//===-- KVXInstrFormats.td - KVX Instruction Formats -------*- tablegen -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

// This is a hack to get an error message as assert does not work
class KVX_Error<string s> {
  dag fail = !dag(ins, []<DAGOperand>, [s]<string>);
}

def IsV1 : Predicate<"Subtarget->isV1()">;
def IsV2 : Predicate<"Subtarget->isV2()">;

// Generic KVX instruction definition.
// It uses multiclass to be able to use defvar and generate input values checking
// to automatically generate a standard dag to be matched as well the output asm.
// It also sets ReadsMem if memory operands is not empty and has
// no output values. And it sets WritesMem if it does have memory
// operands and WritesMem is not set.
// It adds an input operand equals to the output when marked as InPlace.
// or if it is a memory operation with CC. It sets constraint
// $r = $z

// It defines the instruction size depending on the occurence of _X_ or _Y_ in the
// itinenary name. (8, 12 or 4 if not present).

// It sets isPredicable to true if MemOps is not empty and it has no conditional operations

// If the instruction has the modifier SilentMode, it sets mayRaiseFPException to true

// If there is a memory operands and no in/out operands, such as
// I1INVAL, DZEROL ..., the following are set by default:
// mayLoad = 0, mayStore = 0, hasSideEffects = 1

// List of arguments:
// <asm, itin, Ops, Mods, MemOps, CC, Out, InPlace, pattern>

// String to copy/paste on use on definition of NEWINSTRUCTION:
// defm NEWINSTRUCTION : I </*asm=*/, /*itin=*/, /*Ops=*/, /*Mods=*/, /*MemOps=*/, /*CC=*/, /*Out=*/, /*InPlace=*/, /*pattern=*/>;

// Dag to be matched:
// (outs [Out.0:$r]),
// (ins [[MemOps.0:$offset,] MemOps.1:$mem,]
//       [Ops.0:$ops0,[...Ops.N:$opsn,]]
//       [Mods.0:$mod0,...[Mods.N:$modn,]])
//       [Out.0:$z,]
//       [CC.0:$cond, CC.1:$eval]

// Command you can use to debug this:
// ./build_llvm_Debug/bin/llvm-tblgen -I llvm-project/llvm/lib/Target/KVX -I build_llvm_Debug/include -I llvm-project/llvm/include -I llvm-project/llvm/lib/Target llvm-project/llvm/lib/Target/KVX/KVX.td --print-detailed-records

multiclass I <string asm,
         InstrItinClass itin,
         list<DAGOperand> Ops = [],
         list<DAGOperand> ModsAll = [],
         list<DAGOperand> MemOps = [],
         list<DAGOperand> CC = [],
         list<DAGOperand> Out = [],
         bit InPlace = 0,
         list<dag> pat = []> {

    // Filter out Qindex for generating the asm string from Mods and keep it in the dag
    defvar Mods = !filter(i, ModsAll, !not(!eq(i, QindexMod)));
    defvar Qindex = !filter(i, ModsAll, !eq(i, QindexMod));
    defvar EmptyList = []<string>;
    defvar EmptyOutDag = !dag(outs, []<DAGOperand>, []<string>);
    defvar EmptyInDag = !dag(ins, []<DAGOperand>, []<string>);

    // Out holds the output type, e.g. VectorReg, or none, if the instruction does not generate a value.
    defvar MemOpsTst = !gt(!size(MemOps), 2);
    if MemOpsTst then {
      def : KVX_Error<!strconcat("Can't handle instructions with ", !cast<string>(!size(MemOps)), " memory operands.")>;
    }
    defvar ModifsTst = !gt(!size(ModsAll), 3);
    if ModifsTst then {
      def : KVX_Error<!strconcat("Can't handle instructions with ", !cast<string>(!size(ModsAll)), " modifiers.")>;
    }

    defvar OutTst = !gt(!size(Out), 1);
    if OutTst then {
      def : KVX_Error<!strconcat("Can't handle instructions with ", !cast<string>(!size(Out)), " Out operands.")>;
    }

    defvar CCTst = !not(!or(!empty(CC), !eq(!size(CC), 2)));
    if CCTst then {
      def : KVX_Error<!strconcat("Can't handle instructions with ", !cast<string>(!size(CC)), " CC operands")>;
    }

    defvar OpsTst = !gt(!size(Ops), 3);
    if OpsTst then {
      def : KVX_Error<!strconcat("Can't handle instructions with ", !cast<string>(!size(Ops)), " operands.")>;
    }

    defvar AsmTst = !or(!empty(asm), !not(!isa<string>(asm)));
    if AsmTst then {
      def : KVX_Error<"Instruction should have an asm string.">;
    }

    defvar HasntItin = !and(!eq(NoItinerary, itin), !isa<InstrItinClass>(itin));
    if HasntItin then {
      def : KVX_Error<"Instruction should be given an itinerary.">;
    }

    defvar MemDag = !cond(!eq(!size(MemOps), 1): !dag(ins, MemOps, ["mem"]<string>),
                          !eq(!size(MemOps), 2): !dag(ins, MemOps, ["off", "mem"]<string>),
                          true: EmptyInDag);

    defvar OpsDag = !cond(!empty(Ops): EmptyInDag,
                          !eq(!size(Ops), 1): !dag(ins, Ops, ["op0"]),
                          !eq(!size(Ops), 2): !dag(ins, Ops, ["op0", "op1"]),
                          !eq(!size(Ops), 3): !dag(ins, Ops, ["op0", "op1", "op2"]));

    defvar ModsDag = !cond(!empty(ModsAll): EmptyInDag,
                           !eq(!size(ModsAll), 1): !dag(ins, ModsAll, ["mod0"]),
                           !eq(!size(ModsAll), 2): !dag(ins, ModsAll, ["mod0", "mod1"]),
                           !eq(!size(ModsAll), 3): !dag(ins, ModsAll, ["mod0", "mod1", "mod2"]));

    defvar InOutDag = !cond(!and(!not(!empty(Out)), !or(InPlace, !not(!empty(CC)))): !dag(ins, Out, ["z"]<string>),
                            true : EmptyInDag);

    defvar CCDag = !cond(!empty(CC): EmptyInDag,
                         true: !dag(ins, CC, ["cond", "val"]<string>));

    defvar Ins = !con(EmptyInDag, MemDag, OpsDag, ModsDag, InOutDag, CCDag);

    defvar ModsStr = !cond(!empty(Mods): "",
                      !eq(!size(Mods), 1): "$mod0",
                      !eq(!size(Mods), 2): "$mod0$mod1",
                      !eq(!size(Mods), 3): "$mod0$mod1$mod2");

    defvar QindexStr = !if(!empty(Qindex), "", "$mod" # !cast<string>(!size(Mods)));
    defvar CC_Qindex_str = !if(!empty(CC), QindexStr, "$cond" # QindexStr # " $val ?");

    defvar OutStr = !cond(!empty(Out) : "",
                          true : " $r");

    defvar OpsStr = !cond(!empty(Ops): "",
                          !eq(!size(Ops), 1): " $op0",
                          !eq(!size(Ops), 2): " $op0, $op1",
                          !eq(!size(Ops), 3): " $op0, $op1, $op2");

    defvar MemOpStr = !cond(!empty(MemOps) : "",
                            !eq(!size(MemOps), 1): " [$mem]",
                            true: " $off[$mem]");

    // Check if one of the elements of Mods is SilentMode, that returns a non-empty list with !filter
    defvar mayRaiseFPE = !not(!empty(!filter(i, Mods, !eq(i, SilentMod))));

    defvar MemOperation = !and(!empty(Out), !empty(Ops));
    defvar ReadsMem = !not(!or(!empty(MemOps), !empty(Out), MemOperation));
    defvar WritesMem = !xor(!xor(ReadsMem, !not(!empty(MemOps))), MemOperation);

    defvar CanPredicate = !and(!empty(CC), !not(!empty(MemOps)));
    // Should we add an inplace register in the input dag?
    defvar AsmStr = !cond( !eq(WritesMem, 0) : !strconcat(asm, ModsStr, CC_Qindex_str, OutStr, " =", MemOpStr, OpsStr),
                           !eq(WritesMem, 1) : !strconcat(asm, ModsStr, CC_Qindex_str, OutStr, MemOpStr, " =", OpsStr));

    defvar ItirName = !cast<string>(itin);
    defvar InstSz = !cond(!ne(ItirName, !subst("_Y_", "", ItirName)): 12,
                          !ne(ItirName, !subst("_X_", "", ItirName)): 8,
                          true : 4);
// We define an "unamed" instruction, so it will be just the name of the definition it self.
  def "" : Instruction {
    let Pattern = pat;
    let Itinerary = itin;
    let OutOperandList = !cond(!empty(Out) : EmptyOutDag,
                               true : !dag(outs, Out, ["r"]));
    let InOperandList = Ins;
    let AsmString = AsmStr;
    let hasCompleteDecoder = false;
    let Namespace = "KVX";
    let hasSideEffects = MemOperation;
    let mayLoad = ReadsMem;
    let mayStore = WritesMem;
    let Size = InstSz;
    let Constraints = !cond(!ne(InPlace, 0): "$r = $z", true : "");
    let isPredicable = CanPredicate;
    let mayRaiseFPException = mayRaiseFPE;
 }
}

multiclass MC_SIMPE<string OpcStr, InstrItinClass i, list<dag> pat = []>
      : I </*asm=*/OpcStr , /*itin=*/ i, /*Ops=*/[], /*Mods=*/[], /*MemOps=*/[], /*CC=*/[], /*Out=*/[], /*InPlace=*/0, /*pattern=*/pat>;

multiclass MC_LOADS<string OpcStr, RegisterClass RC> {
  defm ri10 : I <OpcStr, LSU_AUXW_LOAD, [], [VariantMod], [Signed10, SingleReg], [], [RC]>;
  defm ri37 : I <OpcStr, LSU_AUXW_X_LOAD, [], [VariantMod], [Signed37, SingleReg], [], [RC]>;
  defm ri64 : I <OpcStr, LSU_AUXW_Y_LOAD, [], [VariantMod], [Wrapped64, SingleReg], [], [RC]>;
  defm rr   : I <OpcStr, LSU_AUXW_LOAD, [], [VariantMod, DoscaleMod], [SingleReg, SingleReg], [], [RC]>;
  defm rrc  : I <OpcStr, LSU_AUXW_LOAD, [], [VariantMod], [SingleReg], [ScalarcondMod, SingleReg], [RC]>;
  defm ri27c: I <OpcStr, LSU_AUXW_X_LOAD, [], [VariantMod], [Signed27, SingleReg], [ScalarcondMod, SingleReg], [RC]>;
  defm ri54c: I <OpcStr, LSU_AUXW_Y_LOAD, [], [VariantMod], [Signed54, SingleReg], [ScalarcondMod, SingleReg], [RC]>;
}

multiclass MC_STORES<string OpcStr, RegisterClass RC> {
  defm ri10 : I <OpcStr, LSU_AUXR_STORE, [RC], [], [Signed10, SingleReg], [], []>;
  defm ri37 : I <OpcStr, LSU_AUXR_X_STORE, [RC], [], [Signed37, SingleReg], [], []>;
  defm ri64 : I <OpcStr, LSU_AUXR_Y_STORE, [RC], [], [Wrapped64, SingleReg], [], []>;
  defm rr   : I <OpcStr, LSU_AUXR_STORE, [RC], [DoscaleMod], [SingleReg, SingleReg], [], []>;
  defm rrc  : I <OpcStr, LSU_AUXR_STORE, [RC], [], [SingleReg], [ScalarcondMod, SingleReg], []>;
  defm ri27c: I <OpcStr, LSU_AUXR_X_STORE, [RC], [], [Signed27, SingleReg], [ScalarcondMod, SingleReg], []>;
  defm ri54c: I <OpcStr, LSU_AUXR_Y_STORE, [RC], [], [Signed54, SingleReg], [ScalarcondMod, SingleReg], []>;
}

multiclass MC_LV<string OpcStr> {
  defm ri10  : I <OpcStr, LSU_LOAD, [], [SpeculateMod], [Signed10, SingleReg], [], [VectorReg], 0,
                  [(set v256i1:$r, (int_kvx_lv  (add SingleReg:$mem, Signed10:$off), SpeculateMod:$mod0))]>;
  defm ri37  : I <OpcStr, LSU_X_LOAD, [], [SpeculateMod], [Signed37, SingleReg], [], [VectorReg], 0,
                  [(set v256i1:$r, (int_kvx_lv  (add SingleReg:$mem, Signed37:$off), SpeculateMod:$mod0))]>;
  defm ri64  : I <OpcStr, LSU_Y_LOAD, [], [SpeculateMod], [Signed37, SingleReg], [], [VectorReg], 0,
                  [(set v256i1:$r, (int_kvx_lv  (add SingleReg:$mem, Wrapped64:$off), SpeculateMod:$mod0))]>;
  defm rr    : I <OpcStr, LSU_LOAD, [], [SpeculateMod, DoscaleMod], [SingleReg, SingleReg], [], [VectorReg]>;

  defm ri27c : I <OpcStr, LSU_X_LOAD, [], [SpeculateMod], [Signed27, SingleReg], [ScalarcondMod, SingleReg], [VectorReg], 1,
                  [(set v256i1:$r, (int_kvx_lv_cond VectorReg:$z, (add SingleReg:$mem, Signed27:$off),
                                    i64:$val, SpeculateMod:$mod0, ScalarcondMod:$cond))]>;
  defm ri54c : I <OpcStr, LSU_Y_LOAD, [], [SpeculateMod], [Signed54, SingleReg], [ScalarcondMod, SingleReg], [VectorReg], 1,
                  [(set v256i1:$r, (int_kvx_lv_cond VectorReg:$z, (add SingleReg:$mem, Signed54:$off),
                                    i64:$val, SpeculateMod:$mod0, ScalarcondMod:$cond))]>;
  defm rrc   : I <OpcStr, LSU_LOAD, [], [SpeculateMod], [SingleReg], [ScalarcondMod, SingleReg], [VectorReg], 1,
                  [(set v256i1:$r, (int_kvx_lv_cond VectorReg:$z, SingleReg:$mem,
                                    i64:$val, SpeculateMod:$mod0, ScalarcondMod:$cond))]>;

  defm ri10cs : I <OpcStr, LSU_LOAD, [], [ColumnMod, SpeculateMod], [Signed10, SingleReg], [], [MatrixReg], 1,
                  [(set v1024i1:$r, (int_kvx_lvc MatrixReg:$z, (add SingleReg:$mem, Signed10:$off),
                                    ColumnMod:$mod0, SpeculateMod:$mod1))]>;
  defm ri37cs : I <OpcStr, LSU_X_LOAD, [], [ColumnMod, SpeculateMod], [Signed37, SingleReg], [], [MatrixReg], 1,
                  [(set v1024i1:$r, (int_kvx_lvc MatrixReg:$z, (add SingleReg:$mem, Signed37:$off),
                                    ColumnMod:$mod0, SpeculateMod:$mod1))]>;
  defm ri64cs : I <OpcStr, LSU_Y_LOAD, [], [ColumnMod, SpeculateMod], [Wrapped64, SingleReg], [], [MatrixReg], 1,
                  [(set v1024i1:$r, (int_kvx_lvc MatrixReg:$z, (add SingleReg:$mem, Wrapped64:$off),
                                    ColumnMod:$mod0, SpeculateMod:$mod1))]>;
  defm rrcs : I <OpcStr, LSU_LOAD, [], [ColumnMod, SpeculateMod, DoscaleMod], [SingleReg, SingleReg], [], [MatrixReg], 1>;

  defm ri27ccs : I <OpcStr, LSU_X_LOAD, [], [ColumnMod, SpeculateMod], [Signed27, SingleReg], [ScalarcondMod, SingleReg], [MatrixReg], 1,
                  [(set v1024i1:$r, (int_kvx_lvc_cond MatrixReg:$z, (add SingleReg:$mem, Signed27:$off),
                                    i64:$val, ColumnMod:$mod0, SpeculateMod:$mod1, ScalarcondMod:$cond))]>;

  defm ri54ccs : I <OpcStr, LSU_Y_LOAD, [], [ColumnMod, SpeculateMod], [Signed54, SingleReg], [ScalarcondMod, SingleReg], [MatrixReg], 1,
                  [(set v1024i1:$r, (int_kvx_lvc_cond v1024i1:$z, (add SingleReg:$mem, Signed54:$off),
                                    i64:$val, ColumnMod:$mod0, SpeculateMod:$mod1, ScalarcondMod:$cond))]>;
  defm rrccs : I <OpcStr, LSU_LOAD, [], [ColumnMod, SpeculateMod], [SingleReg], [ScalarcondMod, SingleReg], [MatrixReg]>;
}

multiclass MC_XLO <string OpcStr = "xlo"> {
  // xlovariant registerA = signed10[registerZ]
  defm ri10 : I <OpcStr, LSU_LOAD, [], [VariantMod], [Signed10, SingleReg], [], [VectorReg], 0,
                [(set v256i1:$r, (int_kvx_xload256 (add i64:$mem, Signed10:$off), VariantMod:$mod0))]>;
  // xlovariant registerA = upper27 lower10[registerZ]
  defm ri37 : I <OpcStr, LSU_X_LOAD, [], [VariantMod], [Signed37, SingleReg], [], [VectorReg], 0,
                [(set v256i1:$r, (int_kvx_xload256 (add i64:$mem, Signed37:$off), VariantMod:$mod0))]>;
  // xlovariant registerA = extend27 upper27 lower10[registerZ]
  defm ri64 : I <OpcStr, LSU_Y_LOAD, [], [VariantMod], [Wrapped64, SingleReg], [], [VectorReg], 0,
                [(set v256i1:$r, (int_kvx_xload256 (add i64:$mem, Wrapped64:$off), VariantMod:$mod0))]>;

  // xlovariantqindex registerAq = signed10[registerZ]
  defm ri10q : I <OpcStr, LSU_LOAD, [], [VariantMod, QindexMod], [Signed10, SingleReg], [], [MatrixReg], 1,
                [(set v1024i1:$r, (int_kvx_xloads1024 v1024i1:$z, (add i64:$mem, Signed10:$off), VariantMod:$mod0, QindexMod:$mod1))]>;
  // xlovariantqindex registerAq = upper27 lower10[registerZ]
  defm ri37q : I <OpcStr, LSU_X_LOAD, [], [VariantMod, QindexMod], [Signed37, SingleReg], [], [MatrixReg], 1,
                [(set v1024i1:$r, (int_kvx_xloads1024 v1024i1:$z, (add i64:$mem, Signed37:$off), VariantMod:$mod0, QindexMod:$mod1))]>;
  //xlovariantqindex registerAq = extend27 upper27 lower10[registerZ]
  defm ri64q : I <OpcStr, LSU_Y_LOAD, [], [VariantMod, QindexMod], [Wrapped64, SingleReg], [], [MatrixReg], 1,
                [(set v1024i1:$r, (int_kvx_xloads1024 v1024i1:$z, (add i64:$mem, Wrapped64:$off), VariantMod:$mod0, QindexMod:$mod1))]>;

  // xlovariantlsumask registerY? registerA = [registerZ]
  defm rrc    : I <OpcStr, LSU_LOAD, [], [VariantMod], [SingleReg], [LsumaskMod, SingleReg], [VectorReg], 1,
                  [(set v256i1:$r, (int_kvx_xloadc256 v256i1:$z, i64:$mem, i64:$val, VariantMod:$mod0, LsumaskMod:$cond))]>;
  // xlovariantlsumask registerY? registerA = offset27[registerZ]
  defm ri27c : I <OpcStr, LSU_X_LOAD, [], [VariantMod], [Signed27, SingleReg], [LsumaskMod, SingleReg], [VectorReg], 1,
                  [(set v256i1:$r, (int_kvx_xloadc256 v256i1:$z, (add i64:$mem, Signed27:$off), i64:$val, VariantMod:$mod0, LsumaskMod:$cond))]>;
  // xlovariantlsumask registerY? registerA = extend27 offset27[registerZ]
  defm ri54c : I <OpcStr, LSU_Y_LOAD, [], [VariantMod], [Signed54, SingleReg], [LsumaskMod, SingleReg], [VectorReg], 1,
                  [(set v256i1:$r, (int_kvx_xloadc256 v256i1:$z, (add i64:$mem, Signed54:$off), i64:$val, VariantMod:$mod0, LsumaskMod:$cond))]>;

  // xlovariantlsumaskqindex registerY? registerAq = [registerZ]
  defm rrcq    : I <OpcStr, LSU_LOAD, [], [VariantMod, QindexMod], [SingleReg], [LsumaskMod, SingleReg], [MatrixReg], 1,
                  [(set v1024i1:$r, (int_kvx_xloadsc1024 v1024i1:$z, i64:$mem, i64:$val, VariantMod:$mod0, LsumaskMod:$cond, QindexMod:$mod1))]>;
  // xlovariantlsumaskqindex registerY? registerAq = offset27[registerZ]
  defm ri27cq : I <OpcStr, LSU_X_LOAD, [], [VariantMod, QindexMod], [Signed27, SingleReg], [LsumaskMod, SingleReg], [MatrixReg], 1,
                    [(set v1024i1:$r, (int_kvx_xloadsc1024 v1024i1:$z, (add i64:$mem, Signed27:$off), i64:$val, VariantMod:$mod0, LsumaskMod:$cond, QindexMod:$mod1))]>;
  // xlovariantlsumaskqindex registerY? registerAq = extend27 offset27[registerZ]
  defm ri54cq : I <OpcStr, LSU_Y_LOAD, [], [VariantMod, QindexMod], [Signed54, SingleReg], [LsumaskMod, SingleReg], [MatrixReg], 1,
                    [(set v1024i1:$r, (int_kvx_xloadsc1024 v1024i1:$z, (add i64:$mem, Signed54:$off), i64:$val, VariantMod:$mod0, LsumaskMod:$cond, QindexMod:$mod1))]>;

  // Missing 21 definitions that require the TCA buffer here
  // xlovariantdoscale registerA = registerY[registerZ]
  defm rr     : I <OpcStr, LSU_LOAD, [], [VariantMod, DoscaleMod], [SingleReg, SingleReg], [], [VectorReg]>;
  // xlovariantdoscaleqindex registerAq = registerY[registerZ]
  defm rrq    : I <OpcStr, LSU_LOAD, [], [VariantMod, DoscaleMod, QindexMod], [SingleReg, SingleReg], [], [MatrixReg], 1>;
}

multiclass MC_SV <string OpcStr> {
  defm ri10 : I <OpcStr, LSU_CRRP_STORE, [VectorReg], [], [Signed10, SingleReg], [], [], 0,
                 [(int_kvx_sv  (add i64:$mem, Signed10:$off), v256i1:$op0)]>;

  defm ri37 : I <OpcStr, LSU_CRRP_X_STORE, [VectorReg], [], [Signed10, SingleReg], [], [], 0,
                 [(int_kvx_sv  (add i64:$mem, Signed37:$off), v256i1:$op0)]>;

  defm ri64 : I <OpcStr, LSU_CRRP_Y_STORE, [VectorReg], [], [Signed10, SingleReg], [], [], 0,
                 [(int_kvx_sv  (add i64:$mem, Wrapped64:$off), v256i1:$op0)]>;

  defm rr : I <OpcStr, LSU_CRRP_STORE, [VectorReg], [DoscaleMod], [SingleReg, SingleReg]>;

  defm ri27c : I <OpcStr, LSU_CRRP_X_STORE, [VectorReg], [], [Signed27, SingleReg], [ScalarcondMod, SingleReg], [], 0,
                 [(int_kvx_sv_cond  (add i64:$mem, Signed27:$off), v256i1:$op0, i64:$val, ScalarcondMod:$cond)]>;

  defm ri54c : I <OpcStr, LSU_CRRP_Y_STORE, [VectorReg], [], [Signed54, SingleReg], [ScalarcondMod, SingleReg], [], 0,
                 [(int_kvx_sv_cond  (add i64:$mem, Signed54:$off), v256i1:$op0, i64:$val, ScalarcondMod:$cond)]>;

  defm rrc : I <OpcStr, LSU_CRRP_STORE, [VectorReg], [], [SingleReg], [ScalarcondMod, SingleReg], [], 0,
                 [(int_kvx_sv_cond  i64:$mem, v256i1:$op0, i64:$val, ScalarcondMod:$cond)]>;
}

multiclass MC_XSO <string OpcStr = "xso"> {
  // xso signed10[registerZ] = registerE
  defm ri10 : I <OpcStr, LSU_CRRP_STORE, [VectorReg], [], [Signed10, SingleReg], [], [], 0,
                [(int_kvx_xstore256 v256i1:$op0, (add i64:$mem, Signed10:$off))]>;
  // xso upper27 lower10[registerZ] = registerE
  defm ri37 : I <OpcStr, LSU_CRRP_X_STORE, [VectorReg], [], [Signed37, SingleReg], [], [], 0,
                [(int_kvx_xstore256 v256i1:$op0, (add i64:$mem, Signed37:$off))]>;
  // xso extend27 upper27 lower10[registerZ] = registerE
  defm ri64 : I <OpcStr, LSU_CRRP_Y_STORE, [VectorReg], [], [Wrapped64, SingleReg], [], [], 0,
                [(int_kvx_xstore256 v256i1:$op0, (add i64:$mem, Wrapped64:$off))]>;

  // xsolsumask registerY? [registerZ] = registerE
  defm rrc    : I <OpcStr, LSU_CRRP_STORE, [VectorReg], [], [SingleReg], [LsumaskMod, SingleReg], [], 0,
                  [(int_kvx_xstorec256 v256i1:$op0, i64:$mem, i64:$val, LsumaskMod:$cond)]>;
  // xsolsumask registerY? offset27[registerZ] = registerE
  defm ri27c : I <OpcStr, LSU_CRRP_X_STORE, [VectorReg], [], [Signed27, SingleReg], [LsumaskMod, SingleReg], [], 0,
                  [(int_kvx_xstorec256 v256i1:$op0, (add i64:$mem, Signed27:$off), i64:$val, LsumaskMod:$cond)]>;
  // xsolsumask registerY? extend27 offset27[registerZ] = registerE
  defm ri54c : I <OpcStr, LSU_CRRP_Y_STORE, [VectorReg], [], [Signed54, SingleReg], [LsumaskMod, SingleReg], [], 0,
                  [(int_kvx_xstorec256 v256i1:$op0, (add i64:$mem, Signed54:$off), i64:$val, LsumaskMod:$cond)]>;

  // xsodoscale registerY[registerZ] = registerE
  defm rr     : I <OpcStr, LSU_CRRP_STORE, [VectorReg], [DoscaleMod], [SingleReg, SingleReg], [], []>;
}

class KVX_INSTRUCTION
  <dag outs, dag ins, string asmstr, list<dag> pattern, InstrItinClass itin,
   int syllables=1>
  : Instruction {
    dag OutOperandList = outs;
    dag InOperandList = ins;
    let AsmString = asmstr;
    let Pattern = pattern;
    let Itinerary = itin;
    let Namespace = "KVX";
    let hasCompleteDecoder = false;
    let Size = !mul(syllables, 4);
  }

class KVX_INSTRUCTION_X
  <dag outs, dag ins, string asmstr, list<dag> pattern, InstrItinClass itin>
  : KVX_INSTRUCTION <outs, ins, asmstr, pattern, itin, 2>;

class KVX_INSTRUCTION_Y
  <dag outs, dag ins, string asmstr, list<dag> pattern, InstrItinClass itin>
  : KVX_INSTRUCTION <outs, ins, asmstr, pattern, itin, 3>;

class KVX_PSEUDO
  <dag outs, dag ins, list<dag> pattern, string asmstr = "pseudo">
  : KVX_INSTRUCTION <outs, ins, asmstr, pattern, NoItinerary, 0> {
    let isPseudo = 1;
    let isCodeGenOnly = 1;
    let hasNoSchedulingInfo = 1;
  }

class KVX_PSEUDO_W_SCHEDINFO
  <dag outs, dag ins, list<dag> pattern, InstrItinClass itin, string asmstr = "pseudo">
  : KVX_INSTRUCTION <outs, ins, asmstr, pattern, itin, 0> {
    let isPseudo = 1;
    let isCodeGenOnly = 1;
    let Itinerary = itin;
  }

let Constraints = "$out = $acc" in
class ROUNDING_SILENT_TERNARY_AUXR_FP <string OpcStr, RegisterClass RC_OUT, RegisterClass RC_IN, InstrItinClass itin>
  : KVX_INSTRUCTION <
    (outs RC_OUT:$out),
    (ins RC_OUT:$acc, RC_IN:$lhs, RC_IN:$rhs, RoundingMod:$r, SilentMod:$s),
    !strconcat (OpcStr, "$r$s $out = $lhs, $rhs"),
    [],
    itin>;

let Constraints = "$o = $a" in
class TERNARY<string Opcode, RegisterClass RC_OUT, RegisterClass RC_LHS, RegisterClass RC_RHS, InstrItinClass Itin, list<dag> Patt = []>
    : KVX_INSTRUCTION <
     (outs RC_OUT:$o),
     (ins RC_OUT:$a, RC_LHS:$lhs, RC_RHS:$rhs),
     !strconcat (Opcode, " $o = $lhs, $rhs"),
     Patt,
     Itin>;

let Constraints = "$o = $a" in
class ROUNDING_SILENT_TERNARY <string Opcode, RegisterClass RC_OUT, RegisterClass RC_LHS, RegisterClass RC_RHS, InstrItinClass Itin, list<dag> Patt = []>
    : KVX_INSTRUCTION <
     (outs RC_OUT:$o),
     (ins RC_OUT:$a, RC_LHS:$lhs, RC_RHS:$rhs, RoundingMod:$r, SilentMod:$s),
     !strconcat (Opcode, "$r$s $o = $lhs, $rhs"),
     Patt,
     Itin>;

class ROUNDING_SILENT_UNARY<string Opcode, RegisterClass RC_OUT, RegisterClass RC_IN, InstrItinClass Itin, list<dag> Patt = []>
    : KVX_INSTRUCTION <
     (outs RC_OUT:$o),
     (ins RC_IN:$i, RoundingMod:$r, SilentMod:$s),
     !strconcat (Opcode, "$r$s $o = $i"),
     Patt,
     Itin>;

class UNARY <string Opcode, RegisterClass RC_OUT, RegisterClass RC_IN, InstrItinClass Itin, list<dag> Patt = []>
    : KVX_INSTRUCTION <
     (outs RC_OUT:$o),
     (ins RC_IN:$i),
     !strconcat (Opcode, " $o = $i"),
     Patt,
     Itin>;

class ROUNDING_SILENT_BINOP<string Opcode, RegisterClass RC_OUT, RegisterClass RC_LHS, RegisterClass RC_RHS, InstrItinClass Itin, list<dag> Patt = []>
    : KVX_INSTRUCTION <
     (outs RC_OUT:$o),
     (ins RC_LHS:$lhs, RC_RHS:$rhs, RoundingMod:$r, SilentMod:$s),
     !strconcat (Opcode, "$r$s $o = $lhs, $rhs"),
     Patt,
     Itin>;

class CACHE_OP<string Opcode, RegisterClass RC, InstrItinClass Itin, list<dag> Patt = []>
    : KVX_INSTRUCTION <
     (outs),
     (ins RC:$way, RC:$set, CacheLevelMod:$c),
     !strconcat (Opcode, "$c $set, $way"),
     Patt,
     Itin>;

class ROUNDING_SILENT_BINOP_FFDM<string OpcStr, RegisterClass RC_OUT, RegisterClass RC_IN, InstrItinClass itin>
    : ROUNDING_SILENT_BINOP <OpcStr, RC_OUT, RC_IN, RC_IN, itin>;


class CONJ_ROUNDING_SILENT_BINOP<string OpcStr, RegisterClass RC_OUT, RegisterClass RC_IN, InstrItinClass itin>
    : KVX_INSTRUCTION <
     (outs RC_OUT:$o),
     (ins RC_IN:$lhs, RC_IN:$rhs, ConjugateMod:$c, RoundingMod:$r, SilentMod:$s),
     !strconcat (OpcStr, "$c$r$s $o = $lhs, $rhs"),
     [/* no straightforward pattern */],
     itin>;

class KVX_INSTRUCTION_CV1_X
  <dag outs, dag ins, string asmstr, list<dag> pattern,
   InstrItinClass itin>
  : KVX_INSTRUCTION_X <outs, ins, asmstr, pattern, itin> {
    let Predicates = [IsV1];
  }

class KVX_INSTRUCTION_CV1_Y
  <dag outs, dag ins, string asmstr, list<dag> pattern,
   InstrItinClass itin>
  : KVX_INSTRUCTION_Y <outs, ins, asmstr, pattern, itin> {
    let Predicates = [IsV1];
  }

class KVX_INSTRUCTION_CV2
  <dag outs, dag ins, string asmstr, list<dag> pattern,
   InstrItinClass itin>
  : KVX_INSTRUCTION <outs, ins, asmstr, pattern, itin> {
    let Predicates = [IsV2];
  }
