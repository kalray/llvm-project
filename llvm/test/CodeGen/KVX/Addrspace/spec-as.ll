; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -o - %s -O2 | FileCheck %s --check-prefixes=CHECK
; RUN: llc -mcpu=kv3-2 -o - %s -O2 | FileCheck %s --check-prefixes=CHECK
; RUN: clang -O2 -c -o /dev/null %s
; RUN: clang -O2 -march=kv3-2 -c -o /dev/null %s

target triple = "kvx-kalray-cos"

%struct.S = type { i32, i32, i32, i32 }

define i8 @speculative_i8(ptr addrspace(258) nocapture readonly %i){
; CHECK-LABEL: speculative_i8:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lbz.s $r0 = 0[$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %0 = load i8, ptr addrspace(258) %i, align 1
  ret i8 %0
}

define i16 @speculative_i16(ptr addrspace(258) nocapture readonly %i){
; CHECK-LABEL: speculative_i16:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lhz.s $r0 = 0[$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %0 = load i16, ptr addrspace(258) %i, align 2
  ret i16 %0
}

define i32 @speculative_i32(ptr addrspace(258) nocapture readonly %i){
; CHECK-LABEL: speculative_i32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lwz.s $r0 = 0[$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %0 = load i32, ptr addrspace(258) %i, align 4
  ret i32 %0
}

define i64 @speculative_i64(ptr addrspace(258) nocapture readonly %i){
; CHECK-LABEL: speculative_i64:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ld.s $r0 = 0[$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %0 = load i64, ptr addrspace(258) %i, align 8
  ret i64 %0
}

define float @fspeculative_f32(ptr addrspace(258) nocapture readonly %f){
; CHECK-LABEL: fspeculative_f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lwz.s $r0 = 0[$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %0 = load float, ptr addrspace(258) %f, align 4
  ret float %0
}

define double @fspeculative_f64(ptr addrspace(258) nocapture readonly %d){
; CHECK-LABEL: fspeculative_f64:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ld.s $r0 = 0[$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %0 = load double, ptr addrspace(258) %d, align 8
  ret double %0
}

define <2 x float> @fspeculative_v2f32(ptr addrspace(258) nocapture readonly %v){
; CHECK-LABEL: fspeculative_v2f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ld.s $r0 = 0[$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %0 = load <2 x float>, ptr addrspace(258) %v, align 8
  ret <2 x float> %0
}

define <4 x float> @fspeculative_v4f32(ptr addrspace(258) nocapture readonly %v){
; CHECK-LABEL: fspeculative_v4f32:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lq.s $r0r1 = 0[$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %0 = load <4 x float>, ptr addrspace(258) %v, align 16
  ret <4 x float> %0
}

define i32 @foo_speculative_a(%struct.S addrspace(258)* nocapture readonly %s){
; CHECK-LABEL: foo_speculative_a:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lwz.s $r0 = 0[$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %a = getelementptr inbounds %struct.S, %struct.S addrspace(258)* %s, i64 0, i32 0
  %0 = load i32, ptr addrspace(258) %a, align 4
  ret i32 %0
}

define i32 @foo_speculative_b(%struct.S addrspace(258)* nocapture readonly %s){
; CHECK-LABEL: foo_speculative_b:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lwz.s $r0 = 4[$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %b = getelementptr inbounds %struct.S, %struct.S addrspace(258)* %s, i64 0, i32 1
  %0 = load i32, ptr addrspace(258) %b, align 4
  ret i32 %0
}

define i32 @foo_speculative_c(%struct.S addrspace(258)* nocapture readonly %s){
; CHECK-LABEL: foo_speculative_c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lwz.s $r0 = 8[$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %c = getelementptr inbounds %struct.S, %struct.S addrspace(258)* %s, i64 0, i32 2
  %0 = load i32, ptr addrspace(258) %c, align 4
  ret i32 %0
}

define i32 @foo_speculative_d(%struct.S addrspace(258)* nocapture readonly %s){
; CHECK-LABEL: foo_speculative_d:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lwz.s $r0 = 12[$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %d = getelementptr inbounds %struct.S, %struct.S addrspace(258)* %s, i64 0, i32 3
  %0 = load i32, ptr addrspace(258) %d, align 4
  ret i32 %0
}

define i32 @foo_speculative_3(ptr addrspace(258) nocapture readonly %v){
; CHECK-LABEL: foo_speculative_3:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lwz.s $r0 = 12[$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %0 = load <4 x i32>, ptr addrspace(258) %v, align 16
  %vecext = extractelement <4 x i32> %0, i32 3
  ret i32 %vecext
}

define i32 @foo_speculative_x(ptr addrspace(258) nocapture readonly %v, i32 %x){
; CHECK-LABEL: foo_speculative_x:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    andw $r1 = $r1, 3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    lwz.s.xs $r0 = $r1[$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
entry:
  %0 = load <4 x i32>, ptr addrspace(258) %v, align 16
  %vecext = extractelement <4 x i32> %0, i32 %x
  ret i32 %vecext
}
