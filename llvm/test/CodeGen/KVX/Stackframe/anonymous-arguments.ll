; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc --frame-pointer=none -o - %s | FileCheck -check-prefix=FP-NONE %s
; RUN: llc --frame-pointer=all -o - %s | FileCheck -check-prefix=FP-ALL %s

target triple = "kvx-kalray-cos"

; Original C code:
;
; #include <stdarg.h>
;
; int add(int n, ...) {
; int sum = 0;
;
; va_list args;
; va_start(args, n);
;
; for(int i = 0; i < n; i++ )
; sum += va_arg(args, int);
;
; va_end(args);
;
; return sum;
; }

define i32 @add(i32 %n, ...) {
; FP-NONE-LABEL: add:
; FP-NONE:       # %bb.0: # %entry
; FP-NONE-NEXT:    addd $r12 = $r12, -96
; FP-NONE-NEXT:    ;; # (end cycle 0)
; FP-NONE-NEXT:    sd 88[$r12] = $r11
; FP-NONE-NEXT:    ;; # (end cycle 1)
; FP-NONE-NEXT:    sd 80[$r12] = $r10
; FP-NONE-NEXT:    ;; # (end cycle 2)
; FP-NONE-NEXT:    sd 72[$r12] = $r9
; FP-NONE-NEXT:    ;; # (end cycle 3)
; FP-NONE-NEXT:    sd 64[$r12] = $r8
; FP-NONE-NEXT:    ;; # (end cycle 4)
; FP-NONE-NEXT:    sd 56[$r12] = $r7
; FP-NONE-NEXT:    ;; # (end cycle 5)
; FP-NONE-NEXT:    sd 48[$r12] = $r6
; FP-NONE-NEXT:    ;; # (end cycle 6)
; FP-NONE-NEXT:    sd 40[$r12] = $r5
; FP-NONE-NEXT:    ;; # (end cycle 7)
; FP-NONE-NEXT:    sd 32[$r12] = $r4
; FP-NONE-NEXT:    ;; # (end cycle 8)
; FP-NONE-NEXT:    sd 24[$r12] = $r3
; FP-NONE-NEXT:    ;; # (end cycle 9)
; FP-NONE-NEXT:    sd 16[$r12] = $r2
; FP-NONE-NEXT:    ;; # (end cycle 10)
; FP-NONE-NEXT:    sd 8[$r12] = $r1
; FP-NONE-NEXT:    addd $r1 = $r12, 8
; FP-NONE-NEXT:    ;; # (end cycle 11)
; FP-NONE-NEXT:    sd 0[$r12] = $r1
; FP-NONE-NEXT:    cb.wlez $r0 ? .LBB0_3
; FP-NONE-NEXT:    ;; # (end cycle 12)
; FP-NONE-NEXT:  # %bb.1: # %for.body.preheader
; FP-NONE-NEXT:    andw $r1 = $r0, 7
; FP-NONE-NEXT:    ld $r2 = 0[$r12]
; FP-NONE-NEXT:    compw.ltu $r3 = $r0, 8
; FP-NONE-NEXT:    ;; # (end cycle 0)
; FP-NONE-NEXT:    cb.even $r3 ? .LBB0_4
; FP-NONE-NEXT:    ;;
; FP-NONE-NEXT:  # %bb.2:
; FP-NONE-NEXT:    make $r0 = 0
; FP-NONE-NEXT:    goto .LBB0_6
; FP-NONE-NEXT:    ;; # (end cycle 0)
; FP-NONE-NEXT:  .LBB0_3:
; FP-NONE-NEXT:    make $r0 = 0
; FP-NONE-NEXT:    addd $r12 = $r12, 96
; FP-NONE-NEXT:    ret
; FP-NONE-NEXT:    ;; # (end cycle 0)
; FP-NONE-NEXT:  .LBB0_4: # %for.body.preheader.new
; FP-NONE-NEXT:    andw $r0 = $r0, 0x7ffffff8
; FP-NONE-NEXT:    ;; # (end cycle 0)
; FP-NONE-NEXT:    addw $r0 = $r0, -8
; FP-NONE-NEXT:    ;; # (end cycle 1)
; FP-NONE-NEXT:    srld $r0 = $r0, 3
; FP-NONE-NEXT:    ;; # (end cycle 2)
; FP-NONE-NEXT:    make $r0 = 0
; FP-NONE-NEXT:    addd $r3 = $r0, 1
; FP-NONE-NEXT:    ;; # (end cycle 3)
; FP-NONE-NEXT:    loopdo $r3, .__LOOPDO_1_END_
; FP-NONE-NEXT:    ;;
; FP-NONE-NEXT:  .LBB0_5: # %for.body
; FP-NONE-NEXT:    # =>This Inner Loop Header: Depth=1
; FP-NONE-NEXT:    addd $r3 = $r2, 8
; FP-NONE-NEXT:    ;; # (end cycle 0)
; FP-NONE-NEXT:    sd 0[$r12] = $r3
; FP-NONE-NEXT:    ;; # (end cycle 1)
; FP-NONE-NEXT:    lwz $r3 = 0[$r2]
; FP-NONE-NEXT:    ;; # (end cycle 2)
; FP-NONE-NEXT:    lwz $r4 = 8[$r2]
; FP-NONE-NEXT:    ;; # (end cycle 3)
; FP-NONE-NEXT:    lwz $r5 = 16[$r2]
; FP-NONE-NEXT:    ;; # (end cycle 4)
; FP-NONE-NEXT:    addw $r0 = $r3, $r0
; FP-NONE-NEXT:    lwz $r3 = 24[$r2]
; FP-NONE-NEXT:    ;; # (end cycle 5)
; FP-NONE-NEXT:    addw $r0 = $r0, $r4
; FP-NONE-NEXT:    lwz $r4 = 32[$r2]
; FP-NONE-NEXT:    ;; # (end cycle 6)
; FP-NONE-NEXT:    addw $r0 = $r0, $r5
; FP-NONE-NEXT:    lwz $r5 = 40[$r2]
; FP-NONE-NEXT:    ;; # (end cycle 7)
; FP-NONE-NEXT:    addw $r0 = $r0, $r3
; FP-NONE-NEXT:    lwz $r3 = 48[$r2]
; FP-NONE-NEXT:    ;; # (end cycle 8)
; FP-NONE-NEXT:    addw $r0 = $r0, $r4
; FP-NONE-NEXT:    addd $r2 = $r2, 64
; FP-NONE-NEXT:    lwz $r4 = 56[$r2]
; FP-NONE-NEXT:    ;; # (end cycle 9)
; FP-NONE-NEXT:    sd 0[$r12] = $r2
; FP-NONE-NEXT:    addw $r0 = $r0, $r5
; FP-NONE-NEXT:    ;; # (end cycle 10)
; FP-NONE-NEXT:    addw $r0 = $r0, $r3
; FP-NONE-NEXT:    ;; # (end cycle 11)
; FP-NONE-NEXT:    addw $r0 = $r0, $r4
; FP-NONE-NEXT:    ;; # (end cycle 12)
; FP-NONE-NEXT:  .__LOOPDO_1_END_:
; FP-NONE-NEXT:  .LBB0_6: # %for.cond.cleanup.loopexit.unr-lcssa
; FP-NONE-NEXT:    cb.weqz $r1 ? .LBB0_9
; FP-NONE-NEXT:    ;;
; FP-NONE-NEXT:  # %bb.7: # %for.body.epil.preheader
; FP-NONE-NEXT:    addw $r1 = $r1, -1
; FP-NONE-NEXT:    ;; # (end cycle 0)
; FP-NONE-NEXT:    addd $r1 = $r2, 8
; FP-NONE-NEXT:    addd $r3 = $r1, 1
; FP-NONE-NEXT:    ;; # (end cycle 1)
; FP-NONE-NEXT:    loopdo $r3, .__LOOPDO_0_END_
; FP-NONE-NEXT:    ;;
; FP-NONE-NEXT:  .LBB0_8: # %for.body.epil
; FP-NONE-NEXT:    # =>This Inner Loop Header: Depth=1
; FP-NONE-NEXT:    sd 0[$r12] = $r1
; FP-NONE-NEXT:    ;; # (end cycle 0)
; FP-NONE-NEXT:    addd $r1 = $r1, 8
; FP-NONE-NEXT:    lwz $r2 = -8[$r1]
; FP-NONE-NEXT:    ;; # (end cycle 1)
; FP-NONE-NEXT:    addw $r0 = $r2, $r0
; FP-NONE-NEXT:    ;; # (end cycle 4)
; FP-NONE-NEXT:  .__LOOPDO_0_END_:
; FP-NONE-NEXT:  .LBB0_9: # %for.cond.cleanup
; FP-NONE-NEXT:    addd $r12 = $r12, 96
; FP-NONE-NEXT:    ret
; FP-NONE-NEXT:    ;; # (end cycle 0)
;
; FP-ALL-LABEL: add:
; FP-ALL:       # %bb.0: # %entry
; FP-ALL-NEXT:    addd $r12 = $r12, -128
; FP-ALL-NEXT:    get $r16 = $ra
; FP-ALL-NEXT:    ;; # (end cycle 0)
; FP-ALL-NEXT:    sd 32[$r12] = $r16
; FP-ALL-NEXT:    ;; # (end cycle 1)
; FP-ALL-NEXT:    sd 24[$r12] = $r14
; FP-ALL-NEXT:    addd $r14 = $r12, 24
; FP-ALL-NEXT:    ;; # (end cycle 2)
; FP-ALL-NEXT:    sd 96[$r14] = $r11
; FP-ALL-NEXT:    ;; # (end cycle 3)
; FP-ALL-NEXT:    sd 88[$r14] = $r10
; FP-ALL-NEXT:    ;; # (end cycle 4)
; FP-ALL-NEXT:    sd 80[$r14] = $r9
; FP-ALL-NEXT:    ;; # (end cycle 5)
; FP-ALL-NEXT:    sd 72[$r14] = $r8
; FP-ALL-NEXT:    ;; # (end cycle 6)
; FP-ALL-NEXT:    sd 64[$r14] = $r7
; FP-ALL-NEXT:    ;; # (end cycle 7)
; FP-ALL-NEXT:    sd 56[$r14] = $r6
; FP-ALL-NEXT:    ;; # (end cycle 8)
; FP-ALL-NEXT:    sd 48[$r14] = $r5
; FP-ALL-NEXT:    ;; # (end cycle 9)
; FP-ALL-NEXT:    sd 40[$r14] = $r4
; FP-ALL-NEXT:    ;; # (end cycle 10)
; FP-ALL-NEXT:    sd 32[$r14] = $r3
; FP-ALL-NEXT:    ;; # (end cycle 11)
; FP-ALL-NEXT:    sd 24[$r14] = $r2
; FP-ALL-NEXT:    ;; # (end cycle 12)
; FP-ALL-NEXT:    sd 16[$r14] = $r1
; FP-ALL-NEXT:    addd $r1 = $r14, 16
; FP-ALL-NEXT:    ;; # (end cycle 13)
; FP-ALL-NEXT:    sd -8[$r14] = $r1
; FP-ALL-NEXT:    cb.wlez $r0 ? .LBB0_3
; FP-ALL-NEXT:    ;; # (end cycle 14)
; FP-ALL-NEXT:  # %bb.1: # %for.body.preheader
; FP-ALL-NEXT:    andw $r1 = $r0, 7
; FP-ALL-NEXT:    ld $r2 = -8[$r14]
; FP-ALL-NEXT:    compw.ltu $r3 = $r0, 8
; FP-ALL-NEXT:    ;; # (end cycle 0)
; FP-ALL-NEXT:    cb.even $r3 ? .LBB0_4
; FP-ALL-NEXT:    ;;
; FP-ALL-NEXT:  # %bb.2:
; FP-ALL-NEXT:    make $r0 = 0
; FP-ALL-NEXT:    goto .LBB0_6
; FP-ALL-NEXT:    ;; # (end cycle 0)
; FP-ALL-NEXT:  .LBB0_3:
; FP-ALL-NEXT:    make $r0 = 0
; FP-ALL-NEXT:    goto .LBB0_9
; FP-ALL-NEXT:    ;; # (end cycle 0)
; FP-ALL-NEXT:  .LBB0_4: # %for.body.preheader.new
; FP-ALL-NEXT:    andw $r0 = $r0, 0x7ffffff8
; FP-ALL-NEXT:    ;; # (end cycle 0)
; FP-ALL-NEXT:    addw $r0 = $r0, -8
; FP-ALL-NEXT:    ;; # (end cycle 1)
; FP-ALL-NEXT:    srld $r0 = $r0, 3
; FP-ALL-NEXT:    ;; # (end cycle 2)
; FP-ALL-NEXT:    make $r0 = 0
; FP-ALL-NEXT:    addd $r3 = $r0, 1
; FP-ALL-NEXT:    ;; # (end cycle 3)
; FP-ALL-NEXT:    loopdo $r3, .__LOOPDO_1_END_
; FP-ALL-NEXT:    ;;
; FP-ALL-NEXT:  .LBB0_5: # %for.body
; FP-ALL-NEXT:    # =>This Inner Loop Header: Depth=1
; FP-ALL-NEXT:    addd $r3 = $r2, 8
; FP-ALL-NEXT:    ;; # (end cycle 0)
; FP-ALL-NEXT:    sd -8[$r14] = $r3
; FP-ALL-NEXT:    ;; # (end cycle 1)
; FP-ALL-NEXT:    lwz $r3 = 0[$r2]
; FP-ALL-NEXT:    ;; # (end cycle 2)
; FP-ALL-NEXT:    lwz $r4 = 8[$r2]
; FP-ALL-NEXT:    ;; # (end cycle 3)
; FP-ALL-NEXT:    lwz $r5 = 16[$r2]
; FP-ALL-NEXT:    ;; # (end cycle 4)
; FP-ALL-NEXT:    addw $r0 = $r3, $r0
; FP-ALL-NEXT:    lwz $r3 = 24[$r2]
; FP-ALL-NEXT:    ;; # (end cycle 5)
; FP-ALL-NEXT:    addw $r0 = $r0, $r4
; FP-ALL-NEXT:    lwz $r4 = 32[$r2]
; FP-ALL-NEXT:    ;; # (end cycle 6)
; FP-ALL-NEXT:    addw $r0 = $r0, $r5
; FP-ALL-NEXT:    lwz $r5 = 40[$r2]
; FP-ALL-NEXT:    ;; # (end cycle 7)
; FP-ALL-NEXT:    addw $r0 = $r0, $r3
; FP-ALL-NEXT:    lwz $r3 = 48[$r2]
; FP-ALL-NEXT:    ;; # (end cycle 8)
; FP-ALL-NEXT:    addw $r0 = $r0, $r4
; FP-ALL-NEXT:    addd $r2 = $r2, 64
; FP-ALL-NEXT:    lwz $r4 = 56[$r2]
; FP-ALL-NEXT:    ;; # (end cycle 9)
; FP-ALL-NEXT:    sd -8[$r14] = $r2
; FP-ALL-NEXT:    addw $r0 = $r0, $r5
; FP-ALL-NEXT:    ;; # (end cycle 10)
; FP-ALL-NEXT:    addw $r0 = $r0, $r3
; FP-ALL-NEXT:    ;; # (end cycle 11)
; FP-ALL-NEXT:    addw $r0 = $r0, $r4
; FP-ALL-NEXT:    ;; # (end cycle 12)
; FP-ALL-NEXT:  .__LOOPDO_1_END_:
; FP-ALL-NEXT:  .LBB0_6: # %for.cond.cleanup.loopexit.unr-lcssa
; FP-ALL-NEXT:    cb.weqz $r1 ? .LBB0_9
; FP-ALL-NEXT:    ;;
; FP-ALL-NEXT:  # %bb.7: # %for.body.epil.preheader
; FP-ALL-NEXT:    addw $r1 = $r1, -1
; FP-ALL-NEXT:    ;; # (end cycle 0)
; FP-ALL-NEXT:    addd $r1 = $r2, 8
; FP-ALL-NEXT:    addd $r3 = $r1, 1
; FP-ALL-NEXT:    ;; # (end cycle 1)
; FP-ALL-NEXT:    loopdo $r3, .__LOOPDO_0_END_
; FP-ALL-NEXT:    ;;
; FP-ALL-NEXT:  .LBB0_8: # %for.body.epil
; FP-ALL-NEXT:    # =>This Inner Loop Header: Depth=1
; FP-ALL-NEXT:    sd -8[$r14] = $r1
; FP-ALL-NEXT:    ;; # (end cycle 0)
; FP-ALL-NEXT:    addd $r1 = $r1, 8
; FP-ALL-NEXT:    lwz $r2 = -8[$r1]
; FP-ALL-NEXT:    ;; # (end cycle 1)
; FP-ALL-NEXT:    addw $r0 = $r2, $r0
; FP-ALL-NEXT:    ;; # (end cycle 4)
; FP-ALL-NEXT:  .__LOOPDO_0_END_:
; FP-ALL-NEXT:  .LBB0_9: # %for.cond.cleanup
; FP-ALL-NEXT:    addd $r12 = $r14, -24
; FP-ALL-NEXT:    ;;
; FP-ALL-NEXT:    ld $r14 = 24[$r12]
; FP-ALL-NEXT:    ;; # (end cycle 0)
; FP-ALL-NEXT:    ld $r16 = 32[$r12]
; FP-ALL-NEXT:    ;; # (end cycle 1)
; FP-ALL-NEXT:    set $ra = $r16
; FP-ALL-NEXT:    addd $r12 = $r12, 128
; FP-ALL-NEXT:    ;; # (end cycle 6)
; FP-ALL-NEXT:    ret
; FP-ALL-NEXT:    ;;
entry:
  %args = alloca ptr, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %args)
  call void @llvm.va_start(ptr nonnull %args)
  %cmp7 = icmp sgt i32 %n, 0
  br i1 %cmp7, label %for.body.preheader, label %for.cond.cleanup

for.body.preheader:
  %ap.cur.pre = load ptr, ptr %args, align 8
  %xtraiter = and i32 %n, 7
  %0 = icmp ult i32 %n, 8
  br i1 %0, label %for.cond.cleanup.loopexit.unr-lcssa, label %for.body.preheader.new

for.body.preheader.new:
  %unroll_iter = and i32 %n, 2147483640
  br label %for.body

for.cond.cleanup.loopexit.unr-lcssa:
  %add.lcssa.ph = phi i32 [ undef, %for.body.preheader ], [ %add.7, %for.body ]
  %ap.cur.unr = phi ptr [ %ap.cur.pre, %for.body.preheader ], [ %ap.next.7, %for.body ]
  %sum.08.unr = phi i32 [ 0, %for.body.preheader ], [ %add.7, %for.body ]
  %lcmp.mod = icmp eq i32 %xtraiter, 0
  br i1 %lcmp.mod, label %for.cond.cleanup, label %for.body.epil

for.body.epil:
  %ap.cur.epil = phi ptr [ %ap.next.epil, %for.body.epil ], [ %ap.cur.unr, %for.cond.cleanup.loopexit.unr-lcssa ]
  %sum.08.epil = phi i32 [ %add.epil, %for.body.epil ], [ %sum.08.unr, %for.cond.cleanup.loopexit.unr-lcssa ]
  %epil.iter = phi i32 [ %epil.iter.sub, %for.body.epil ], [ %xtraiter, %for.cond.cleanup.loopexit.unr-lcssa ]
  %ap.next.epil = getelementptr inbounds i8, ptr %ap.cur.epil, i64 8
  store ptr %ap.next.epil, ptr %args, align 8
  %1 = load i32, ptr %ap.cur.epil, align 8
  %add.epil = add nsw i32 %1, %sum.08.epil
  %epil.iter.sub = add nsw i32 %epil.iter, -1
  %epil.iter.cmp = icmp eq i32 %epil.iter.sub, 0
  br i1 %epil.iter.cmp, label %for.cond.cleanup, label %for.body.epil

for.cond.cleanup:
  %sum.0.lcssa = phi i32 [ 0, %entry ], [ %add.lcssa.ph, %for.cond.cleanup.loopexit.unr-lcssa ], [ %add.epil, %for.body.epil ]
  call void @llvm.va_end(ptr nonnull %args)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %args)
  ret i32 %sum.0.lcssa

for.body:
  %ap.cur = phi ptr [ %ap.cur.pre, %for.body.preheader.new ], [ %ap.next.7, %for.body ]
  %sum.08 = phi i32 [ 0, %for.body.preheader.new ], [ %add.7, %for.body ]
  %niter = phi i32 [ %unroll_iter, %for.body.preheader.new ], [ %niter.nsub.7, %for.body ]
  %ap.next = getelementptr inbounds i8, ptr %ap.cur, i64 8
  store ptr %ap.next, ptr %args, align 8
  %2 = load i32, ptr %ap.cur, align 8
  %add = add nsw i32 %2, %sum.08
  %ap.next.1 = getelementptr inbounds i8, ptr %ap.cur, i64 16
  store ptr %ap.next.1, ptr %args, align 8
  %3 = load i32, ptr %ap.next, align 8
  %add.1 = add nsw i32 %add, %3
  %ap.next.2 = getelementptr inbounds i8, ptr %ap.cur, i64 24
  store ptr %ap.next.2, ptr %args, align 8
  %4 = load i32, ptr %ap.next.1, align 8
  %add.2 = add nsw i32 %add.1, %4
  %ap.next.3 = getelementptr inbounds i8, ptr %ap.cur, i64 32
  store ptr %ap.next.3, ptr %args, align 8
  %5 = load i32, ptr %ap.next.2, align 8
  %add.3 = add nsw i32 %add.2, %5
  %ap.next.4 = getelementptr inbounds i8, ptr %ap.cur, i64 40
  store ptr %ap.next.4, ptr %args, align 8
  %6 = load i32, ptr %ap.next.3, align 8
  %add.4 = add nsw i32 %add.3, %6
  %ap.next.5 = getelementptr inbounds i8, ptr %ap.cur, i64 48
  store ptr %ap.next.5, ptr %args, align 8
  %7 = load i32, ptr %ap.next.4, align 8
  %add.5 = add nsw i32 %add.4, %7
  %ap.next.6 = getelementptr inbounds i8, ptr %ap.cur, i64 56
  store ptr %ap.next.6, ptr %args, align 8
  %8 = load i32, ptr %ap.next.5, align 8
  %add.6 = add nsw i32 %add.5, %8
  %ap.next.7 = getelementptr inbounds i8, ptr %ap.cur, i64 64
  store ptr %ap.next.7, ptr %args, align 8
  %9 = load i32, ptr %ap.next.6, align 8
  %add.7 = add nsw i32 %add.6, %9
  %niter.nsub.7 = add nsw i32 %niter, -8
  %niter.ncmp.7 = icmp eq i32 %niter.nsub.7, 0
  br i1 %niter.ncmp.7, label %for.cond.cleanup.loopexit.unr-lcssa, label %for.body
}

declare void @llvm.va_start(ptr)

declare void @llvm.va_end(ptr)

declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture)

declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture)

