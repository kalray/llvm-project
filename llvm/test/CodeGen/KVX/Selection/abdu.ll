; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mcpu=kv3-1 -O2 -o - %s | FileCheck %s --check-prefixes=ALL,V1
; RUN: llc -mcpu=kv3-2 -O2 -o - %s | FileCheck %s --check-prefixes=ALL,V2
; RUN: clang -O2 -c -o /dev/null %s
; RUN: clang -O2 -march=kv3-2 -c -o /dev/null %s

target triple = "kvx-kalray-cos"

define i64 @abdud(i64 %0, i64 %1) {
; V1-LABEL: abdud:
; V1:       # %bb.0:
; V1-NEXT:    minud $r0 = $r0, $r1
; V1-NEXT:    maxud $r2 = $r0, $r1
; V1-NEXT:    ;; # (end cycle 0)
; V1-NEXT:    sbfd $r0 = $r0, $r2
; V1-NEXT:    ret
; V1-NEXT:    ;; # (end cycle 1)
;
; V2-LABEL: abdud:
; V2:       # %bb.0:
; V2-NEXT:    abdud $r0 = $r0, $r1
; V2-NEXT:    ret
; V2-NEXT:    ;; # (end cycle 0)
  %3 = icmp ugt i64 %0, %1
  %4 = sub i64 %0, %1
  %5 = sub i64 %1, %0
  %6 = select i1 %3, i64 %4, i64 %5
  ret i64 %6
}

define i64 @abdud2(i64 %0, i64 %1) {
; V1-LABEL: abdud2:
; V1:       # %bb.0:
; V1-NEXT:    minud $r0 = $r0, $r1
; V1-NEXT:    maxud $r2 = $r0, $r1
; V1-NEXT:    ;; # (end cycle 0)
; V1-NEXT:    sbfd $r0 = $r0, $r2
; V1-NEXT:    ret
; V1-NEXT:    ;; # (end cycle 1)
;
; V2-LABEL: abdud2:
; V2:       # %bb.0:
; V2-NEXT:    abdud $r0 = $r0, $r1
; V2-NEXT:    ret
; V2-NEXT:    ;; # (end cycle 0)
  %3 = icmp ult i64 %0, %1
  %4 = sub i64 %1, %0
  %5 = sub i64 %0, %1
  %6 = select i1 %3, i64 %4, i64 %5
  ret i64 %6
}

define i64 @abdud3(i64 %0, i64 %1) {
; V1-LABEL: abdud3:
; V1:       # %bb.0:
; V1-NEXT:    minud $r0 = $r0, $r1
; V1-NEXT:    maxud $r2 = $r0, $r1
; V1-NEXT:    ;; # (end cycle 0)
; V1-NEXT:    sbfd $r0 = $r0, $r2
; V1-NEXT:    ret
; V1-NEXT:    ;; # (end cycle 1)
;
; V2-LABEL: abdud3:
; V2:       # %bb.0:
; V2-NEXT:    abdud $r0 = $r0, $r1
; V2-NEXT:    ret
; V2-NEXT:    ;; # (end cycle 0)
  %3 = tail call i64 @llvm.umax.i64(i64 %0, i64 %1)
  %4 = tail call i64 @llvm.umin.i64(i64 %0, i64 %1)
  %5 = sub i64 %3, %4
  ret i64 %5
}

declare i64 @llvm.umax.i64(i64, i64)

declare i64 @llvm.umin.i64(i64, i64)

; This can only match once we allow i128 subtractions
define i64 @abdud4(i64 %0, i64 %1) {
; ALL-LABEL: abdud4:
; ALL:       # %bb.0:
; ALL-NEXT:    sbfd $r0 = $r1, $r0
; ALL-NEXT:    compd.ltu $r2 = $r0, $r1
; ALL-NEXT:    ;; # (end cycle 0)
; ALL-NEXT:    negd $r1 = $r2
; ALL-NEXT:    negd $r2 = $r0
; ALL-NEXT:    ;; # (end cycle 1)
; ALL-NEXT:    cmoved.dltz $r1 ? $r0 = $r2
; ALL-NEXT:    ret
; ALL-NEXT:    ;; # (end cycle 2)
  %3 = zext i64 %0 to i128
  %4 = zext i64 %1 to i128
  %5 = sub nsw i128 %3, %4
  %6 = icmp slt i128 %5, 0
  %7 = trunc i128 %5 to i64
  %8 = sub i64 0, %7
  %9 = select i1 %6, i64 %8, i64 %7
  ret i64 %9
}

define i32 @abduw(i32 %0, i32 %1) {
; V1-LABEL: abduw:
; V1:       # %bb.0:
; V1-NEXT:    minuw $r0 = $r0, $r1
; V1-NEXT:    maxuw $r2 = $r0, $r1
; V1-NEXT:    ;; # (end cycle 0)
; V1-NEXT:    sbfw $r0 = $r0, $r2
; V1-NEXT:    ret
; V1-NEXT:    ;; # (end cycle 1)
;
; V2-LABEL: abduw:
; V2:       # %bb.0:
; V2-NEXT:    abduw $r0 = $r0, $r1
; V2-NEXT:    ret
; V2-NEXT:    ;; # (end cycle 0)
  %3 = icmp ugt i32 %0, %1
  %4 = sub i32 %0, %1
  %5 = sub i32 %1, %0
  %6 = select i1 %3, i32 %4, i32 %5
  ret i32 %6
}

define i32 @abduw2(i32 %0, i32 %1) {
; V1-LABEL: abduw2:
; V1:       # %bb.0:
; V1-NEXT:    minuw $r0 = $r0, $r1
; V1-NEXT:    maxuw $r2 = $r0, $r1
; V1-NEXT:    ;; # (end cycle 0)
; V1-NEXT:    sbfw $r0 = $r0, $r2
; V1-NEXT:    ret
; V1-NEXT:    ;; # (end cycle 1)
;
; V2-LABEL: abduw2:
; V2:       # %bb.0:
; V2-NEXT:    abduw $r0 = $r0, $r1
; V2-NEXT:    ret
; V2-NEXT:    ;; # (end cycle 0)
  %3 = icmp ult i32 %0, %1
  %4 = sub i32 %1, %0
  %5 = sub i32 %0, %1
  %6 = select i1 %3, i32 %4, i32 %5
  ret i32 %6
}

define i32 @abduw3(i32 %0, i32 %1) {
; V1-LABEL: abduw3:
; V1:       # %bb.0:
; V1-NEXT:    minuw $r0 = $r0, $r1
; V1-NEXT:    maxuw $r2 = $r0, $r1
; V1-NEXT:    ;; # (end cycle 0)
; V1-NEXT:    sbfw $r0 = $r0, $r2
; V1-NEXT:    ret
; V1-NEXT:    ;; # (end cycle 1)
;
; V2-LABEL: abduw3:
; V2:       # %bb.0:
; V2-NEXT:    abduw $r0 = $r0, $r1
; V2-NEXT:    ret
; V2-NEXT:    ;; # (end cycle 0)
  %3 = zext i32 %0 to i64
  %4 = zext i32 %1 to i64
  %5 = sub nsw i64 %3, %4
  %6 = tail call i64 @llvm.abs.i64(i64 %5, i1 true)
  %7 = trunc i64 %6 to i32
  ret i32 %7
}

define i32 @abduw4(i32 %0, i32 %1) {
; V1-LABEL: abduw4:
; V1:       # %bb.0:
; V1-NEXT:    minuw $r0 = $r0, $r1
; V1-NEXT:    maxuw $r2 = $r0, $r1
; V1-NEXT:    ;; # (end cycle 0)
; V1-NEXT:    sbfw $r0 = $r0, $r2
; V1-NEXT:    ret
; V1-NEXT:    ;; # (end cycle 1)
;
; V2-LABEL: abduw4:
; V2:       # %bb.0:
; V2-NEXT:    abduw $r0 = $r0, $r1
; V2-NEXT:    ret
; V2-NEXT:    ;; # (end cycle 0)
  %3 = tail call i32 @llvm.umax.i32(i32 %0, i32 %1)
  %4 = tail call i32 @llvm.umin.i32(i32 %0, i32 %1)
  %5 = sub i32 %3, %4
  ret i32 %5
}

declare i32 @llvm.umax.i32(i32, i32)

declare i32 @llvm.umin.i32(i32, i32)

define <8 x i8> @abdubo(<8 x i8> %0, <8 x i8> %1) {
; V1-LABEL: abdubo:
; V1:       # %bb.0:
; V1-NEXT:    sbmm8 $r2 = $r0, 0x80004000200010
; V1-NEXT:    sbmm8 $r3 = $r1, 0x80004000200010
; V1-NEXT:    ;; # (end cycle 0)
; V1-NEXT:    sbmm8 $r0 = $r0, 0x8000400020001
; V1-NEXT:    sbmm8 $r1 = $r1, 0x8000400020001
; V1-NEXT:    ;; # (end cycle 1)
; V1-NEXT:    abdhq $r0 = $r1, $r0
; V1-NEXT:    abdhq $r2 = $r3, $r2
; V1-NEXT:    ;; # (end cycle 2)
; V1-NEXT:    sbmm8 $r0 = $r0, 0x40100401
; V1-NEXT:    sbmm8 $r1 = $r2, 0x40100401
; V1-NEXT:    ;; # (end cycle 3)
; V1-NEXT:    insf $r0 = $r1, 63, 32
; V1-NEXT:    ret
; V1-NEXT:    ;; # (end cycle 4)
;
; V2-LABEL: abdubo:
; V2:       # %bb.0:
; V2-NEXT:    abdubo $r0 = $r0, $r1
; V2-NEXT:    ret
; V2-NEXT:    ;; # (end cycle 0)
  %3 = tail call <8 x i8> @llvm.umax.v8i8(<8 x i8> %0, <8 x i8> %1)
  %4 = tail call <8 x i8> @llvm.umin.v8i8(<8 x i8> %0, <8 x i8> %1)
  %5 = sub <8 x i8> %3, %4
  ret <8 x i8> %5
}

declare <8 x i8> @llvm.umax.v8i8(<8 x i8>, <8 x i8>)

declare <8 x i8> @llvm.umin.v8i8(<8 x i8>, <8 x i8>)

; This can't be matched yet as it zexts to illegal <8 x i16>
define <8 x i8> @abdubo2(<8 x i8> %0, <8 x i8> %1) {
; V1-LABEL: abdubo2:
; V1:       # %bb.0:
; V1-NEXT:    sbmm8 $r2 = $r0, 0x80004000200010
; V1-NEXT:    sbmm8 $r3 = $r1, 0x80004000200010
; V1-NEXT:    ;; # (end cycle 0)
; V1-NEXT:    sbmm8 $r0 = $r0, 0x8000400020001
; V1-NEXT:    sbmm8 $r1 = $r1, 0x8000400020001
; V1-NEXT:    ;; # (end cycle 1)
; V1-NEXT:    abdhq $r0 = $r1, $r0
; V1-NEXT:    abdhq $r2 = $r3, $r2
; V1-NEXT:    ;; # (end cycle 2)
; V1-NEXT:    sbmm8 $r0 = $r0, 0x40100401
; V1-NEXT:    sbmm8 $r1 = $r2, 0x40100401
; V1-NEXT:    ;; # (end cycle 3)
; V1-NEXT:    insf $r0 = $r1, 63, 32
; V1-NEXT:    ret
; V1-NEXT:    ;; # (end cycle 4)
;
; V2-LABEL: abdubo2:
; V2:       # %bb.0:
; V2-NEXT:    abdubo $r0 = $r0, $r1
; V2-NEXT:    ret
; V2-NEXT:    ;; # (end cycle 0)
  %3 = zext <8 x i8> %0 to <8 x i16>
  %4 = zext <8 x i8> %1 to <8 x i16>
  %5 = sub nsw <8 x i16> %3, %4
  %6 = tail call <8 x i16> @llvm.abs.v8i16(<8 x i16> %5, i1 false)
  %7 = trunc <8 x i16> %6 to <8 x i8>
  ret <8 x i8> %7
}

declare <8 x i16> @llvm.abs.v8i16(<8 x i16>, i1 immarg)

; This can't be matched yet as it zexts to illegal <8 x i16>
define <8 x i8> @abdubo3(<8 x i8> %0, <8 x i8> %1) {
; V1-LABEL: abdubo3:
; V1:       # %bb.0:
; V1-NEXT:    sbmm8 $r0 = $r0, 0x80004000200010
; V1-NEXT:    sbmm8 $r2 = $r0, 0x8000400020001
; V1-NEXT:    ;; # (end cycle 0)
; V1-NEXT:    sbmm8 $r1 = $r1, 0x80004000200010
; V1-NEXT:    sbmm8 $r3 = $r1, 0x8000400020001
; V1-NEXT:    ;; # (end cycle 1)
; V1-NEXT:    sbfhq $r0 = $r0, $r1
; V1-NEXT:    sbfhq $r1 = $r2, $r3
; V1-NEXT:    sbfhq $r4 = $r1, $r0
; V1-NEXT:    sbfhq $r5 = $r3, $r2
; V1-NEXT:    ;; # (end cycle 2)
; V1-NEXT:    maxhq $r0 = $r4, $r0
; V1-NEXT:    maxhq $r1 = $r5, $r1
; V1-NEXT:    ;; # (end cycle 3)
; V1-NEXT:    sbmm8 $r0 = $r1, 0x40100401
; V1-NEXT:    sbmm8 $r2 = $r0, 0x40100401
; V1-NEXT:    ;; # (end cycle 4)
; V1-NEXT:    insf $r0 = $r2, 63, 32
; V1-NEXT:    ret
; V1-NEXT:    ;; # (end cycle 5)
;
; V2-LABEL: abdubo3:
; V2:       # %bb.0:
; V2-NEXT:    abdubo $r0 = $r0, $r1
; V2-NEXT:    srld $r2 = $r0, 32
; V2-NEXT:    srld $r3 = $r1, 32
; V2-NEXT:    ;; # (end cycle 0)
; V2-NEXT:    abdubo $r2 = $r2, $r3
; V2-NEXT:    ;; # (end cycle 1)
; V2-NEXT:    insf $r0 = $r2, 63, 32
; V2-NEXT:    ret
; V2-NEXT:    ;; # (end cycle 2)
  %3 = zext <8 x i8> %0 to <8 x i16>
  %4 = zext <8 x i8> %1 to <8 x i16>
  %5 = sub nsw <8 x i16> %3, %4
  %6 = sub nsw <8 x i16> %4, %3
  %7 = tail call <8 x i16> @llvm.smax.v8i16(<8 x i16> %5, <8 x i16> %6)
  %8 = trunc <8 x i16> %7 to <8 x i8>
  ret <8 x i8> %8
}

declare <8 x i16> @llvm.smax.v8i16(<8 x i16>, <8 x i16>)

define <4 x i8> @abdubo_v4(<4 x i8> %0, <4 x i8> %1) {
; V1-LABEL: abdubo_v4:
; V1:       # %bb.0:
; V1-NEXT:    sbmm8 $r0 = $r0, 0x8000400020001
; V1-NEXT:    sbmm8 $r1 = $r1, 0x8000400020001
; V1-NEXT:    ;; # (end cycle 0)
; V1-NEXT:    abdhq $r0 = $r1, $r0
; V1-NEXT:    ;; # (end cycle 1)
; V1-NEXT:    sbmm8 $r0 = $r0, 0x40100401
; V1-NEXT:    ret
; V1-NEXT:    ;; # (end cycle 2)
;
; V2-LABEL: abdubo_v4:
; V2:       # %bb.0:
; V2-NEXT:    abdubo $r0 = $r0, $r1
; V2-NEXT:    ret
; V2-NEXT:    ;; # (end cycle 0)
  %3 = tail call <4 x i8> @llvm.umax.v4i8(<4 x i8> %0, <4 x i8> %1)
  %4 = tail call <4 x i8> @llvm.umin.v4i8(<4 x i8> %0, <4 x i8> %1)
  %5 = sub <4 x i8> %3, %4
  ret <4 x i8> %5
}

declare <4 x i8> @llvm.umax.v4i8(<4 x i8>, <4 x i8>)

declare <4 x i8> @llvm.umin.v4i8(<4 x i8>, <4 x i8>)

define <4 x i8> @abdubo2_v4(<4 x i8> %0, <4 x i8> %1) {
; V1-LABEL: abdubo2_v4:
; V1:       # %bb.0:
; V1-NEXT:    sbmm8 $r0 = $r0, 0x8000400020001
; V1-NEXT:    sbmm8 $r1 = $r1, 0x8000400020001
; V1-NEXT:    ;; # (end cycle 0)
; V1-NEXT:    abdhq $r0 = $r1, $r0
; V1-NEXT:    ;; # (end cycle 1)
; V1-NEXT:    sbmm8 $r0 = $r0, 0x40100401
; V1-NEXT:    ret
; V1-NEXT:    ;; # (end cycle 2)
;
; V2-LABEL: abdubo2_v4:
; V2:       # %bb.0:
; V2-NEXT:    abdubo $r0 = $r0, $r1
; V2-NEXT:    ret
; V2-NEXT:    ;; # (end cycle 0)
  %3 = zext <4 x i8> %0 to <4 x i16>
  %4 = zext <4 x i8> %1 to <4 x i16>
  %5 = sub nsw <4 x i16> %3, %4
  %6 = tail call <4 x i16> @llvm.abs.v4i16(<4 x i16> %5, i1 false)
  %7 = trunc <4 x i16> %6 to <4 x i8>
  ret <4 x i8> %7
}

declare <4 x i16> @llvm.abs.v4i16(<4 x i16>, i1 immarg)

define <4 x i8> @abdubo3_v4(<4 x i8> %0, <4 x i8> %1) {
; V1-LABEL: abdubo3_v4:
; V1:       # %bb.0:
; V1-NEXT:    sbmm8 $r0 = $r0, 0x8000400020001
; V1-NEXT:    sbmm8 $r1 = $r1, 0x8000400020001
; V1-NEXT:    ;; # (end cycle 0)
; V1-NEXT:    sbfhq $r0 = $r0, $r1
; V1-NEXT:    sbfhq $r2 = $r1, $r0
; V1-NEXT:    ;; # (end cycle 1)
; V1-NEXT:    maxhq $r0 = $r2, $r0
; V1-NEXT:    ;; # (end cycle 2)
; V1-NEXT:    sbmm8 $r0 = $r0, 0x40100401
; V1-NEXT:    ret
; V1-NEXT:    ;; # (end cycle 3)
;
; V2-LABEL: abdubo3_v4:
; V2:       # %bb.0:
; V2-NEXT:    abdubo $r0 = $r0, $r1
; V2-NEXT:    ret
; V2-NEXT:    ;; # (end cycle 0)
  %3 = zext <4 x i8> %0 to <4 x i16>
  %4 = zext <4 x i8> %1 to <4 x i16>
  %5 = sub nsw <4 x i16> %3, %4
  %6 = sub nsw <4 x i16> %4, %3
  %7 = tail call <4 x i16> @llvm.smax.v4i16(<4 x i16> %5, <4 x i16> %6)
  %8 = trunc <4 x i16> %7 to <4 x i8>
  ret <4 x i8> %8
}

declare <4 x i16> @llvm.smax.v4i16(<4 x i16>, <4 x i16>)

define <2 x i8> @abdubo_v2(<2 x i8> %0, <2 x i8> %1) {
; V1-LABEL: abdubo_v2:
; V1:       # %bb.0:
; V1-NEXT:    sbmm8 $r0 = $r0, 0x20001
; V1-NEXT:    sbmm8 $r1 = $r1, 0x20001
; V1-NEXT:    ;; # (end cycle 0)
; V1-NEXT:    abdhq $r0 = $r1, $r0
; V1-NEXT:    ;; # (end cycle 1)
; V1-NEXT:    sbmm8 $r0 = $r0, 0x401
; V1-NEXT:    ret
; V1-NEXT:    ;; # (end cycle 2)
;
; V2-LABEL: abdubo_v2:
; V2:       # %bb.0:
; V2-NEXT:    abdubo $r0 = $r0, $r1
; V2-NEXT:    ret
; V2-NEXT:    ;; # (end cycle 0)
  %3 = tail call <2 x i8> @llvm.umax.v2i8(<2 x i8> %0, <2 x i8> %1)
  %4 = tail call <2 x i8> @llvm.umin.v2i8(<2 x i8> %0, <2 x i8> %1)
  %5 = sub <2 x i8> %3, %4
  ret <2 x i8> %5
}

declare <2 x i8> @llvm.umax.v2i8(<2 x i8>, <2 x i8>)

declare <2 x i8> @llvm.umin.v2i8(<2 x i8>, <2 x i8>)

define <2 x i8> @abdubo2_v2(<2 x i8> %0, <2 x i8> %1) {
; V1-LABEL: abdubo2_v2:
; V1:       # %bb.0:
; V1-NEXT:    sbmm8 $r0 = $r0, 0x20001
; V1-NEXT:    sbmm8 $r1 = $r1, 0x20001
; V1-NEXT:    ;; # (end cycle 0)
; V1-NEXT:    abdhq $r0 = $r1, $r0
; V1-NEXT:    ;; # (end cycle 1)
; V1-NEXT:    sbmm8 $r0 = $r0, 0x401
; V1-NEXT:    ret
; V1-NEXT:    ;; # (end cycle 2)
;
; V2-LABEL: abdubo2_v2:
; V2:       # %bb.0:
; V2-NEXT:    abdubo $r0 = $r0, $r1
; V2-NEXT:    ret
; V2-NEXT:    ;; # (end cycle 0)
  %3 = zext <2 x i8> %0 to <2 x i16>
  %4 = zext <2 x i8> %1 to <2 x i16>
  %5 = sub nsw <2 x i16> %3, %4
  %6 = tail call <2 x i16> @llvm.abs.v2i16(<2 x i16> %5, i1 false)
  %7 = trunc <2 x i16> %6 to <2 x i8>
  ret <2 x i8> %7
}

declare <2 x i16> @llvm.abs.v2i16(<2 x i16>, i1 immarg)

define <2 x i8> @abdubo3_v2(<2 x i8> %0, <2 x i8> %1) {
; V1-LABEL: abdubo3_v2:
; V1:       # %bb.0:
; V1-NEXT:    sbmm8 $r0 = $r0, 0x20001
; V1-NEXT:    sbmm8 $r1 = $r1, 0x20001
; V1-NEXT:    ;; # (end cycle 0)
; V1-NEXT:    sbfhq $r0 = $r0, $r1
; V1-NEXT:    sbfhq $r2 = $r1, $r0
; V1-NEXT:    ;; # (end cycle 1)
; V1-NEXT:    maxhq $r0 = $r2, $r0
; V1-NEXT:    ;; # (end cycle 2)
; V1-NEXT:    sbmm8 $r0 = $r0, 0x401
; V1-NEXT:    ret
; V1-NEXT:    ;; # (end cycle 3)
;
; V2-LABEL: abdubo3_v2:
; V2:       # %bb.0:
; V2-NEXT:    abdubo $r0 = $r0, $r1
; V2-NEXT:    ret
; V2-NEXT:    ;; # (end cycle 0)
  %3 = zext <2 x i8> %0 to <2 x i16>
  %4 = zext <2 x i8> %1 to <2 x i16>
  %5 = sub nsw <2 x i16> %3, %4
  %6 = sub nsw <2 x i16> %4, %3
  %7 = tail call <2 x i16> @llvm.smax.v2i16(<2 x i16> %5, <2 x i16> %6)
  %8 = trunc <2 x i16> %7 to <2 x i8>
  ret <2 x i8> %8
}

declare <2 x i16> @llvm.smax.v2i16(<2 x i16>, <2 x i16>)

define <4 x i16> @abduhq(<4 x i16> %0, <4 x i16> %1) {
; V1-LABEL: abduhq:
; V1:       # %bb.0:
; V1-NEXT:    minuhq $r0 = $r0, $r1
; V1-NEXT:    maxuhq $r2 = $r0, $r1
; V1-NEXT:    ;; # (end cycle 0)
; V1-NEXT:    sbfhq $r0 = $r0, $r2
; V1-NEXT:    ret
; V1-NEXT:    ;; # (end cycle 1)
;
; V2-LABEL: abduhq:
; V2:       # %bb.0:
; V2-NEXT:    abduhq $r0 = $r0, $r1
; V2-NEXT:    ret
; V2-NEXT:    ;; # (end cycle 0)
  %3 = tail call <4 x i16> @llvm.umax.v4i16(<4 x i16> %0, <4 x i16> %1)
  %4 = tail call <4 x i16> @llvm.umin.v4i16(<4 x i16> %0, <4 x i16> %1)
  %5 = sub <4 x i16> %3, %4
  ret <4 x i16> %5
}

declare <4 x i16> @llvm.umax.v4i16(<4 x i16>, <4 x i16>)

declare <4 x i16> @llvm.umin.v4i16(<4 x i16>, <4 x i16>)

define <4 x i16> @abduhq2(<4 x i16> %0, <4 x i16> %1) {
; V1-LABEL: abduhq2:
; V1:       # %bb.0:
; V1-NEXT:    minuhq $r0 = $r0, $r1
; V1-NEXT:    maxuhq $r2 = $r0, $r1
; V1-NEXT:    ;; # (end cycle 0)
; V1-NEXT:    sbfhq $r0 = $r0, $r2
; V1-NEXT:    ret
; V1-NEXT:    ;; # (end cycle 1)
;
; V2-LABEL: abduhq2:
; V2:       # %bb.0:
; V2-NEXT:    abduhq $r0 = $r0, $r1
; V2-NEXT:    ret
; V2-NEXT:    ;; # (end cycle 0)
  %3 = zext <4 x i16> %0 to <4 x i32>
  %4 = zext <4 x i16> %1 to <4 x i32>
  %5 = sub nsw <4 x i32> %3, %4
  %6 = tail call <4 x i32> @llvm.abs.v4i32(<4 x i32> %5, i1 false)
  %7 = trunc <4 x i32> %6 to <4 x i16>
  ret <4 x i16> %7
}

declare <4 x i32> @llvm.abs.v4i32(<4 x i32>, i1 immarg)

define <2 x i16> @abduhq_v2(<2 x i16> %0, <2 x i16> %1) {
; V1-LABEL: abduhq_v2:
; V1:       # %bb.0:
; V1-NEXT:    minuhq $r0 = $r0, $r1
; V1-NEXT:    maxuhq $r2 = $r0, $r1
; V1-NEXT:    ;; # (end cycle 0)
; V1-NEXT:    sbfhq $r0 = $r0, $r2
; V1-NEXT:    ret
; V1-NEXT:    ;; # (end cycle 1)
;
; V2-LABEL: abduhq_v2:
; V2:       # %bb.0:
; V2-NEXT:    abduhq $r0 = $r0, $r1
; V2-NEXT:    ret
; V2-NEXT:    ;; # (end cycle 0)
  %3 = tail call <2 x i16> @llvm.umax.v2i16(<2 x i16> %0, <2 x i16> %1)
  %4 = tail call <2 x i16> @llvm.umin.v2i16(<2 x i16> %0, <2 x i16> %1)
  %5 = sub <2 x i16> %3, %4
  ret <2 x i16> %5
}

declare <2 x i16> @llvm.umax.v2i16(<2 x i16>, <2 x i16>)

declare <2 x i16> @llvm.umin.v2i16(<2 x i16>, <2 x i16>)

define <2 x i16> @abduhq2_v2(<2 x i16> %0, <2 x i16> %1) {
; V1-LABEL: abduhq2_v2:
; V1:       # %bb.0:
; V1-NEXT:    minuhq $r0 = $r0, $r1
; V1-NEXT:    maxuhq $r2 = $r0, $r1
; V1-NEXT:    ;; # (end cycle 0)
; V1-NEXT:    sbfhq $r0 = $r0, $r2
; V1-NEXT:    ret
; V1-NEXT:    ;; # (end cycle 1)
;
; V2-LABEL: abduhq2_v2:
; V2:       # %bb.0:
; V2-NEXT:    abduhq $r0 = $r0, $r1
; V2-NEXT:    ret
; V2-NEXT:    ;; # (end cycle 0)
  %3 = zext <2 x i16> %0 to <2 x i32>
  %4 = zext <2 x i16> %1 to <2 x i32>
  %5 = sub nsw <2 x i32> %3, %4
  %6 = tail call <2 x i32> @llvm.abs.v2i32(<2 x i32> %5, i1 false)
  %7 = trunc <2 x i32> %6 to <2 x i16>
  ret <2 x i16> %7
}

declare <2 x i32> @llvm.abs.v2i32(<2 x i32>, i1 immarg)

define <2 x i32> @abduwp(<2 x i32> %0, <2 x i32> %1) {
; V1-LABEL: abduwp:
; V1:       # %bb.0:
; V1-NEXT:    minuwp $r0 = $r0, $r1
; V1-NEXT:    maxuwp $r2 = $r0, $r1
; V1-NEXT:    ;; # (end cycle 0)
; V1-NEXT:    sbfwp $r0 = $r0, $r2
; V1-NEXT:    ret
; V1-NEXT:    ;; # (end cycle 1)
;
; V2-LABEL: abduwp:
; V2:       # %bb.0:
; V2-NEXT:    abduwp $r0 = $r0, $r1
; V2-NEXT:    ret
; V2-NEXT:    ;; # (end cycle 0)
  %3 = tail call <2 x i32> @llvm.umax.v2i32(<2 x i32> %0, <2 x i32> %1)
  %4 = tail call <2 x i32> @llvm.umin.v2i32(<2 x i32> %0, <2 x i32> %1)
  %5 = sub <2 x i32> %3, %4
  ret <2 x i32> %5
}

declare <2 x i32> @llvm.umax.v2i32(<2 x i32>, <2 x i32>)

declare <2 x i32> @llvm.umin.v2i32(<2 x i32>, <2 x i32>)

define <2 x i32> @abduwp2(<2 x i32> %0, <2 x i32> %1) {
; V1-LABEL: abduwp2:
; V1:       # %bb.0:
; V1-NEXT:    minuwp $r0 = $r0, $r1
; V1-NEXT:    maxuwp $r2 = $r0, $r1
; V1-NEXT:    ;; # (end cycle 0)
; V1-NEXT:    sbfwp $r0 = $r0, $r2
; V1-NEXT:    ret
; V1-NEXT:    ;; # (end cycle 1)
;
; V2-LABEL: abduwp2:
; V2:       # %bb.0:
; V2-NEXT:    abduwp $r0 = $r0, $r1
; V2-NEXT:    ret
; V2-NEXT:    ;; # (end cycle 0)
  %3 = zext <2 x i32> %0 to <2 x i64>
  %4 = zext <2 x i32> %1 to <2 x i64>
  %5 = sub nsw <2 x i64> %3, %4
  %6 = tail call <2 x i64> @llvm.abs.v2i64(<2 x i64> %5, i1 false)
  %7 = trunc <2 x i64> %6 to <2 x i32>
  ret <2 x i32> %7
}

declare <2 x i64> @llvm.abs.v2i64(<2 x i64>, i1 immarg)

declare i64 @llvm.abs.i64(i64, i1 immarg)

