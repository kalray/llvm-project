; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -O3 -o - -mcpu=kv3-1 %s | FileCheck %s
; RUN: llc -O3 -o - -mcpu=kv3-2 %s | FileCheck %s
; RUN: clang -O3 -c -march=kv3-1 -o /dev/null %s
; RUN: clang -O3 -c -march=kv3-2 -o /dev/null %s

target triple = "kvx-kalray-cos"

define i128 @add(i128 %0, i128 %1) {
; CHECK-LABEL: add:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addd $r0 = $r2, $r0
; CHECK-NEXT:    addd $r1 = $r3, $r1
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    compd.ltu $r2 = $r0, $r2
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    addd $r1 = $r1, $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 2)
  %3 = add nsw i128 %1, %0
  ret i128 %3
}

define i128 @sub(i128 %0, i128 %1) {
; CHECK-LABEL: sub:
; CHECK:       # %bb.0:
; CHECK-NEXT:    sbfd $r0 = $r2, $r0
; CHECK-NEXT:    sbfd $r1 = $r3, $r1
; CHECK-NEXT:    compd.ltu $r3 = $r0, $r2
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sbfd $r1 = $r3, $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
  %3 = sub nsw i128 %0, %1
  ret i128 %3
}

define i128 @mul(i128 %0, i128 %1) {
; CHECK-LABEL: mul:
; CHECK:       # %bb.0:
; CHECK-NEXT:    muludt $r4r5 = $r2, $r0
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    maddd $r5 = $r2, $r1
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    copyd $r0 = $r4
; CHECK-NEXT:    maddd $r5 = $r3, $r0
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    copyd $r1 = $r5
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 4)
  %3 = mul nsw i128 %1, %0
  ret i128 %3
}

define i128 @instxor(i128 %0, i128 %1) {
; CHECK-LABEL: instxor:
; CHECK:       # %bb.0:
; CHECK-NEXT:    eord $r0 = $r2, $r0
; CHECK-NEXT:    eord $r1 = $r3, $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %3 = xor i128 %1, %0
  ret i128 %3
}

define i128 @nxor(i128 %0, i128 %1) {
; CHECK-LABEL: nxor:
; CHECK:       # %bb.0:
; CHECK-NEXT:    neord $r0 = $r0, $r2
; CHECK-NEXT:    neord $r1 = $r1, $r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %3 = xor i128 %0, %1
  %4 = xor i128 %3, -1
  ret i128 %4
}

define i128 @nand(i128 %0, i128 %1) {
; CHECK-LABEL: nand:
; CHECK:       # %bb.0:
; CHECK-NEXT:    nandd $r0 = $r2, $r0
; CHECK-NEXT:    nandd $r1 = $r3, $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %3 = and i128 %1, %0
  %4 = xor i128 %3, -1
  ret i128 %4
}

define i128 @nor(i128 %0, i128 %1) {
; CHECK-LABEL: nor:
; CHECK:       # %bb.0:
; CHECK-NEXT:    niord $r0 = $r2, $r0
; CHECK-NEXT:    niord $r1 = $r3, $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %3 = or i128 %1, %0
  %4 = xor i128 %3, -1
  ret i128 %4
}

define i128 @nor_2(i128 %0, i128 %1) {
; CHECK-LABEL: nor_2:
; CHECK:       # %bb.0:
; CHECK-NEXT:    niord $r0 = $r2, $r0
; CHECK-NEXT:    niord $r1 = $r3, $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %3 = or i128 %1, %0
  %4 = xor i128 %3, -1
  ret i128 %4
}

define i128 @andn_1(i128 %0, i128 %1) {
; CHECK-LABEL: andn_1:
; CHECK:       # %bb.0:
; CHECK-NEXT:    andnd $r0 = $r0, $r2
; CHECK-NEXT:    andnd $r1 = $r1, $r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %3 = xor i128 %0, -1
  %4 = and i128 %3, %1
  ret i128 %4
}

define i128 @andn_2(i128 %0, i128 %1) {
; CHECK-LABEL: andn_2:
; CHECK:       # %bb.0:
; CHECK-NEXT:    andnd $r0 = $r2, $r0
; CHECK-NEXT:    andnd $r1 = $r3, $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %3 = xor i128 %1, -1
  %4 = and i128 %3, %0
  ret i128 %4
}

define i128 @and(i128 %0, i128 %1) {
; CHECK-LABEL: and:
; CHECK:       # %bb.0:
; CHECK-NEXT:    andd $r0 = $r2, $r0
; CHECK-NEXT:    andd $r1 = $r3, $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %3 = and i128 %1, %0
  ret i128 %3
}

define i128 @or(i128 %0, i128 %1) {
; CHECK-LABEL: or:
; CHECK:       # %bb.0:
; CHECK-NEXT:    iord $r0 = $r2, $r0
; CHECK-NEXT:    iord $r1 = $r3, $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %3 = or i128 %1, %0
  ret i128 %3
}

define i32 @land(i128 %0, i128 %1) {
; CHECK-LABEL: land:
; CHECK:       # %bb.0:
; CHECK-NEXT:    iord $r0 = $r0, $r1
; CHECK-NEXT:    iord $r1 = $r2, $r3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    landd $r0 = $r0, $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
  %3 = icmp ne i128 %0, 0
  %4 = icmp ne i128 %1, 0
  %5 = and i1 %3, %4
  %6 = zext i1 %5 to i32
  ret i32 %6
}

define i32 @lor(i128 %0, i128 %1) {
; CHECK-LABEL: lor:
; CHECK:       # %bb.0:
; CHECK-NEXT:    iord $r0 = $r2, $r0
; CHECK-NEXT:    iord $r1 = $r3, $r1
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    liord $r0 = $r0, $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
  %3 = or i128 %1, %0
  %4 = icmp ne i128 %3, 0
  %5 = zext i1 %4 to i32
  ret i32 %5
}

define i128 @sext_1_1(i8 %0) {
; CHECK-LABEL: sext_1_1:
; CHECK:       # %bb.0:
; CHECK-NEXT:    andw $r0 = $r0, 1
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    negw $r0 = $r0
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    sxwd $r0 = $r0
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    copyd $r1 = $r0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 3)
  %2 = and i8 %0, 1
  %3 = zext i8 %2 to i32
  %4 = sub nsw i32 0, %3
  %5 = sext i32 %4 to i128
  ret i128 %5
}

define i128 @sext_1_2(i8 %0, i8 %1) {
; CHECK-LABEL: sext_1_2:
; CHECK:       # %bb.0:
; CHECK-NEXT:    zxbd $r0 = $r0
; CHECK-NEXT:    zxbd $r1 = $r1
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    landw $r0 = $r0, $r1
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    extfs $r0 = $r0, 0, 0
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    copyd $r1 = $r0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 3)
  %3 = icmp ne i8 %0, 0
  %4 = icmp ne i8 %1, 0
  %5 = and i1 %3, %4
  %6 = sext i1 %5 to i128
  ret i128 %6
}

define i128 @sext_8(i8 %0) {
; CHECK-LABEL: sext_8:
; CHECK:       # %bb.0:
; CHECK-NEXT:    sxbd $r0 = $r0
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    srad $r1 = $r0, 63
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
  %2 = sext i8 %0 to i128
  ret i128 %2
}

define i128 @sext_16(i16 %0) {
; CHECK-LABEL: sext_16:
; CHECK:       # %bb.0:
; CHECK-NEXT:    sxhd $r0 = $r0
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    srad $r1 = $r0, 63
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
  %2 = sext i16 %0 to i128
  ret i128 %2
}

define i128 @sext_32(i32 %0) {
; CHECK-LABEL: sext_32:
; CHECK:       # %bb.0:
; CHECK-NEXT:    sxwd $r0 = $r0
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    srad $r1 = $r0, 63
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
  %2 = sext i32 %0 to i128
  ret i128 %2
}

define i128 @sext_64(i64 %0) {
; CHECK-LABEL: sext_64:
; CHECK:       # %bb.0:
; CHECK-NEXT:    srad $r1 = $r0, 63
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %2 = sext i64 %0 to i128
  ret i128 %2
}

define i128 @zext_8(i8 %0) {
; CHECK-LABEL: zext_8:
; CHECK:       # %bb.0:
; CHECK-NEXT:    andd $r0 = $r0, 255
; CHECK-NEXT:    make $r1 = 0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %2 = zext i8 %0 to i128
  ret i128 %2
}

define i128 @zext_16(i16 %0) {
; CHECK-LABEL: zext_16:
; CHECK:       # %bb.0:
; CHECK-NEXT:    clrf $r0 = $r0, 63, 16
; CHECK-NEXT:    make $r1 = 0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %2 = zext i16 %0 to i128
  ret i128 %2
}

define i128 @zext_32(i32 %0) {
; CHECK-LABEL: zext_32:
; CHECK:       # %bb.0:
; CHECK-NEXT:    zxwd $r0 = $r0
; CHECK-NEXT:    make $r1 = 0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %2 = zext i32 %0 to i128
  ret i128 %2
}

define i128 @zext_64(i64 %0) {
; CHECK-LABEL: zext_64:
; CHECK:       # %bb.0:
; CHECK-NEXT:    make $r1 = 0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %2 = zext i64 %0 to i128
  ret i128 %2
}

define i128 @MADDDT(i128 %0, i64 %1, i64 %2) {
; CHECK-LABEL: MADDDT:
; CHECK:       # %bb.0:
; CHECK-NEXT:    muldt $r2r3 = $r3, $r2
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    addd $r0 = $r2, $r0
; CHECK-NEXT:    addd $r1 = $r3, $r1
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    compd.ltu $r2 = $r0, $r2
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    addd $r1 = $r1, $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 4)
  %4 = sext i64 %1 to i128
  %5 = sext i64 %2 to i128
  %6 = mul nsw i128 %5, %4
  %7 = add nsw i128 %6, %0
  ret i128 %7
}

define i128 @MADDSUDT_1(i128 %0, i64 %1, i64 %2) {
; CHECK-LABEL: MADDSUDT_1:
; CHECK:       # %bb.0:
; CHECK-NEXT:    mulsudt $r2r3 = $r3, $r2
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    addd $r0 = $r2, $r0
; CHECK-NEXT:    addd $r1 = $r3, $r1
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    compd.ltu $r2 = $r0, $r2
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    addd $r1 = $r1, $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 4)
  %4 = zext i64 %1 to i128
  %5 = sext i64 %2 to i128
  %6 = mul nsw i128 %5, %4
  %7 = add nsw i128 %6, %0
  ret i128 %7
}

define i128 @MADDSUDT_2(i128 %0, i64 %1, i64 %2) {
; CHECK-LABEL: MADDSUDT_2:
; CHECK:       # %bb.0:
; CHECK-NEXT:    mulsudt $r2r3 = $r2, $r3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    addd $r0 = $r2, $r0
; CHECK-NEXT:    addd $r1 = $r3, $r1
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    compd.ltu $r2 = $r0, $r2
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    addd $r1 = $r1, $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 4)
  %4 = sext i64 %1 to i128
  %5 = zext i64 %2 to i128
  %6 = mul nsw i128 %5, %4
  %7 = add nsw i128 %6, %0
  ret i128 %7
}

define i128 @MADDUDT(i128 %0, i64 %1, i64 %2) {
; CHECK-LABEL: MADDUDT:
; CHECK:       # %bb.0:
; CHECK-NEXT:    muludt $r2r3 = $r3, $r2
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    addd $r0 = $r2, $r0
; CHECK-NEXT:    addd $r1 = $r3, $r1
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    compd.ltu $r2 = $r0, $r2
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    addd $r1 = $r1, $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 4)
  %4 = zext i64 %1 to i128
  %5 = zext i64 %2 to i128
  %6 = mul nuw nsw i128 %5, %4
  %7 = add nsw i128 %6, %0
  ret i128 %7
}

define i128 @MADDUZDT(i128 %0, i64 %1, i64 %2) {
; CHECK-LABEL: MADDUZDT:
; CHECK:       # %bb.0:
; CHECK-NEXT:    muludt $r2r3 = $r3, $r2
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    addd $r0 = $r2, $r1
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    compd.ltu $r1 = $r0, $r2
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    addd $r1 = $r3, $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 4)
  %4 = lshr i128 %0, 64
  %5 = zext i64 %1 to i128
  %6 = zext i64 %2 to i128
  %7 = mul nuw nsw i128 %6, %5
  %8 = add nuw i128 %7, %4
  ret i128 %8
}

define i128 @MSBFDT(i128 %0, i64 %1, i64 %2) {
; CHECK-LABEL: MSBFDT:
; CHECK:       # %bb.0:
; CHECK-NEXT:    muldt $r2r3 = $r3, $r2
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sbfd $r0 = $r2, $r0
; CHECK-NEXT:    sbfd $r1 = $r3, $r1
; CHECK-NEXT:    compd.ltu $r3 = $r0, $r2
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    sbfd $r1 = $r3, $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 3)
  %4 = sext i64 %1 to i128
  %5 = sext i64 %2 to i128
  %6 = mul nsw i128 %5, %4
  %7 = sub nsw i128 %0, %6
  ret i128 %7
}

define i128 @MSBFSUDT_1(i128 %0, i64 %1, i64 %2) {
; CHECK-LABEL: MSBFSUDT_1:
; CHECK:       # %bb.0:
; CHECK-NEXT:    mulsudt $r2r3 = $r3, $r2
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sbfd $r0 = $r2, $r0
; CHECK-NEXT:    sbfd $r1 = $r3, $r1
; CHECK-NEXT:    compd.ltu $r3 = $r0, $r2
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    sbfd $r1 = $r3, $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 3)
  %4 = zext i64 %1 to i128
  %5 = sext i64 %2 to i128
  %6 = mul nsw i128 %5, %4
  %7 = sub nsw i128 %0, %6
  ret i128 %7
}

define i128 @MSBFSUDT_2(i128 %0, i64 %1, i64 %2) {
; CHECK-LABEL: MSBFSUDT_2:
; CHECK:       # %bb.0:
; CHECK-NEXT:    mulsudt $r2r3 = $r2, $r3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sbfd $r0 = $r2, $r0
; CHECK-NEXT:    sbfd $r1 = $r3, $r1
; CHECK-NEXT:    compd.ltu $r3 = $r0, $r2
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    sbfd $r1 = $r3, $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 3)
  %4 = sext i64 %1 to i128
  %5 = zext i64 %2 to i128
  %6 = mul nsw i128 %5, %4
  %7 = sub nsw i128 %0, %6
  ret i128 %7
}

define i128 @MSBFUDT(i128 %0, i64 %1, i64 %2) {
; CHECK-LABEL: MSBFUDT:
; CHECK:       # %bb.0:
; CHECK-NEXT:    muludt $r2r3 = $r3, $r2
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sbfd $r0 = $r2, $r0
; CHECK-NEXT:    sbfd $r1 = $r3, $r1
; CHECK-NEXT:    compd.ltu $r3 = $r0, $r2
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    sbfd $r1 = $r3, $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 3)
  %4 = zext i64 %1 to i128
  %5 = zext i64 %2 to i128
  %6 = mul nuw nsw i128 %5, %4
  %7 = sub nsw i128 %0, %6
  ret i128 %7
}

define i128 @ld(ptr nocapture readonly %0) {
; CHECK-LABEL: ld:
; CHECK:       # %bb.0:
; CHECK-NEXT:    lq $r0r1 = 0[$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %2 = load i128, ptr %0
  ret i128 %2
}

define void @st(i128 %0, ptr nocapture %1) {
; CHECK-LABEL: st:
; CHECK:       # %bb.0:
; CHECK-NEXT:    sq 0[$r2] = $r0r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  store i128 %0, ptr %1
  ret void
}

define i128 @not(i128 %0) {
; CHECK-LABEL: not:
; CHECK:       # %bb.0:
; CHECK-NEXT:    notd $r0 = $r0
; CHECK-NEXT:    notd $r1 = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %2 = xor i128 %0, -1
  ret i128 %2
}

define i128 @neg(i128 %0) {
; CHECK-LABEL: neg:
; CHECK:       # %bb.0:
; CHECK-NEXT:    negd $r0 = $r0
; CHECK-NEXT:    compd.ne $r2 = $r0, 0
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    addd $r1 = $r1, $r2
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    negd $r1 = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 2)
  %2 = sub nsw i128 0, %0
  ret i128 %2
}

define i32 @lnot(i128 %0) {
; CHECK-LABEL: lnot:
; CHECK:       # %bb.0:
; CHECK-NEXT:    lniord $r0 = $r0, $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %2 = icmp eq i128 %0, 0
  %3 = zext i1 %2 to i32
  ret i32 %3
}

define i32 @lnot_eqz(i128 %0) {
; CHECK-LABEL: lnot_eqz:
; CHECK:       # %bb.0:
; CHECK-NEXT:    lniord $r0 = $r0, $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %2 = icmp eq i128 %0, 0
  %3 = zext i1 %2 to i32
  ret i32 %3
}

define i32 @nez(i128 %0) {
; CHECK-LABEL: nez:
; CHECK:       # %bb.0:
; CHECK-NEXT:    liord $r0 = $r0, $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %2 = icmp ne i128 %0, 0
  %3 = zext i1 %2 to i32
  ret i32 %3
}

define i32 @gez(i128 %0) {
; CHECK-LABEL: gez:
; CHECK:       # %bb.0:
; CHECK-NEXT:    srld $r0 = $r1, 63
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    eorw $r0 = $r0, 1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
  %2 = lshr i128 %0, 127
  %3 = trunc i128 %2 to i32
  %4 = xor i32 %3, 1
  ret i32 %4
}

define i32 @u_gez(i128 %0) {
; CHECK-LABEL: u_gez:
; CHECK:       # %bb.0:
; CHECK-NEXT:    make $r0 = 1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  ret i32 1
}

define i32 @gtz(i128 %0) {
; CHECK-LABEL: gtz:
; CHECK:       # %bb.0:
; CHECK-NEXT:    compd.gt $r0 = $r1, 0
; CHECK-NEXT:    compd.ne $r2 = $r0, 0
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    cmoved.deqz $r1 ? $r0 = $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
  %2 = icmp sgt i128 %0, 0
  %3 = zext i1 %2 to i32
  ret i32 %3
}

define i32 @u_gtz(i128 %0) {
; CHECK-LABEL: u_gtz:
; CHECK:       # %bb.0:
; CHECK-NEXT:    liord $r0 = $r0, $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %2 = icmp ne i128 %0, 0
  %3 = zext i1 %2 to i32
  ret i32 %3
}

define i32 @ltz(i128 %0) {
; CHECK-LABEL: ltz:
; CHECK:       # %bb.0:
; CHECK-NEXT:    srld $r0 = $r1, 63
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %2 = lshr i128 %0, 127
  %3 = trunc i128 %2 to i32
  ret i32 %3
}

define i32 @u_ltz(i128 %0) {
; CHECK-LABEL: u_ltz:
; CHECK:       # %bb.0:
; CHECK-NEXT:    make $r0 = 0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  ret i32 0
}

define i32 @lez(i128 %0) {
; CHECK-LABEL: lez:
; CHECK:       # %bb.0:
; CHECK-NEXT:    compd.lt $r0 = $r1, 0
; CHECK-NEXT:    compd.eq $r2 = $r0, 0
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    cmoved.deqz $r1 ? $r0 = $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
  %2 = icmp slt i128 %0, 1
  %3 = zext i1 %2 to i32
  ret i32 %3
}

define i32 @u_lez(i128 %0) {
; CHECK-LABEL: u_lez:
; CHECK:       # %bb.0:
; CHECK-NEXT:    lniord $r0 = $r0, $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %2 = icmp eq i128 %0, 0
  %3 = zext i1 %2 to i32
  ret i32 %3
}

define i32 @eq(i128 %0, i128 %1) {
; CHECK-LABEL: eq:
; CHECK:       # %bb.0:
; CHECK-NEXT:    eord $r0 = $r0, $r2
; CHECK-NEXT:    eord $r1 = $r1, $r3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    lniord $r0 = $r0, $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
  %3 = icmp eq i128 %0, %1
  %4 = zext i1 %3 to i32
  ret i32 %4
}

define i32 @ne(i128 %0, i128 %1) {
; CHECK-LABEL: ne:
; CHECK:       # %bb.0:
; CHECK-NEXT:    eord $r0 = $r0, $r2
; CHECK-NEXT:    eord $r1 = $r1, $r3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    liord $r0 = $r0, $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
  %3 = icmp ne i128 %0, %1
  %4 = zext i1 %3 to i32
  ret i32 %4
}

define i32 @gt(i128 %0, i128 %1) {
; CHECK-LABEL: gt:
; CHECK:       # %bb.0:
; CHECK-NEXT:    compd.gt $r0 = $r1, $r3
; CHECK-NEXT:    compd.eq $r1 = $r1, $r3
; CHECK-NEXT:    compd.gtu $r2 = $r0, $r2
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    cmoved.wnez $r1 ? $r0 = $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
  %3 = icmp sgt i128 %0, %1
  %4 = zext i1 %3 to i32
  ret i32 %4
}

define i32 @u_gt(i128 %0, i128 %1) {
; CHECK-LABEL: u_gt:
; CHECK:       # %bb.0:
; CHECK-NEXT:    compd.gtu $r0 = $r1, $r3
; CHECK-NEXT:    compd.eq $r1 = $r1, $r3
; CHECK-NEXT:    compd.gtu $r2 = $r0, $r2
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    cmoved.wnez $r1 ? $r0 = $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
  %3 = icmp ugt i128 %0, %1
  %4 = zext i1 %3 to i32
  ret i32 %4
}

define i32 @ge(i128 %0, i128 %1) {
; CHECK-LABEL: ge:
; CHECK:       # %bb.0:
; CHECK-NEXT:    compd.ge $r0 = $r1, $r3
; CHECK-NEXT:    compd.eq $r1 = $r1, $r3
; CHECK-NEXT:    compd.geu $r2 = $r0, $r2
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    cmoved.wnez $r1 ? $r0 = $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
  %3 = icmp sge i128 %0, %1
  %4 = zext i1 %3 to i32
  ret i32 %4
}

define i32 @uge(i128 %0, i128 %1) {
; CHECK-LABEL: uge:
; CHECK:       # %bb.0:
; CHECK-NEXT:    compd.geu $r0 = $r1, $r3
; CHECK-NEXT:    compd.eq $r1 = $r1, $r3
; CHECK-NEXT:    compd.geu $r2 = $r0, $r2
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    cmoved.wnez $r1 ? $r0 = $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
  %3 = icmp uge i128 %0, %1
  %4 = zext i1 %3 to i32
  ret i32 %4
}

define i32 @lt(i128 %0, i128 %1) {
; CHECK-LABEL: lt:
; CHECK:       # %bb.0:
; CHECK-NEXT:    compd.lt $r0 = $r1, $r3
; CHECK-NEXT:    compd.eq $r1 = $r1, $r3
; CHECK-NEXT:    compd.ltu $r2 = $r0, $r2
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    cmoved.wnez $r1 ? $r0 = $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
  %3 = icmp slt i128 %0, %1
  %4 = zext i1 %3 to i32
  ret i32 %4
}

define i32 @ult(i128 %0, i128 %1) {
; CHECK-LABEL: ult:
; CHECK:       # %bb.0:
; CHECK-NEXT:    compd.ltu $r0 = $r1, $r3
; CHECK-NEXT:    compd.eq $r1 = $r1, $r3
; CHECK-NEXT:    compd.ltu $r2 = $r0, $r2
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    cmoved.wnez $r1 ? $r0 = $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
  %3 = icmp ult i128 %0, %1
  %4 = zext i1 %3 to i32
  ret i32 %4
}

define i32 @le(i128 %0, i128 %1) {
; CHECK-LABEL: le:
; CHECK:       # %bb.0:
; CHECK-NEXT:    compd.le $r0 = $r1, $r3
; CHECK-NEXT:    compd.eq $r1 = $r1, $r3
; CHECK-NEXT:    compd.leu $r2 = $r0, $r2
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    cmoved.wnez $r1 ? $r0 = $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
  %3 = icmp sle i128 %0, %1
  %4 = zext i1 %3 to i32
  ret i32 %4
}

define i32 @ule(i128 %0, i128 %1) {
; CHECK-LABEL: ule:
; CHECK:       # %bb.0:
; CHECK-NEXT:    compd.leu $r0 = $r1, $r3
; CHECK-NEXT:    compd.eq $r1 = $r1, $r3
; CHECK-NEXT:    compd.leu $r2 = $r0, $r2
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    cmoved.wnez $r1 ? $r0 = $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
  %3 = icmp ule i128 %0, %1
  %4 = zext i1 %3 to i32
  ret i32 %4
}

define i128 @shl_64(i128 %0) {
; CHECK-LABEL: shl_64:
; CHECK:       # %bb.0:
; CHECK-NEXT:    make $r0 = 0
; CHECK-NEXT:    copyd $r1 = $r0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %2 = shl i128 %0, 64
  ret i128 %2
}

define i128 @lshr_64(i128 %0) {
; CHECK-LABEL: lshr_64:
; CHECK:       # %bb.0:
; CHECK-NEXT:    copyd $r0 = $r1
; CHECK-NEXT:    make $r1 = 0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %2 = lshr i128 %0, 64
  ret i128 %2
}

define i128 @ashr_64(i128 %0) {
; CHECK-LABEL: ashr_64:
; CHECK:       # %bb.0:
; CHECK-NEXT:    copyd $r0 = $r1
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    srad $r1 = $r0, 63
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
  %2 = ashr i128 %0, 64
  ret i128 %2
}

define i128 @shl(i128 %0, i32 %1) {
; CHECK-LABEL: shl:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addd $r12 = $r12, -32
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 24[$r12] = $r16
; CHECK-NEXT:    call __ashlti3
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    ld $r16 = 24[$r12]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 32
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %3 = zext i32 %1 to i128
  %4 = shl i128 %0, %3
  ret i128 %4
}

define i128 @lshr(i128 %0, i32 %1) {
; CHECK-LABEL: lshr:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addd $r12 = $r12, -32
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 24[$r12] = $r16
; CHECK-NEXT:    call __lshrti3
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    ld $r16 = 24[$r12]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 32
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %3 = zext i32 %1 to i128
  %4 = lshr i128 %0, %3
  ret i128 %4
}

define i128 @ashr(i128 %0, i32 %1) {
; CHECK-LABEL: ashr:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addd $r12 = $r12, -32
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 24[$r12] = $r16
; CHECK-NEXT:    call __ashrti3
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    ld $r16 = 24[$r12]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 32
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %3 = zext i32 %1 to i128
  %4 = ashr i128 %0, %3
  ret i128 %4
}

define i128 @sdiv(i128 %0, i128 %1) {
; CHECK-LABEL: sdiv:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addd $r12 = $r12, -32
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 24[$r12] = $r16
; CHECK-NEXT:    call __divti3
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    ld $r16 = 24[$r12]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 32
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %3 = sdiv i128 %0, %1
  ret i128 %3
}

define i128 @udiv(i128 %0, i128 %1) {
; CHECK-LABEL: udiv:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addd $r12 = $r12, -32
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 24[$r12] = $r16
; CHECK-NEXT:    call __udivti3
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    ld $r16 = 24[$r12]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 32
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %3 = udiv i128 %0, %1
  ret i128 %3
}

define i128 @sudiv(i128 %0, i128 %1) {
; CHECK-LABEL: sudiv:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addd $r12 = $r12, -32
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 24[$r12] = $r16
; CHECK-NEXT:    call __udivti3
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    ld $r16 = 24[$r12]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 32
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %3 = udiv i128 %0, %1
  ret i128 %3
}

define i128 @usdiv(i128 %0, i128 %1) {
; CHECK-LABEL: usdiv:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addd $r12 = $r12, -32
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 24[$r12] = $r16
; CHECK-NEXT:    call __udivti3
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    ld $r16 = 24[$r12]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 32
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %3 = udiv i128 %0, %1
  ret i128 %3
}

