; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -o - %s | FileCheck %s --check-prefixes=CHECK
; RUN: llc -mcpu=kv3-2 -o - %s | FileCheck %s --check-prefixes=CHECK
; RUN: clang -O2 -c -o /dev/null %s
; RUN: clang -O2 -march=kv3-2 -c -o /dev/null %s

; RUN: clang -c -o /dev/null %s

target triple = "kvx-kalray-cos"

define <2 x float> @floatComplex2vec(i64 %a.coerce) {
; CHECK-LABEL: floatComplex2vec:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %a.sroa.0.0.extract.trunc = trunc i64 %a.coerce to i32
  %0 = bitcast i32 %a.sroa.0.0.extract.trunc to float
  %a.sroa.2.0.extract.shift = lshr i64 %a.coerce, 32
  %a.sroa.2.0.extract.trunc = trunc i64 %a.sroa.2.0.extract.shift to i32
  %1 = bitcast i32 %a.sroa.2.0.extract.trunc to float
  %vecinit = insertelement <2 x float> undef, float %0, i32 0
  %vecinit2 = insertelement <2 x float> %vecinit, float %1, i32 1
  ret <2 x float> %vecinit2
}

define i64 @floatVec2complex(<2 x float> %a) {
; CHECK-LABEL: floatVec2complex:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %bc = bitcast <2 x float> %a to <2 x i32>
  %0 = extractelement <2 x i32> %bc, i32 0
  %1 = extractelement <2 x i32> %bc, i32 1
  %retval.sroa.2.0.insert.ext = zext i32 %1 to i64
  %retval.sroa.2.0.insert.shift = shl nuw i64 %retval.sroa.2.0.insert.ext, 32
  %retval.sroa.0.0.insert.ext = zext i32 %0 to i64
  %retval.sroa.0.0.insert.insert = or i64 %retval.sroa.2.0.insert.shift, %retval.sroa.0.0.insert.ext
  ret i64 %retval.sroa.0.0.insert.insert
}

define <2 x double> @doubleComplex2vec(i64 %a.coerce0, i64 %a.coerce1) {
; CHECK-LABEL: doubleComplex2vec:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = bitcast i64 %a.coerce0 to double
  %vecinit = insertelement <2 x double> undef, double %0, i32 0
  %1 = bitcast i64 %a.coerce1 to double
  %vecinit2 = insertelement <2 x double> %vecinit, double %1, i32 1
  ret <2 x double> %vecinit2
}

define { i64, i64 } @doubleVec2Complex(<2 x double> %a) #4 {
; CHECK-LABEL: doubleVec2Complex:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %bc = bitcast <2 x double> %a to <2 x i64>
  %0 = extractelement <2 x i64> %bc, i32 0
  %1 = extractelement <2 x i64> %bc, i32 1
  %.fca.0.insert = insertvalue { i64, i64 } undef, i64 %0, 0
  %.fca.1.insert = insertvalue { i64, i64 } %.fca.0.insert, i64 %1, 1
  ret { i64, i64 } %.fca.1.insert
}
