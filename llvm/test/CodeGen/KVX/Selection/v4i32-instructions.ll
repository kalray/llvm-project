; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mcpu=kv3-1 -O2 -o - %s | FileCheck %s --check-prefixes=CHECK,CV1
; RUN: llc -mcpu=kv3-2 -O2 -o - %s | FileCheck %s --check-prefixes=CHECK,CV2
; RUN: clang -O2 -march=kv3-1 -c -o /dev/null %s
; RUN: clang -O2 -march=kv3-2 -c -o /dev/null %s

target triple = "kvx-kalray-cos"

define <4 x i32> @test_ret_const() #0 {
; CHECK-LABEL: test_ret_const:
; CHECK:       # %bb.0:
; CHECK-NEXT:    make $r0 = 0x200000001
; CHECK-NEXT:    make $r1 = 0x200000001
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  ret <4 x i32> <i32 1, i32 2, i32 1, i32 2>
}

define i32 @test_extract_0(<4 x i32> %a) #0 {
; CHECK-LABEL: test_extract_0:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %e = extractelement <4 x i32> %a, i32 0
  ret i32 %e
}

define i32 @test_extract_1(<4 x i32> %a) #0 {
; CHECK-LABEL: test_extract_1:
; CHECK:       # %bb.0:
; CHECK-NEXT:    srad $r0 = $r0, 32
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %e = extractelement <4 x i32> %a, i32 1
  ret i32 %e
}

define <4 x i32> @test_fma(<4 x i32> %a, <4 x i32> %b, <4 x i32> %c) #0 {
; CV1-LABEL: test_fma:
; CV1:       # %bb.0:
; CV1-NEXT:    maddwp $r0 = $r2, $r4
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    maddwp $r1 = $r3, $r5
; CV1-NEXT:    ret
; CV1-NEXT:    ;; # (end cycle 1)
;
; CV2-LABEL: test_fma:
; CV2:       # %bb.0:
; CV2-NEXT:    maddwq $r0r1 = $r2r3, $r4r5
; CV2-NEXT:    ret
; CV2-NEXT:    ;; # (end cycle 0)
  %m = mul <4 x i32> %b, %c
  %ad = add <4 x i32> %a, %m
  ret <4 x i32> %ad
}

; FIXME: CV2 could have 2 make in same bundle
define <4 x i32> @test_fma_imm(<4 x i32> %a, <4 x i32> %b) #0 {
; CV1-LABEL: test_fma_imm:
; CV1:       # %bb.0:
; CV1-NEXT:    make $r5 = 0x200000001
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    maddwp $r1 = $r3, $r5
; CV1-NEXT:    copyd $r4 = $r5
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:    maddwp $r0 = $r2, $r4
; CV1-NEXT:    ret
; CV1-NEXT:    ;; # (end cycle 2)
;
; CV2-LABEL: test_fma_imm:
; CV2:       # %bb.0:
; CV2-NEXT:    make $r5 = 0x200000001
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    copyd $r4 = $r5
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:    maddwq $r0r1 = $r2r3, $r4r5
; CV2-NEXT:    ret
; CV2-NEXT:    ;; # (end cycle 2)
  %m = mul <4 x i32> <i32 1, i32 2, i32 1, i32 2>, %b
  %ad = add <4 x i32> %a, %m
  ret <4 x i32> %ad
}


define i32 @test_extract_i(<4 x i32> %a, i64 %idx) #0 {
; CHECK-LABEL: test_extract_i:
; CHECK:       # %bb.0:
; CHECK-NEXT:    andw $r2 = $r2, 1
; CHECK-NEXT:    srlw $r3 = $r2, 1
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    cmoved.odd $r3 ? $r0 = $r1
; CHECK-NEXT:    sllw $r1 = $r2, 5
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    srld $r0 = $r0, $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 2)
  %e = extractelement <4 x i32> %a, i64 %idx
  ret i32 %e
}

define <4 x i32> @test_add(<4 x i32> %a, <4 x i32> %b) #0 {
; CHECK-LABEL: test_add:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addwp $r0 = $r0, $r2
; CHECK-NEXT:    addwp $r1 = $r1, $r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %r = add <4 x i32> %a, %b
  ret <4 x i32> %r
}

define <4 x i32> @test_add_imm_0(<4 x i32> %a) #0 {
; CHECK-LABEL: test_add_imm_0:
; CHECK:       # %bb.0:
; CHECK-NEXT:    make $r3 = 0x200000001
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    addwp $r1 = $r1, $r3
; CHECK-NEXT:    copyd $r2 = $r3
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    addwp $r0 = $r0, $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 2)
  %r = add <4 x i32> <i32 1, i32 2, i32 1, i32 2>, %a
  ret <4 x i32> %r
}

define <4 x i32> @test_add_imm_1(<4 x i32> %a) #0 {
; CHECK-LABEL: test_add_imm_1:
; CHECK:       # %bb.0:
; CHECK-NEXT:    make $r3 = 0x200000001
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    addwp $r1 = $r1, $r3
; CHECK-NEXT:    copyd $r2 = $r3
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    addwp $r0 = $r0, $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 2)
  %r = add <4 x i32> %a, <i32 1, i32 2, i32 1, i32 2>
  ret <4 x i32> %r
}

define <4 x i32> @test_sub(<4 x i32> %a, <4 x i32> %b) #0 {
; CHECK-LABEL: test_sub:
; CHECK:       # %bb.0:
; CHECK-NEXT:    sbfwp $r0 = $r2, $r0
; CHECK-NEXT:    sbfwp $r1 = $r3, $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %r = sub <4 x i32> %a, %b
  ret <4 x i32> %r
}

define <4 x i32> @test_sub_imm(<4 x i32> %a) #0 {
; CHECK-LABEL: test_sub_imm:
; CHECK:       # %bb.0:
; CHECK-NEXT:    make $r3 = 0x200000001
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sbfwp $r1 = $r3, $r1
; CHECK-NEXT:    copyd $r2 = $r3
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    sbfwp $r0 = $r2, $r0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 2)
  %r = sub <4 x i32> %a, <i32 1, i32 2, i32 1, i32 2>
  ret <4 x i32> %r
}

define <4 x i32> @test_sub_fromimm(<4 x i32> %a) #0 {
; CHECK-LABEL: test_sub_fromimm:
; CHECK:       # %bb.0:
; CHECK-NEXT:    make $r3 = 0x200000001
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sbfwp $r1 = $r1, $r3
; CHECK-NEXT:    copyd $r2 = $r3
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    sbfwp $r0 = $r0, $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 2)
  %r = sub <4 x i32> <i32 1, i32 2, i32 1, i32 2>, %a
  ret <4 x i32> %r
}

define <4 x i32> @test_neg(<4 x i32> %a) #0 {
; CHECK-LABEL: test_neg:
; CHECK:       # %bb.0:
; CHECK-NEXT:    make $r2 = 0
; CHECK-NEXT:    make $r3 = 0
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sbfwp $r0 = $r0, $r2
; CHECK-NEXT:    sbfwp $r1 = $r1, $r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
  %r = sub <4 x i32> <i32 0, i32 0, i32 0, i32 0>, %a
  ret <4 x i32> %r
}

define <4 x i32> @test_mul(<4 x i32> %a, <4 x i32> %b) #0 {
; CHECK-LABEL: test_mul:
; CHECK:       # %bb.0:
; CHECK-NEXT:    mulwq $r0r1 = $r0r1, $r2r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %r = mul <4 x i32> %a, %b
  ret <4 x i32> %r
}

define <4 x i32> @test_mul_2(<4 x i32> %a, <4 x i32> %b, <4 x i32> %c) #0 {
; CHECK-LABEL: test_mul_2:
; CHECK:       # %bb.0:
; CHECK-NEXT:    mulwq $r0r1 = $r0r1, $r2r3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    mulwq $r0r1 = $r0r1, $r4r5
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 2)
  %r = mul <4 x i32> %a, %b
  %r1 = mul <4 x i32> %r, %c
  ret <4 x i32> %r1
}

define <4 x i32> @test_div(<4 x i32> %a, <4 x i32> %b) #0 {
; CHECK-LABEL: test_div:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addd $r12 = $r12, -64
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 56[$r12] = $r16
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    sd 48[$r12] = $r22
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    sq 32[$r12] = $r20r21
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    sq 16[$r12] = $r18r19
; CHECK-NEXT:    copyd $r18 = $r3
; CHECK-NEXT:    copyd $r19 = $r2
; CHECK-NEXT:    copyd $r20 = $r1
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    srad $r0 = $r20, 32
; CHECK-NEXT:    srad $r1 = $r18, 32
; CHECK-NEXT:    copyd $r21 = $r0
; CHECK-NEXT:    call __divsi3
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    copyd $r0 = $r20
; CHECK-NEXT:    copyd $r1 = $r18
; CHECK-NEXT:    copyd $r22 = $r0
; CHECK-NEXT:    call __divsi3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    srad $r0 = $r21, 32
; CHECK-NEXT:    srad $r1 = $r19, 32
; CHECK-NEXT:    copyd $r18 = $r0
; CHECK-NEXT:    call __divsi3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    copyd $r0 = $r21
; CHECK-NEXT:    copyd $r1 = $r19
; CHECK-NEXT:    copyd $r20 = $r0
; CHECK-NEXT:    call __divsi3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    insf $r0 = $r20, 63, 32
; CHECK-NEXT:    insf $r18 = $r22, 63, 32
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    lq $r18r19 = 16[$r12]
; CHECK-NEXT:    copyd $r1 = $r18
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    lq $r20r21 = 32[$r12]
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    ld $r22 = 48[$r12]
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    ld $r16 = 56[$r12]
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 64
; CHECK-NEXT:    ;; # (end cycle 9)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %r = sdiv <4 x i32> %a, %b
  ret <4 x i32> %r
}

define <4 x i32> @test_rem(<4 x i32> %a, <4 x i32> %b) #0 {
; CHECK-LABEL: test_rem:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addd $r12 = $r12, -64
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 56[$r12] = $r16
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    sd 48[$r12] = $r22
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    sq 32[$r12] = $r20r21
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    sq 16[$r12] = $r18r19
; CHECK-NEXT:    copyd $r18 = $r3
; CHECK-NEXT:    copyd $r19 = $r2
; CHECK-NEXT:    copyd $r20 = $r1
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    srad $r0 = $r20, 32
; CHECK-NEXT:    srad $r1 = $r18, 32
; CHECK-NEXT:    copyd $r21 = $r0
; CHECK-NEXT:    call __modsi3
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    copyd $r0 = $r20
; CHECK-NEXT:    copyd $r1 = $r18
; CHECK-NEXT:    copyd $r22 = $r0
; CHECK-NEXT:    call __modsi3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    srad $r0 = $r21, 32
; CHECK-NEXT:    srad $r1 = $r19, 32
; CHECK-NEXT:    copyd $r18 = $r0
; CHECK-NEXT:    call __modsi3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    copyd $r0 = $r21
; CHECK-NEXT:    copyd $r1 = $r19
; CHECK-NEXT:    copyd $r20 = $r0
; CHECK-NEXT:    call __modsi3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    insf $r0 = $r20, 63, 32
; CHECK-NEXT:    insf $r18 = $r22, 63, 32
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    lq $r18r19 = 16[$r12]
; CHECK-NEXT:    copyd $r1 = $r18
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    lq $r20r21 = 32[$r12]
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    ld $r22 = 48[$r12]
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    ld $r16 = 56[$r12]
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 64
; CHECK-NEXT:    ;; # (end cycle 9)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %r = srem <4 x i32> %a, %b
  ret <4 x i32> %r
}

define void @test_ldst_v4i32(ptr %a, ptr %b) {
; CHECK-LABEL: test_ldst_v4i32:
; CHECK:       # %bb.0:
; CHECK-NEXT:    lq $r2r3 = 0[$r0]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sq 0[$r1] = $r2r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 2)
  %t1 = load <4 x i32>, ptr %a
  store <4 x i32> %t1, ptr %b, align 16
  ret void
}

declare <4 x i32> @test_callee(<4 x i32> %a, <4 x i32> %b) #0

define <4 x i32> @test_call(<4 x i32> %a, <4 x i32> %b) #0 {
; CHECK-LABEL: test_call:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addd $r12 = $r12, -32
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 24[$r12] = $r16
; CHECK-NEXT:    call test_callee
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    ld $r16 = 24[$r12]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 32
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %r = call <4 x i32> @test_callee(<4 x i32> %a, <4 x i32> %b)
  ret <4 x i32> %r
}

define <4 x i32> @test_call_flipped(<4 x i32> %a, <4 x i32> %b) #0 {
; CHECK-LABEL: test_call_flipped:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addd $r12 = $r12, -32
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 24[$r12] = $r16
; CHECK-NEXT:    copyd $r0 = $r2
; CHECK-NEXT:    copyd $r2 = $r0
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    copyd $r1 = $r3
; CHECK-NEXT:    copyd $r3 = $r1
; CHECK-NEXT:    call test_callee
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    ld $r16 = 24[$r12]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 32
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %r = call <4 x i32> @test_callee(<4 x i32> %b, <4 x i32> %a)
  ret <4 x i32> %r
}

define <4 x i32> @test_tailcall_flipped(<4 x i32> %a, <4 x i32> %b) #0 {
; CHECK-LABEL: test_tailcall_flipped:
; CHECK:       # %bb.0:
; CHECK-NEXT:    copyd $r0 = $r2
; CHECK-NEXT:    copyd $r1 = $r3
; CHECK-NEXT:    copyd $r2 = $r0
; CHECK-NEXT:    copyd $r3 = $r1
; CHECK-NEXT:    goto test_callee
; CHECK-NEXT:    ;; # (end cycle 0)
  %r = tail call <4 x i32> @test_callee(<4 x i32> %b, <4 x i32> %a)
  ret <4 x i32> %r
}

define <4 x i32> @test_select(<4 x i32> %a, <4 x i32> %b, i1 zeroext %c) #0 {
; CHECK-LABEL: test_select:
; CHECK:       # %bb.0:
; CHECK-NEXT:    cmoved.even $r4 ? $r0 = $r2
; CHECK-NEXT:    cmoved.even $r4 ? $r1 = $r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %r = select i1 %c, <4 x i32> %a, <4 x i32> %b
  ret <4 x i32> %r
}

define <4 x i32> @test_select_cc(<4 x i32> %a, <4 x i32> %b, <4 x i32> %c, <4 x i32> %d) #0 {
; CHECK-LABEL: test_select_cc:
; CHECK:       # %bb.0:
; CHECK-NEXT:    compnwp.lt $r4 = $r4, $r6
; CHECK-NEXT:    compnwp.lt $r5 = $r5, $r7
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    cmovewp.even $r4 ? $r0 = $r2
; CHECK-NEXT:    cmovewp.even $r5 ? $r1 = $r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
  %cc = icmp slt <4 x i32> %c, %d
  %r = select <4 x i1> %cc, <4 x i32> %a, <4 x i32> %b
  ret <4 x i32> %r
}

define <4 x i64> @test_select_cc_f32_f32(<4 x i64> %a, <4 x i64> %b, <4 x i32> %c, <4 x i32> %d) #0 {
; CV1-LABEL: test_select_cc_f32_f32:
; CV1:       # %bb.0:
; CV1-NEXT:    compnwp.ltu $r8 = $r8, $r10
; CV1-NEXT:    compnwp.ltu $r9 = $r9, $r11
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    sxwd $r8 = $r8
; CV1-NEXT:    sxwd $r9 = $r9
; CV1-NEXT:    srld $r10 = $r9, 32
; CV1-NEXT:    srld $r11 = $r8, 32
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:    sxwd $r10 = $r10
; CV1-NEXT:    sxwd $r11 = $r11
; CV1-NEXT:    ;; # (end cycle 2)
; CV1-NEXT:    cmoved.dnez $r8 ? $r4 = $r0
; CV1-NEXT:    cmoved.dnez $r11 ? $r5 = $r1
; CV1-NEXT:    ;; # (end cycle 3)
; CV1-NEXT:    copyd $r0 = $r4
; CV1-NEXT:    copyd $r1 = $r5
; CV1-NEXT:    cmoved.dnez $r9 ? $r6 = $r2
; CV1-NEXT:    cmoved.dnez $r10 ? $r7 = $r3
; CV1-NEXT:    ;; # (end cycle 4)
; CV1-NEXT:    copyd $r2 = $r6
; CV1-NEXT:    copyd $r3 = $r7
; CV1-NEXT:    ret
; CV1-NEXT:    ;; # (end cycle 5)
;
; CV2-LABEL: test_select_cc_f32_f32:
; CV2:       # %bb.0:
; CV2-NEXT:    compnwp.ltu $r8 = $r8, $r10
; CV2-NEXT:    compnwp.ltu $r9 = $r9, $r11
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    sxwd $r8 = $r8
; CV2-NEXT:    sxwd $r9 = $r9
; CV2-NEXT:    srld $r10 = $r9, 32
; CV2-NEXT:    srld $r11 = $r8, 32
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:    cmoved.dnez $r8 ? $r4 = $r0
; CV2-NEXT:    cmoved.dnez $r9 ? $r6 = $r2
; CV2-NEXT:    sxwd $r10 = $r10
; CV2-NEXT:    sxwd $r11 = $r11
; CV2-NEXT:    ;; # (end cycle 2)
; CV2-NEXT:    copyd $r0 = $r4
; CV2-NEXT:    cmoved.dnez $r11 ? $r5 = $r1
; CV2-NEXT:    cmoved.dnez $r10 ? $r7 = $r3
; CV2-NEXT:    ;; # (end cycle 3)
; CV2-NEXT:    copyd $r1 = $r5
; CV2-NEXT:    copyd $r2 = $r6
; CV2-NEXT:    copyd $r3 = $r7
; CV2-NEXT:    ret
; CV2-NEXT:    ;; # (end cycle 4)
  %cc = icmp ult <4 x i32> %c, %d
  %r = select <4 x i1> %cc, <4 x i64> %a, <4 x i64> %b
  ret <4 x i64> %r
}

define <4 x i1> @test_icmp_ule(<4 x i32> %a, <4 x i32> %b) #0 {
; CHECK-LABEL: test_icmp_ule:
; CHECK:       # %bb.0:
; CHECK-NEXT:    compnwp.leu $r0 = $r0, $r2
; CHECK-NEXT:    compnwp.leu $r1 = $r1, $r3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sbmm8 $r0 = $r0, 0x1001
; CHECK-NEXT:    sbmm8 $r1 = $r1, 0x1001
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    insf $r0 = $r1, 31, 16
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 2)
  %r = icmp ule <4 x i32> %a, %b
  ret <4 x i1> %r
}

define <4 x i1> @test_icmp_slt(<4 x i32> %a, <4 x i32> %b) #0 {
; CHECK-LABEL: test_icmp_slt:
; CHECK:       # %bb.0:
; CHECK-NEXT:    compnwp.lt $r0 = $r0, $r2
; CHECK-NEXT:    compnwp.lt $r1 = $r1, $r3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sbmm8 $r0 = $r0, 0x1001
; CHECK-NEXT:    sbmm8 $r1 = $r1, 0x1001
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    insf $r0 = $r1, 31, 16
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 2)
  %r = icmp slt <4 x i32> %a, %b
  ret <4 x i1> %r
}

define <4 x i1> @test_icmp_ugt(<4 x i32> %a, <4 x i32> %b) #0 {
; CHECK-LABEL: test_icmp_ugt:
; CHECK:       # %bb.0:
; CHECK-NEXT:    compnwp.gtu $r0 = $r0, $r2
; CHECK-NEXT:    compnwp.gtu $r1 = $r1, $r3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sbmm8 $r0 = $r0, 0x1001
; CHECK-NEXT:    sbmm8 $r1 = $r1, 0x1001
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    insf $r0 = $r1, 31, 16
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 2)
  %r = icmp ugt <4 x i32> %a, %b
  ret <4 x i1> %r
}

define <4 x i1> @test_icmp_uge(<4 x i32> %a, <4 x i32> %b) #0 {
; CHECK-LABEL: test_icmp_uge:
; CHECK:       # %bb.0:
; CHECK-NEXT:    compnwp.geu $r0 = $r0, $r2
; CHECK-NEXT:    compnwp.geu $r1 = $r1, $r3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sbmm8 $r0 = $r0, 0x1001
; CHECK-NEXT:    sbmm8 $r1 = $r1, 0x1001
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    insf $r0 = $r1, 31, 16
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 2)
  %r = icmp uge <4 x i32> %a, %b
  ret <4 x i1> %r
}

define <4 x i1> @test_icmp_ult(<4 x i32> %a, <4 x i32> %b) #0 {
; CHECK-LABEL: test_icmp_ult:
; CHECK:       # %bb.0:
; CHECK-NEXT:    compnwp.ltu $r0 = $r0, $r2
; CHECK-NEXT:    compnwp.ltu $r1 = $r1, $r3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sbmm8 $r0 = $r0, 0x1001
; CHECK-NEXT:    sbmm8 $r1 = $r1, 0x1001
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    insf $r0 = $r1, 31, 16
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 2)
  %r = icmp ult <4 x i32> %a, %b
  ret <4 x i1> %r
}

define <4 x i64> @test_sext_2xi64(<4 x i32> %a) #0 {
; CHECK-LABEL: test_sext_2xi64:
; CHECK:       # %bb.0:
; CHECK-NEXT:    sxwd $r2 = $r1
; CHECK-NEXT:    srad $r3 = $r1, 32
; CHECK-NEXT:    sxwd $r4 = $r0
; CHECK-NEXT:    srad $r5 = $r0, 32
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    copyd $r0 = $r4
; CHECK-NEXT:    copyd $r1 = $r5
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
  %r = sext <4 x i32> %a to <4 x i64>
  ret <4 x i64> %r
}

declare <4 x i32> @llvm.abs.v4i32(<4 x i32>, i1) #0

define <4 x i32> @test_abs(<4 x i32> %a) #0 {
; CHECK-LABEL: test_abs:
; CHECK:       # %bb.0:
; CHECK-NEXT:    abswp $r0 = $r0
; CHECK-NEXT:    abswp $r1 = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %r = call <4 x i32> @llvm.abs.v4i32(<4 x i32> %a, i1 false)
  ret <4 x i32> %r
}

define <4 x i32> @test_insertelement0(<4 x i32> %a, i32 %x) #0 {
; CHECK-LABEL: test_insertelement0:
; CHECK:       # %bb.0:
; CHECK-NEXT:    insf $r0 = $r2, 31, 0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %i = insertelement <4 x i32> %a, i32 %x, i64 0
  ret <4 x i32> %i
}

define <4 x i32> @test_insertelement1(<4 x i32> %a, i32 %x) #0 {
; CHECK-LABEL: test_insertelement1:
; CHECK:       # %bb.0:
; CHECK-NEXT:    insf $r0 = $r2, 63, 32
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %i = insertelement <4 x i32> %a, i32 %x, i64 1
  ret <4 x i32> %i
}

define <4 x i32> @test_insertelement2(<4 x i32> %a, i32 %x) #0 {
; CHECK-LABEL: test_insertelement2:
; CHECK:       # %bb.0:
; CHECK-NEXT:    insf $r1 = $r2, 31, 0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %i = insertelement <4 x i32> %a, i32 %x, i64 2
  ret <4 x i32> %i
}

define <4 x i32> @test_insertelement3(<4 x i32> %a, i32 %x) #0 {
; CHECK-LABEL: test_insertelement3:
; CHECK:       # %bb.0:
; CHECK-NEXT:    insf $r1 = $r2, 63, 32
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %i = insertelement <4 x i32> %a, i32 %x, i64 3
  ret <4 x i32> %i
}

define <4 x i32> @test_insertelement(<4 x i32> %a, i32 %x, i64 %p) #0 {
; CHECK-LABEL: test_insertelement:
; CHECK:       # %bb.0:
; CHECK-NEXT:    insf $r2 = $r2, 63, 32
; CHECK-NEXT:    insf $r3 = $r3, 63, 32
; CHECK-NEXT:    make $r4 = 0x300000002
; CHECK-NEXT:    make $r5 = 0x100000000
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    compnwp.eq $r3 = $r5, $r3
; CHECK-NEXT:    compnwp.eq $r4 = $r4, $r3
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    cmovewp.nez $r3 ? $r0 = $r2
; CHECK-NEXT:    cmovewp.nez $r4 ? $r1 = $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 2)
  %i = insertelement <4 x i32> %a, i32 %x, i64 %p
  ret <4 x i32> %i
}

define <4 x i8> @trunc_to_v4i8(<4 x i32> %a) {
; CHECK-LABEL: trunc_to_v4i8:
; CHECK:       # %bb.0:
; CHECK-NEXT:    sbmm8 $r0 = $r0, 0x1001
; CHECK-NEXT:    sbmm8 $r1 = $r1, 0x1001
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    insf $r0 = $r1, 31, 16
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
  %r = trunc <4 x i32> %a to <4 x i8>
  ret <4 x i8> %r
}

define <4 x i8> @trunc_to_v4i8_buildvector(i32 %arg1, i32 %arg2, i32 %arg3, i32 %arg4) {
; CHECK-LABEL: trunc_to_v4i8_buildvector:
; CHECK:       # %bb.0:
; CHECK-NEXT:    insf $r0 = $r1, 15, 8
; CHECK-NEXT:    insf $r2 = $r3, 15, 8
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    insf $r0 = $r2, 31, 16
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
  %v0 = insertelement <4 x i32> undef, i32 %arg1, i32 0
  %v1 = insertelement <4 x i32> %v0, i32 %arg2, i32 1
  %v2 = insertelement <4 x i32> %v1, i32 %arg3, i32 2
  %v3 = insertelement <4 x i32> %v2, i32 %arg4, i32 3
  %conv = trunc <4 x i32> %v3 to <4 x i8>
  ret <4 x i8> %conv
}

define <4 x i32> @concat(<2 x i32> %a, <2 x i32> %b){
; CHECK-LABEL: concat:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %v = shufflevector <2 x i32> %a, <2 x i32> %b, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  ret <4 x i32> %v
}

define <4 x i32> @revconcat(<2 x i32> %b, <2 x i32> %a){
; CHECK-LABEL: revconcat:
; CHECK:       # %bb.0:
; CHECK-NEXT:    copyd $r0 = $r1
; CHECK-NEXT:    copyd $r1 = $r0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %v = shufflevector <2 x i32> %a, <2 x i32> %b, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  ret <4 x i32> %v
}

define void @bug() {
; CHECK-LABEL: bug:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:  .LBB40_1: # %loop
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    goto .LBB40_1
; CHECK-NEXT:    ;;
entry:
  br label %loop

loop:
  %0 = phi <4 x i32> [ %1, %loop ], [ undef, %entry ]
  %1 = insertelement <4 x i32> %0, i32 0, i64 2
  %2 = extractelement <4 x i32> %0, i32 3
  br label %loop
}

define <4 x i32> @MULHWQ(<4 x i16> %a, <4 x i16> %b) {
; CHECK-LABEL: MULHWQ:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    mulhwq $r0r1 = $r1, $r0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %0 = sext <4 x i16> %a to <4 x i32>
  %1 = sext <4 x i16> %b to <4 x i32>
  %mul = mul nsw <4 x i32> %1, %0
  ret <4 x i32> %mul
}

define <4 x i32> @MULSUHWQ(<4 x i16> %a, <4 x i16> %b) {
; CHECK-LABEL: MULSUHWQ:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    mulsuhwq $r0r1 = $r0, $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %0 = sext <4 x i16> %a to <4 x i32>
  %1 = zext <4 x i16> %b to <4 x i32>
  %mul = mul nsw <4 x i32> %1, %0
  ret <4 x i32> %mul
}

define <4 x i32> @MULUHWQ(<4 x i16> %a, <4 x i16> %b) {
; CHECK-LABEL: MULUHWQ:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    muluhwq $r0r1 = $r1, $r0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %0 = zext <4 x i16> %a to <4 x i32>
  %1 = zext <4 x i16> %b to <4 x i32>
  %mul = mul nuw <4 x i32> %1, %0
  ret <4 x i32> %mul
}

define <4 x i32> @MADDHWQ(<4 x i32> %0, <4 x i16> %1, <4 x i16> %2) {
; CHECK-LABEL: MADDHWQ:
; CHECK:       # %bb.0:
; CHECK-NEXT:    maddhwq $r0r1 = $r3, $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %4 = sext <4 x i16> %1 to <4 x i32>
  %5 = sext <4 x i16> %2 to <4 x i32>
  %6 = mul nsw <4 x i32> %5, %4
  %7 = add <4 x i32> %6, %0
  ret <4 x i32> %7
}

define <4 x i32> @MADDSUHWQ(<4 x i32> %0, <4 x i16> %1, <4 x i16> %2) {
; CHECK-LABEL: MADDSUHWQ:
; CHECK:       # %bb.0:
; CHECK-NEXT:    maddsuhwq $r0r1 = $r2, $r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %4 = sext <4 x i16> %1 to <4 x i32>
  %5 = zext <4 x i16> %2 to <4 x i32>
  %6 = mul nsw <4 x i32> %5, %4
  %7 = add <4 x i32> %6, %0
  ret <4 x i32> %7
}

define <4 x i32> @MADDUHWQ(<4 x i32> %0, <4 x i16> %1, <4 x i16> %2) {
; CHECK-LABEL: MADDUHWQ:
; CHECK:       # %bb.0:
; CHECK-NEXT:    madduhwq $r0r1 = $r3, $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %4 = zext <4 x i16> %1 to <4 x i32>
  %5 = zext <4 x i16> %2 to <4 x i32>
  %6 = mul nuw <4 x i32> %5, %4
  %7 = add <4 x i32> %6, %0
  ret <4 x i32> %7
}

define <3 x i32> @MADDSUHWQ_v3(<3 x i32> %0, <3 x i16> %1, <3 x i16> %2) {
; CHECK-LABEL: MADDSUHWQ_v3:
; CHECK:       # %bb.0:
; CHECK-NEXT:    maddsuhwq $r0r1 = $r2, $r3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    insf $r1 = $r0, 63, 32
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 2)
  %4 = sext <3 x i16> %1 to <3 x i32>
  %5 = zext <3 x i16> %2 to <3 x i32>
  %6 = mul nsw <3 x i32> %5, %4
  %7 = add <3 x i32> %6, %0
  ret <3 x i32> %7
}


define <4 x i32> @MSBFHWQ(<4 x i32> %0, <4 x i16> %1, <4 x i16> %2) {
; CHECK-LABEL: MSBFHWQ:
; CHECK:       # %bb.0:
; CHECK-NEXT:    msbfhwq $r0r1 = $r3, $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %4 = sext <4 x i16> %1 to <4 x i32>
  %5 = sext <4 x i16> %2 to <4 x i32>
  %6 = mul nsw <4 x i32> %5, %4
  %7 = sub <4 x i32> %0, %6
  ret <4 x i32> %7
}

define <4 x i32> @MSBFSUHWQ(<4 x i32> %0, <4 x i16> %1, <4 x i16> %2) {
; CHECK-LABEL: MSBFSUHWQ:
; CHECK:       # %bb.0:
; CHECK-NEXT:    msbfsuhwq $r0r1 = $r2, $r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %4 = sext <4 x i16> %1 to <4 x i32>
  %5 = zext <4 x i16> %2 to <4 x i32>
  %6 = mul nsw <4 x i32> %5, %4
  %7 = sub <4 x i32> %0, %6
  ret <4 x i32> %7
}

define <4 x i32> @MSBFUHWQ(<4 x i32> %0, <4 x i16> %1, <4 x i16> %2) {
; CHECK-LABEL: MSBFUHWQ:
; CHECK:       # %bb.0:
; CHECK-NEXT:    msbfuhwq $r0r1 = $r3, $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %4 = zext <4 x i16> %1 to <4 x i32>
  %5 = zext <4 x i16> %2 to <4 x i32>
  %6 = mul nuw <4 x i32> %5, %4
  %7 = sub <4 x i32> %0, %6
  ret <4 x i32> %7
}

attributes #0 = { nounwind }

define <4 x i32> @test_div_4(<4 x i32> %a, <4 x i32> %b) #0 {
; CHECK-LABEL: test_div_4:
; CHECK:       # %bb.0:
; CHECK-NEXT:    srawps $r2 = $r0, 31
; CHECK-NEXT:    srawps $r3 = $r1, 31
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    srlwps $r2 = $r2, 30
; CHECK-NEXT:    srlwps $r3 = $r3, 30
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    addwp $r0 = $r0, $r2
; CHECK-NEXT:    addwp $r1 = $r1, $r3
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    srawps $r0 = $r0, 2
; CHECK-NEXT:    srawps $r1 = $r1, 2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 3)
  %r = sdiv <4 x i32> %a, <i32 4, i32 4, i32 4, i32 4>
  ret <4 x i32> %r
}

define <4 x i32> @test_div_32(<4 x i32> %a, <4 x i32> %b) #0 {
; CHECK-LABEL: test_div_32:
; CHECK:       # %bb.0:
; CHECK-NEXT:    srawps $r2 = $r0, 31
; CHECK-NEXT:    srawps $r3 = $r1, 31
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    srlwps $r2 = $r2, 27
; CHECK-NEXT:    srlwps $r3 = $r3, 27
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    addwp $r0 = $r0, $r2
; CHECK-NEXT:    addwp $r1 = $r1, $r3
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    srawps $r0 = $r0, 5
; CHECK-NEXT:    srawps $r1 = $r1, 5
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 3)
  %r = sdiv <4 x i32> %a, <i32 32, i32 32, i32 32, i32 32>
  ret <4 x i32> %r
}

define void @subvec0(ptr %0) {
; CHECK-LABEL: subvec0:
; CHECK:       # %bb.0:
  br label %2

2:
  %3 = shufflevector <4 x i32> zeroinitializer, <4 x i32> undef, <2 x i32> <i32 0, i32 1>
  %4 = add nsw <2 x i32> zeroinitializer, %3
  %5 = shufflevector <2 x i32> %4, <2 x i32> poison, <4 x i32> <i32 0, i32 1, i32 undef, i32 undef>
  %6 = shufflevector <4 x i32> %5, <4 x i32> zeroinitializer, <4 x i32> <i32 0, i32 1, i32 6, i32 7>
  store <4 x i32> %6, ptr undef, align 16
  br label %2
}

define void @subvec2(ptr %0) {
; CHECK-LABEL: subvec2:
; CHECK:       # %bb.0:
  br label %2

2:
  %3 = shufflevector <4 x i32> zeroinitializer, <4 x i32> undef, <2 x i32> <i32 0, i32 1>
  %4 = add nsw <2 x i32> zeroinitializer, %3
  %5 = shufflevector <2 x i32> %4, <2 x i32> poison, <4 x i32> <i32 0, i32 1, i32 undef, i32 undef>
  %6 = shufflevector <4 x i32> %5, <4 x i32> zeroinitializer, <4 x i32> <i32 6, i32 7, i32 2, i32 3>
  store <4 x i32> %6, ptr undef, align 16
  br label %2
}

define <4 x i32> @test_select_cmp(<4 x i32> %a, <4 x i32> %b, <4 x i32> %c, <4 x i32> %d) #0 {
; CHECK-LABEL: test_select_cmp:
; CHECK:       # %bb.0:
; CHECK-NEXT:    compnwp.ne $r4 = $r4, $r6
; CHECK-NEXT:    compnwp.ne $r5 = $r5, $r7
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    andd $r4 = $r4, $r5
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    compd.eq $r4 = $r4, -1
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    cmoved.even $r4 ? $r0 = $r2
; CHECK-NEXT:    cmoved.even $r4 ? $r1 = $r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 3)
  %cc = icmp ne <4 x i32> %c, %d
  %bc = bitcast <4 x i1> %cc to i4
  %cmp = icmp eq i4 %bc, -1
  %r = select i1 %cmp, <4 x i32> %a, <4 x i32> %b
  ret <4 x i32> %r
}

define <4 x i32> @test_select_cmp_2(<4 x i32> %a, <4 x i32> %b, <4 x i32> %c, <4 x i32> %d) {
; CHECK-LABEL: test_select_cmp_2:
; CHECK:       # %bb.0:
; CHECK-NEXT:    compnwp.ne $r4 = $r4, $r6
; CHECK-NEXT:    compnwp.ne $r5 = $r5, $r7
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    lniord $r4 = $r5, $r4
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    cmoved.even $r4 ? $r0 = $r2
; CHECK-NEXT:    cmoved.even $r4 ? $r1 = $r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 2)
  %cc = icmp ne <4 x i32> %c, %d
  %bc = bitcast <4 x i1> %cc to i4
  %cmp = icmp eq i4 %bc, 0
  %r = select i1 %cmp, <4 x i32> %a, <4 x i32> %b
  ret <4 x i32> %r
}

define <4 x i32> @test_select_cmp_3(<4 x i32> %a, <4 x i32> %b, <4 x i32> %c, <4 x i32> %d) {
; CHECK-LABEL: test_select_cmp_3:
; CHECK:       # %bb.0:
; CHECK-NEXT:    compnwp.ne $r4 = $r4, $r6
; CHECK-NEXT:    compnwp.ne $r5 = $r5, $r7
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    liord $r4 = $r5, $r4
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    cmoved.even $r4 ? $r0 = $r2
; CHECK-NEXT:    cmoved.even $r4 ? $r1 = $r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 2)
  %cc = icmp ne <4 x i32> %c, %d
  %bc = bitcast <4 x i1> %cc to i4
  %cmp = icmp ne i4 %bc, 0
  %r = select i1 %cmp, <4 x i32> %a, <4 x i32> %b
  ret <4 x i32> %r
}

define <4 x i32> @test_select_cmp_4(<4 x i32> %a, <4 x i32> %b, <4 x i32> %c, <4 x i32> %d) {
; CHECK-LABEL: test_select_cmp_4:
; CHECK:       # %bb.0:
; CHECK-NEXT:    compnwp.ne $r4 = $r4, $r6
; CHECK-NEXT:    compnwp.ne $r5 = $r5, $r7
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    andd $r4 = $r4, $r5
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    compd.ne $r4 = $r4, -1
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    cmoved.even $r4 ? $r0 = $r2
; CHECK-NEXT:    cmoved.even $r4 ? $r1 = $r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 3)
  %cc = icmp ne <4 x i32> %c, %d
  %bc = bitcast <4 x i1> %cc to i4
  %cmp = icmp ne i4 %bc, -1
  %r = select i1 %cmp, <4 x i32> %a, <4 x i32> %b
  ret <4 x i32> %r
}

define <4 x i32> @fshl_rr(<4 x i32> %a, <4 x i32> %b, i32 %c) {
; CHECK-LABEL: fshl_rr:
; CHECK:       # %bb.0:
; CHECK-NEXT:    andw $r5 = $r4, 31
; CHECK-NEXT:    srad $r6 = $r1, 32
; CHECK-NEXT:    srad $r7 = $r3, 32
; CHECK-NEXT:    srad $r8 = $r0, 32
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sllw $r0 = $r0, $r5
; CHECK-NEXT:    sllw $r1 = $r1, $r5
; CHECK-NEXT:    sllw $r6 = $r6, $r5
; CHECK-NEXT:    sllw $r8 = $r8, $r5
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    srlw $r3 = $r3, 1
; CHECK-NEXT:    andnw $r4 = $r4, 31
; CHECK-NEXT:    srad $r5 = $r2, 32
; CHECK-NEXT:    srlw $r7 = $r7, 1
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    srlw $r2 = $r2, 1
; CHECK-NEXT:    srlw $r3 = $r3, $r4
; CHECK-NEXT:    srlw $r5 = $r5, 1
; CHECK-NEXT:    srlw $r7 = $r7, $r4
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    iorw $r1 = $r1, $r3
; CHECK-NEXT:    srlw $r2 = $r2, $r4
; CHECK-NEXT:    iorw $r4 = $r6, $r7
; CHECK-NEXT:    srlw $r5 = $r5, $r4
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    iorw $r0 = $r0, $r2
; CHECK-NEXT:    insf $r1 = $r4, 63, 32
; CHECK-NEXT:    iorw $r3 = $r8, $r5
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    insf $r0 = $r3, 63, 32
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 6)
  %i = insertelement <4 x i32> undef, i32 %c, i32 0
  %s = shufflevector <4 x i32> %i, <4 x i32> undef, <4 x i32> <i32 0, i32 0, i32 0, i32 0>
  %r = call <4 x i32> @llvm.fshl.v4i32(<4 x i32> %a, <4 x i32> %b, <4 x i32> %s)
  ret <4 x i32> %r
}

define <4 x i32> @fshl_ri(<4 x i32> %a, <4 x i32> %b) {
; CHECK-LABEL: fshl_ri:
; CHECK:       # %bb.0:
; CHECK-NEXT:    srad $r4 = $r3, 32
; CHECK-NEXT:    srad $r5 = $r1, 32
; CHECK-NEXT:    srad $r6 = $r2, 32
; CHECK-NEXT:    srad $r7 = $r0, 32
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sllw $r1 = $r1, 3
; CHECK-NEXT:    srlw $r3 = $r3, 29
; CHECK-NEXT:    srlw $r4 = $r4, 29
; CHECK-NEXT:    sllw $r5 = $r5, 3
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    sllw $r0 = $r0, 3
; CHECK-NEXT:    srlw $r2 = $r2, 29
; CHECK-NEXT:    srlw $r6 = $r6, 29
; CHECK-NEXT:    sllw $r7 = $r7, 3
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    iorw $r0 = $r0, $r2
; CHECK-NEXT:    iorw $r1 = $r1, $r3
; CHECK-NEXT:    iorw $r3 = $r7, $r6
; CHECK-NEXT:    iorw $r4 = $r5, $r4
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    insf $r0 = $r3, 63, 32
; CHECK-NEXT:    insf $r1 = $r4, 63, 32
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 4)
  %r = call <4 x i32> @llvm.fshl.v4i32(<4 x i32> %a, <4 x i32> %b, <4 x i32> <i32 3, i32 3, i32 3, i32 3>)
  ret <4 x i32> %r
}

define <4 x i32> @fshl_vec(<4 x i32> %a, <4 x i32> %b, <4 x i32> %c) {
; CHECK-LABEL: fshl_vec:
; CHECK:       # %bb.0:
; CHECK-NEXT:    srlw $r3 = $r3, 1
; CHECK-NEXT:    srad $r6 = $r5, 32
; CHECK-NEXT:    srad $r7 = $r3, 32
; CHECK-NEXT:    srad $r9 = $r1, 32
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    andw $r6 = $r6, 31
; CHECK-NEXT:    srlw $r7 = $r7, 1
; CHECK-NEXT:    andnw $r8 = $r6, 31
; CHECK-NEXT:    srad $r10 = $r0, 32
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    andw $r5 = $r5, 31
; CHECK-NEXT:    sllw $r6 = $r9, $r6
; CHECK-NEXT:    srlw $r7 = $r7, $r8
; CHECK-NEXT:    andnw $r8 = $r5, 31
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    sllw $r1 = $r1, $r5
; CHECK-NEXT:    srlw $r3 = $r3, $r8
; CHECK-NEXT:    srad $r8 = $r4, 32
; CHECK-NEXT:    srad $r9 = $r2, 32
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    andnw $r5 = $r8, 31
; CHECK-NEXT:    andw $r8 = $r8, 31
; CHECK-NEXT:    srlw $r9 = $r9, 1
; CHECK-NEXT:    andnw $r11 = $r4, 31
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    srlw $r2 = $r2, 1
; CHECK-NEXT:    andw $r4 = $r4, 31
; CHECK-NEXT:    srlw $r5 = $r9, $r5
; CHECK-NEXT:    sllw $r8 = $r10, $r8
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    sllw $r0 = $r0, $r4
; CHECK-NEXT:    iorw $r1 = $r1, $r3
; CHECK-NEXT:    srlw $r2 = $r2, $r11
; CHECK-NEXT:    iorw $r4 = $r6, $r7
; CHECK-NEXT:    ;; # (end cycle 6)
; CHECK-NEXT:    iorw $r0 = $r0, $r2
; CHECK-NEXT:    insf $r1 = $r4, 63, 32
; CHECK-NEXT:    iorw $r3 = $r8, $r5
; CHECK-NEXT:    ;; # (end cycle 7)
; CHECK-NEXT:    insf $r0 = $r3, 63, 32
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 8)
  %r = call <4 x i32> @llvm.fshl.v4i32(<4 x i32> %a, <4 x i32> %b, <4 x i32> %c)
  ret <4 x i32> %r
}
define <4 x i32> @fshr_rr(<4 x i32> %a, <4 x i32> %b, i32 %c) {
; CHECK-LABEL: fshr_rr:
; CHECK:       # %bb.0:
; CHECK-NEXT:    andw $r5 = $r4, 31
; CHECK-NEXT:    srad $r6 = $r3, 32
; CHECK-NEXT:    srad $r7 = $r1, 32
; CHECK-NEXT:    srad $r8 = $r2, 32
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    srlw $r2 = $r2, $r5
; CHECK-NEXT:    srlw $r3 = $r3, $r5
; CHECK-NEXT:    srlw $r6 = $r6, $r5
; CHECK-NEXT:    srlw $r8 = $r8, $r5
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    sllw $r1 = $r1, 1
; CHECK-NEXT:    andnw $r4 = $r4, 31
; CHECK-NEXT:    srad $r5 = $r0, 32
; CHECK-NEXT:    sllw $r7 = $r7, 1
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    sllw $r0 = $r0, 1
; CHECK-NEXT:    sllw $r1 = $r1, $r4
; CHECK-NEXT:    sllw $r5 = $r5, 1
; CHECK-NEXT:    sllw $r7 = $r7, $r4
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    sllw $r0 = $r0, $r4
; CHECK-NEXT:    iorw $r1 = $r1, $r3
; CHECK-NEXT:    iorw $r4 = $r7, $r6
; CHECK-NEXT:    sllw $r5 = $r5, $r4
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    iorw $r0 = $r0, $r2
; CHECK-NEXT:    insf $r1 = $r4, 63, 32
; CHECK-NEXT:    iorw $r3 = $r5, $r8
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    insf $r0 = $r3, 63, 32
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 6)
  %i = insertelement <4 x i32> undef, i32 %c, i32 0
  %s = shufflevector <4 x i32> %i, <4 x i32> undef, <4 x i32> <i32 0, i32 0, i32 0, i32 0>
  %r = call <4 x i32> @llvm.fshr.v4i32(<4 x i32> %a, <4 x i32> %b, <4 x i32> %s)
  ret <4 x i32> %r
}

define <4 x i32> @fshr_ri(<4 x i32> %a, <4 x i32> %b, i32 %c) {
; CHECK-LABEL: fshr_ri:
; CHECK:       # %bb.0:
; CHECK-NEXT:    srad $r4 = $r3, 32
; CHECK-NEXT:    srad $r5 = $r1, 32
; CHECK-NEXT:    srad $r6 = $r2, 32
; CHECK-NEXT:    srad $r7 = $r0, 32
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sllw $r1 = $r1, 29
; CHECK-NEXT:    srlw $r3 = $r3, 3
; CHECK-NEXT:    srlw $r4 = $r4, 3
; CHECK-NEXT:    sllw $r5 = $r5, 29
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    sllw $r0 = $r0, 29
; CHECK-NEXT:    srlw $r2 = $r2, 3
; CHECK-NEXT:    srlw $r6 = $r6, 3
; CHECK-NEXT:    sllw $r7 = $r7, 29
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    iorw $r0 = $r0, $r2
; CHECK-NEXT:    iorw $r1 = $r1, $r3
; CHECK-NEXT:    iorw $r3 = $r7, $r6
; CHECK-NEXT:    iorw $r4 = $r5, $r4
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    insf $r0 = $r3, 63, 32
; CHECK-NEXT:    insf $r1 = $r4, 63, 32
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 4)
  %r = call <4 x i32> @llvm.fshr.v4i32(<4 x i32> %a, <4 x i32> %b, <4 x i32> <i32 3, i32 3, i32 3, i32 3>)
  ret <4 x i32> %r
}

define <4 x i32> @fshr_vec(<4 x i32> %a, <4 x i32> %b, <4 x i32> %c) {
; CHECK-LABEL: fshr_vec:
; CHECK:       # %bb.0:
; CHECK-NEXT:    sllw $r1 = $r1, 1
; CHECK-NEXT:    srad $r6 = $r5, 32
; CHECK-NEXT:    srad $r7 = $r3, 32
; CHECK-NEXT:    srad $r9 = $r1, 32
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    andnw $r6 = $r6, 31
; CHECK-NEXT:    andw $r8 = $r6, 31
; CHECK-NEXT:    srad $r10 = $r0, 32
; CHECK-NEXT:    andw $r11 = $r4, 31
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    andnw $r5 = $r5, 31
; CHECK-NEXT:    srlw $r7 = $r7, $r8
; CHECK-NEXT:    sllw $r8 = $r9, 1
; CHECK-NEXT:    andw $r9 = $r5, 31
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    sllw $r1 = $r1, $r5
; CHECK-NEXT:    srlw $r3 = $r3, $r9
; CHECK-NEXT:    srad $r5 = $r4, 32
; CHECK-NEXT:    sllw $r6 = $r8, $r6
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    andnw $r5 = $r5, 31
; CHECK-NEXT:    srad $r8 = $r2, 32
; CHECK-NEXT:    andw $r9 = $r5, 31
; CHECK-NEXT:    sllw $r10 = $r10, 1
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    sllw $r0 = $r0, 1
; CHECK-NEXT:    andnw $r4 = $r4, 31
; CHECK-NEXT:    sllw $r5 = $r10, $r5
; CHECK-NEXT:    srlw $r8 = $r8, $r9
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    sllw $r0 = $r0, $r4
; CHECK-NEXT:    iorw $r1 = $r1, $r3
; CHECK-NEXT:    srlw $r2 = $r2, $r11
; CHECK-NEXT:    iorw $r4 = $r6, $r7
; CHECK-NEXT:    ;; # (end cycle 6)
; CHECK-NEXT:    iorw $r0 = $r0, $r2
; CHECK-NEXT:    insf $r1 = $r4, 63, 32
; CHECK-NEXT:    iorw $r3 = $r5, $r8
; CHECK-NEXT:    ;; # (end cycle 7)
; CHECK-NEXT:    insf $r0 = $r3, 63, 32
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 8)
  %r = call <4 x i32> @llvm.fshr.v4i32(<4 x i32> %a, <4 x i32> %b, <4 x i32> %c)
  ret <4 x i32> %r
}

declare <4 x i32> @llvm.fshr.v4i32(<4 x i32>, <4 x i32>, <4 x i32>)
declare <4 x i32> @llvm.fshl.v4i32(<4 x i32>, <4 x i32>, <4 x i32>)

define <4 x i32> @shl_wp(<4 x i32> %0) {
; CHECK-LABEL: shl_wp:
; CHECK:       # %bb.0:
; CHECK-NEXT:    sllwps $r0 = $r0, 15
; CHECK-NEXT:    sllwps $r1 = $r1, 15
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %2 = shl <4 x i32> %0, <i32 15, i32 15, i32 15, i32 15>
  ret <4 x i32> %2
}

define <4 x i32> @shl_wp_r(<4 x i32> %0, i32 %1) {
; CHECK-LABEL: shl_wp_r:
; CHECK:       # %bb.0:
; CHECK-NEXT:    sllwps $r0 = $r0, $r2
; CHECK-NEXT:    sllwps $r1 = $r1, $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %3 = insertelement <4 x i32> poison, i32 %1, i64 0
  %4 = shufflevector <4 x i32> %3, <4 x i32> poison, <4 x i32> zeroinitializer
  %5 = shl <4 x i32> %0, %4
  ret <4 x i32> %5
}

define <4 x i32> @shl_wp2(<4 x i32> %0) {
; CHECK-LABEL: shl_wp2:
; CHECK:       # %bb.0:
; CHECK-NEXT:    sllwps $r0 = $r0, 15
; CHECK-NEXT:    sllwps $r1 = $r1, 17
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %2 = shl <4 x i32> %0, <i32 15, i32 15, i32 17, i32 17>
  ret <4 x i32> %2
}

define <4 x i32> @shl_wp_r2(<4 x i32> %0, i32 %1, i32 %2) {
; CHECK-LABEL: shl_wp_r2:
; CHECK:       # %bb.0:
; CHECK-NEXT:    sllwps $r0 = $r0, $r2
; CHECK-NEXT:    sllwps $r1 = $r1, $r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %4 = insertelement <4 x i32> undef, i32 %1, i64 0
  %5 = insertelement <4 x i32> %4, i32 %1, i64 1
  %6 = insertelement <4 x i32> %5, i32 %2, i64 2
  %7 = insertelement <4 x i32> %6, i32 %2, i64 3
  %8 = shl <4 x i32> %0, %7
  ret <4 x i32> %8
}

define <4 x i32> @shl_notwp(<4 x i32> %0) {
; CHECK-LABEL: shl_notwp:
; CHECK:       # %bb.0:
; CHECK-NEXT:    sllwps $r0 = $r0, 15
; CHECK-NEXT:    sllwps $r1 = $r1, 31
; CHECK-NEXT:    sllw $r2 = $r0, 1
; CHECK-NEXT:    sllw $r3 = $r1, 15
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    insf $r0 = $r2, 31, 0
; CHECK-NEXT:    insf $r1 = $r3, 31, 0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
  %2 = shl <4 x i32> %0, <i32 1, i32 15, i32 15, i32 31>
  ret <4 x i32> %2
}

define <4 x i32> @shl_notwp_r(<4 x i32> %0, <4 x i32> %1) {
; CHECK-LABEL: shl_notwp_r:
; CHECK:       # %bb.0:
; CHECK-NEXT:    sllw $r2 = $r0, $r2
; CHECK-NEXT:    sllw $r3 = $r1, $r3
; CHECK-NEXT:    extfz $r4 = $r2, 36, 32
; CHECK-NEXT:    extfz $r5 = $r3, 36, 32
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sllwps $r0 = $r0, $r4
; CHECK-NEXT:    sllwps $r1 = $r1, $r5
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    insf $r0 = $r2, 31, 0
; CHECK-NEXT:    insf $r1 = $r3, 31, 0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 2)
  %3 = shl <4 x i32> %0, %1
  ret <4 x i32> %3
}

define <4 x i32> @lshr_wp(<4 x i32> %0) {
; CHECK-LABEL: lshr_wp:
; CHECK:       # %bb.0:
; CHECK-NEXT:    srlwps $r0 = $r0, 15
; CHECK-NEXT:    srlwps $r1 = $r1, 15
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %2 = lshr <4 x i32> %0, <i32 15, i32 15, i32 15, i32 15>
  ret <4 x i32> %2
}

define <4 x i32> @lshr_wp_r(<4 x i32> %0, i32 %1) {
; CHECK-LABEL: lshr_wp_r:
; CHECK:       # %bb.0:
; CHECK-NEXT:    srlwps $r0 = $r0, $r2
; CHECK-NEXT:    srlwps $r1 = $r1, $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %3 = insertelement <4 x i32> poison, i32 %1, i64 0
  %4 = shufflevector <4 x i32> %3, <4 x i32> poison, <4 x i32> zeroinitializer
  %5 = lshr <4 x i32> %0, %4
  ret <4 x i32> %5
}

define <4 x i32> @lshr_wp2(<4 x i32> %0) {
; CHECK-LABEL: lshr_wp2:
; CHECK:       # %bb.0:
; CHECK-NEXT:    srlwps $r0 = $r0, 15
; CHECK-NEXT:    srlwps $r1 = $r1, 17
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %2 = lshr <4 x i32> %0, <i32 15, i32 15, i32 17, i32 17>
  ret <4 x i32> %2
}

define <4 x i32> @lshr_wp_r2(<4 x i32> %0, i32 %1, i32 %2) {
; CHECK-LABEL: lshr_wp_r2:
; CHECK:       # %bb.0:
; CHECK-NEXT:    srlwps $r0 = $r0, $r2
; CHECK-NEXT:    srlwps $r1 = $r1, $r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %4 = insertelement <4 x i32> undef, i32 %1, i64 0
  %5 = insertelement <4 x i32> %4, i32 %1, i64 1
  %6 = insertelement <4 x i32> %5, i32 %2, i64 2
  %7 = insertelement <4 x i32> %6, i32 %2, i64 3
  %8 = lshr <4 x i32> %0, %7
  ret <4 x i32> %8
}

define <4 x i32> @lshr_notwp(<4 x i32> %0) {
; CHECK-LABEL: lshr_notwp:
; CHECK:       # %bb.0:
; CHECK-NEXT:    srlwps $r0 = $r0, 15
; CHECK-NEXT:    srlwps $r1 = $r1, 31
; CHECK-NEXT:    srlw $r2 = $r0, 1
; CHECK-NEXT:    srlw $r3 = $r1, 15
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    insf $r0 = $r2, 31, 0
; CHECK-NEXT:    insf $r1 = $r3, 31, 0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
  %2 = lshr <4 x i32> %0, <i32 1, i32 15, i32 15, i32 31>
  ret <4 x i32> %2
}

define <4 x i32> @lshr_notwp_r(<4 x i32> %0, <4 x i32> %1) {
; CHECK-LABEL: lshr_notwp_r:
; CHECK:       # %bb.0:
; CHECK-NEXT:    srlw $r2 = $r0, $r2
; CHECK-NEXT:    srlw $r3 = $r1, $r3
; CHECK-NEXT:    extfz $r4 = $r2, 36, 32
; CHECK-NEXT:    extfz $r5 = $r3, 36, 32
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    srlwps $r0 = $r0, $r4
; CHECK-NEXT:    srlwps $r1 = $r1, $r5
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    insf $r0 = $r2, 31, 0
; CHECK-NEXT:    insf $r1 = $r3, 31, 0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 2)
  %3 = lshr <4 x i32> %0, %1
  ret <4 x i32> %3
}

define <4 x i32> @ashr_wp(<4 x i32> %0) {
; CHECK-LABEL: ashr_wp:
; CHECK:       # %bb.0:
; CHECK-NEXT:    srawps $r0 = $r0, 15
; CHECK-NEXT:    srawps $r1 = $r1, 15
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %2 = ashr <4 x i32> %0, <i32 15, i32 15, i32 15, i32 15>
  ret <4 x i32> %2
}

define <4 x i32> @ashr_wp_r(<4 x i32> %0, i32 %1) {
; CHECK-LABEL: ashr_wp_r:
; CHECK:       # %bb.0:
; CHECK-NEXT:    srawps $r0 = $r0, $r2
; CHECK-NEXT:    srawps $r1 = $r1, $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %3 = insertelement <4 x i32> poison, i32 %1, i64 0
  %4 = shufflevector <4 x i32> %3, <4 x i32> poison, <4 x i32> zeroinitializer
  %5 = ashr <4 x i32> %0, %4
  ret <4 x i32> %5
}

define <4 x i32> @ashr_wp2(<4 x i32> %0) {
; CHECK-LABEL: ashr_wp2:
; CHECK:       # %bb.0:
; CHECK-NEXT:    srawps $r0 = $r0, 15
; CHECK-NEXT:    srawps $r1 = $r1, 17
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %2 = ashr <4 x i32> %0, <i32 15, i32 15, i32 17, i32 17>
  ret <4 x i32> %2
}

define <4 x i32> @ashr_wp_r2(<4 x i32> %0, i32 %1, i32 %2) {
; CHECK-LABEL: ashr_wp_r2:
; CHECK:       # %bb.0:
; CHECK-NEXT:    srawps $r0 = $r0, $r2
; CHECK-NEXT:    srawps $r1 = $r1, $r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %4 = insertelement <4 x i32> undef, i32 %1, i64 0
  %5 = insertelement <4 x i32> %4, i32 %1, i64 1
  %6 = insertelement <4 x i32> %5, i32 %2, i64 2
  %7 = insertelement <4 x i32> %6, i32 %2, i64 3
  %8 = ashr <4 x i32> %0, %7
  ret <4 x i32> %8
}

define <4 x i32> @ashr_notwp(<4 x i32> %0) {
; CHECK-LABEL: ashr_notwp:
; CHECK:       # %bb.0:
; CHECK-NEXT:    srawps $r0 = $r0, 15
; CHECK-NEXT:    srawps $r1 = $r1, 31
; CHECK-NEXT:    sraw $r2 = $r0, 1
; CHECK-NEXT:    sraw $r3 = $r1, 15
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    insf $r0 = $r2, 31, 0
; CHECK-NEXT:    insf $r1 = $r3, 31, 0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
  %2 = ashr <4 x i32> %0, <i32 1, i32 15, i32 15, i32 31>
  ret <4 x i32> %2
}

define <4 x i32> @ashr_notwp_r(<4 x i32> %0, <4 x i32> %1) {
; CHECK-LABEL: ashr_notwp_r:
; CHECK:       # %bb.0:
; CHECK-NEXT:    sraw $r2 = $r0, $r2
; CHECK-NEXT:    sraw $r3 = $r1, $r3
; CHECK-NEXT:    extfz $r4 = $r2, 36, 32
; CHECK-NEXT:    extfz $r5 = $r3, 36, 32
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    srawps $r0 = $r0, $r4
; CHECK-NEXT:    srawps $r1 = $r1, $r5
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    insf $r0 = $r2, 31, 0
; CHECK-NEXT:    insf $r1 = $r3, 31, 0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 2)
  %3 = ashr <4 x i32> %0, %1
  ret <4 x i32> %3
}


define <4 x i32> @sdiv(<4 x i32> %a, <4 x i32> %b) {
; CHECK-LABEL: sdiv:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addd $r12 = $r12, -64
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 56[$r12] = $r16
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    sd 48[$r12] = $r22
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    sq 32[$r12] = $r20r21
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    sq 16[$r12] = $r18r19
; CHECK-NEXT:    copyd $r18 = $r3
; CHECK-NEXT:    copyd $r19 = $r2
; CHECK-NEXT:    copyd $r20 = $r1
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    srad $r0 = $r20, 32
; CHECK-NEXT:    srad $r1 = $r18, 32
; CHECK-NEXT:    copyd $r21 = $r0
; CHECK-NEXT:    call __divsi3
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    copyd $r0 = $r20
; CHECK-NEXT:    copyd $r1 = $r18
; CHECK-NEXT:    copyd $r22 = $r0
; CHECK-NEXT:    call __divsi3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    srad $r0 = $r21, 32
; CHECK-NEXT:    srad $r1 = $r19, 32
; CHECK-NEXT:    copyd $r18 = $r0
; CHECK-NEXT:    call __divsi3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    copyd $r0 = $r21
; CHECK-NEXT:    copyd $r1 = $r19
; CHECK-NEXT:    copyd $r20 = $r0
; CHECK-NEXT:    call __divsi3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    insf $r0 = $r20, 63, 32
; CHECK-NEXT:    insf $r18 = $r22, 63, 32
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    lq $r18r19 = 16[$r12]
; CHECK-NEXT:    copyd $r1 = $r18
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    lq $r20r21 = 32[$r12]
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    ld $r22 = 48[$r12]
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    ld $r16 = 56[$r12]
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 64
; CHECK-NEXT:    ;; # (end cycle 9)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %r = sdiv <4 x i32> %a, %b
  ret <4 x i32> %r
}

define <4 x i32> @sdiv_vs(<4 x i32> %a, i32 %b) {
; CHECK-LABEL: sdiv_vs:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addd $r12 = $r12, -64
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 56[$r12] = $r16
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    sd 48[$r12] = $r22
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    sq 32[$r12] = $r20r21
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    sq 16[$r12] = $r18r19
; CHECK-NEXT:    copyd $r18 = $r2
; CHECK-NEXT:    copyd $r19 = $r1
; CHECK-NEXT:    copyd $r20 = $r0
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    srad $r0 = $r19, 32
; CHECK-NEXT:    copyd $r1 = $r18
; CHECK-NEXT:    call __divsi3
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    copyd $r0 = $r19
; CHECK-NEXT:    copyd $r1 = $r18
; CHECK-NEXT:    copyd $r21 = $r0
; CHECK-NEXT:    call __divsi3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    srad $r0 = $r20, 32
; CHECK-NEXT:    copyd $r1 = $r18
; CHECK-NEXT:    copyd $r19 = $r0
; CHECK-NEXT:    call __divsi3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    copyd $r0 = $r20
; CHECK-NEXT:    copyd $r1 = $r18
; CHECK-NEXT:    copyd $r22 = $r0
; CHECK-NEXT:    call __divsi3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    insf $r0 = $r22, 63, 32
; CHECK-NEXT:    insf $r19 = $r21, 63, 32
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    lq $r18r19 = 16[$r12]
; CHECK-NEXT:    copyd $r1 = $r19
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    lq $r20r21 = 32[$r12]
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    ld $r22 = 48[$r12]
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    ld $r16 = 56[$r12]
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 64
; CHECK-NEXT:    ;; # (end cycle 9)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %v0 = insertelement <4 x i32> undef, i32 %b, i32 0
  %splat = shufflevector <4 x i32> %v0, <4 x i32> undef, <4 x i32> zeroinitializer
  %div = sdiv <4 x i32> %a, %splat
  ret <4 x i32> %div
}

define <4 x i32> @sdiv_sv(<4 x i32> %a, i32 %b) {
; CHECK-LABEL: sdiv_sv:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addd $r12 = $r12, -64
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 56[$r12] = $r16
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    sd 48[$r12] = $r22
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    sq 32[$r12] = $r20r21
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    sq 16[$r12] = $r18r19
; CHECK-NEXT:    copyd $r18 = $r2
; CHECK-NEXT:    copyd $r19 = $r1
; CHECK-NEXT:    copyd $r20 = $r0
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    copyd $r0 = $r18
; CHECK-NEXT:    srad $r1 = $r19, 32
; CHECK-NEXT:    call __divsi3
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    copyd $r0 = $r18
; CHECK-NEXT:    copyd $r1 = $r19
; CHECK-NEXT:    copyd $r21 = $r0
; CHECK-NEXT:    call __divsi3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    copyd $r0 = $r18
; CHECK-NEXT:    srad $r1 = $r20, 32
; CHECK-NEXT:    copyd $r19 = $r0
; CHECK-NEXT:    call __divsi3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    copyd $r0 = $r18
; CHECK-NEXT:    copyd $r1 = $r20
; CHECK-NEXT:    copyd $r22 = $r0
; CHECK-NEXT:    call __divsi3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    insf $r0 = $r22, 63, 32
; CHECK-NEXT:    insf $r19 = $r21, 63, 32
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    lq $r18r19 = 16[$r12]
; CHECK-NEXT:    copyd $r1 = $r19
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    lq $r20r21 = 32[$r12]
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    ld $r22 = 48[$r12]
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    ld $r16 = 56[$r12]
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 64
; CHECK-NEXT:    ;; # (end cycle 9)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %v0 = insertelement <4 x i32> undef, i32 %b, i32 0
  %splat = shufflevector <4 x i32> %v0, <4 x i32> undef, <4 x i32> zeroinitializer
  %div = sdiv <4 x i32> %splat, %a
  ret <4 x i32> %div
}

define <4 x i32> @sdiv_ss(i32 %a, i32 %b) {
; CHECK-LABEL: sdiv_ss:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addd $r12 = $r12, -32
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 24[$r12] = $r16
; CHECK-NEXT:    copyd $r0 = $r1
; CHECK-NEXT:    copyd $r1 = $r0
; CHECK-NEXT:    call __divsi3
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    insf $r0 = $r0, 63, 32
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    copyd $r1 = $r0
; CHECK-NEXT:    ld $r16 = 24[$r12]
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 32
; CHECK-NEXT:    ;; # (end cycle 6)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %va = insertelement <4 x i32> undef, i32 %b, i32 0
  %vb = insertelement <4 x i32> undef, i32 %a, i32 0
  %splata = shufflevector <4 x i32> %va, <4 x i32> undef, <4 x i32> zeroinitializer
  %splatb = shufflevector <4 x i32> %vb, <4 x i32> undef, <4 x i32> zeroinitializer
  %div = sdiv <4 x i32> %splata, %splatb
  ret <4 x i32> %div
}

define <4 x i32> @srem(<4 x i32> %a, <4 x i32> %b) {
; CHECK-LABEL: srem:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addd $r12 = $r12, -64
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 56[$r12] = $r16
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    sd 48[$r12] = $r22
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    sq 32[$r12] = $r20r21
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    sq 16[$r12] = $r18r19
; CHECK-NEXT:    copyd $r18 = $r3
; CHECK-NEXT:    copyd $r19 = $r2
; CHECK-NEXT:    copyd $r20 = $r1
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    srad $r0 = $r20, 32
; CHECK-NEXT:    srad $r1 = $r18, 32
; CHECK-NEXT:    copyd $r21 = $r0
; CHECK-NEXT:    call __modsi3
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    copyd $r0 = $r20
; CHECK-NEXT:    copyd $r1 = $r18
; CHECK-NEXT:    copyd $r22 = $r0
; CHECK-NEXT:    call __modsi3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    srad $r0 = $r21, 32
; CHECK-NEXT:    srad $r1 = $r19, 32
; CHECK-NEXT:    copyd $r18 = $r0
; CHECK-NEXT:    call __modsi3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    copyd $r0 = $r21
; CHECK-NEXT:    copyd $r1 = $r19
; CHECK-NEXT:    copyd $r20 = $r0
; CHECK-NEXT:    call __modsi3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    insf $r0 = $r20, 63, 32
; CHECK-NEXT:    insf $r18 = $r22, 63, 32
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    lq $r18r19 = 16[$r12]
; CHECK-NEXT:    copyd $r1 = $r18
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    lq $r20r21 = 32[$r12]
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    ld $r22 = 48[$r12]
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    ld $r16 = 56[$r12]
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 64
; CHECK-NEXT:    ;; # (end cycle 9)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %r = srem <4 x i32> %a, %b
  ret <4 x i32> %r
}

define <4 x i32> @srem_vs(<4 x i32> %a, i32 %b) {
; CHECK-LABEL: srem_vs:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addd $r12 = $r12, -64
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 56[$r12] = $r16
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    sd 48[$r12] = $r22
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    sq 32[$r12] = $r20r21
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    sq 16[$r12] = $r18r19
; CHECK-NEXT:    copyd $r18 = $r2
; CHECK-NEXT:    copyd $r19 = $r1
; CHECK-NEXT:    copyd $r20 = $r0
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    srad $r0 = $r19, 32
; CHECK-NEXT:    copyd $r1 = $r18
; CHECK-NEXT:    call __modsi3
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    copyd $r0 = $r19
; CHECK-NEXT:    copyd $r1 = $r18
; CHECK-NEXT:    copyd $r21 = $r0
; CHECK-NEXT:    call __modsi3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    srad $r0 = $r20, 32
; CHECK-NEXT:    copyd $r1 = $r18
; CHECK-NEXT:    copyd $r19 = $r0
; CHECK-NEXT:    call __modsi3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    copyd $r0 = $r20
; CHECK-NEXT:    copyd $r1 = $r18
; CHECK-NEXT:    copyd $r22 = $r0
; CHECK-NEXT:    call __modsi3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    insf $r0 = $r22, 63, 32
; CHECK-NEXT:    insf $r19 = $r21, 63, 32
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    lq $r18r19 = 16[$r12]
; CHECK-NEXT:    copyd $r1 = $r19
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    lq $r20r21 = 32[$r12]
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    ld $r22 = 48[$r12]
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    ld $r16 = 56[$r12]
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 64
; CHECK-NEXT:    ;; # (end cycle 9)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %v0 = insertelement <4 x i32> undef, i32 %b, i32 0
  %splat = shufflevector <4 x i32> %v0, <4 x i32> undef, <4 x i32> zeroinitializer
  %div = srem <4 x i32> %a, %splat
  ret <4 x i32> %div
}

define <4 x i32> @srem_sv(<4 x i32> %a, i32 %b) {
; CHECK-LABEL: srem_sv:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addd $r12 = $r12, -64
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 56[$r12] = $r16
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    sd 48[$r12] = $r22
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    sq 32[$r12] = $r20r21
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    sq 16[$r12] = $r18r19
; CHECK-NEXT:    copyd $r18 = $r2
; CHECK-NEXT:    copyd $r19 = $r1
; CHECK-NEXT:    copyd $r20 = $r0
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    copyd $r0 = $r18
; CHECK-NEXT:    srad $r1 = $r19, 32
; CHECK-NEXT:    call __modsi3
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    copyd $r0 = $r18
; CHECK-NEXT:    copyd $r1 = $r19
; CHECK-NEXT:    copyd $r21 = $r0
; CHECK-NEXT:    call __modsi3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    copyd $r0 = $r18
; CHECK-NEXT:    srad $r1 = $r20, 32
; CHECK-NEXT:    copyd $r19 = $r0
; CHECK-NEXT:    call __modsi3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    copyd $r0 = $r18
; CHECK-NEXT:    copyd $r1 = $r20
; CHECK-NEXT:    copyd $r22 = $r0
; CHECK-NEXT:    call __modsi3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    insf $r0 = $r22, 63, 32
; CHECK-NEXT:    insf $r19 = $r21, 63, 32
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    lq $r18r19 = 16[$r12]
; CHECK-NEXT:    copyd $r1 = $r19
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    lq $r20r21 = 32[$r12]
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    ld $r22 = 48[$r12]
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    ld $r16 = 56[$r12]
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 64
; CHECK-NEXT:    ;; # (end cycle 9)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %v0 = insertelement <4 x i32> undef, i32 %b, i32 0
  %splat = shufflevector <4 x i32> %v0, <4 x i32> undef, <4 x i32> zeroinitializer
  %div = srem <4 x i32> %splat, %a
  ret <4 x i32> %div
}

define <4 x i32> @srem_ss(i32 %a, i32 %b) {
; CHECK-LABEL: srem_ss:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addd $r12 = $r12, -32
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 24[$r12] = $r16
; CHECK-NEXT:    copyd $r0 = $r1
; CHECK-NEXT:    copyd $r1 = $r0
; CHECK-NEXT:    call __modsi3
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    insf $r0 = $r0, 63, 32
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    copyd $r1 = $r0
; CHECK-NEXT:    ld $r16 = 24[$r12]
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 32
; CHECK-NEXT:    ;; # (end cycle 6)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %va = insertelement <4 x i32> undef, i32 %b, i32 0
  %vb = insertelement <4 x i32> undef, i32 %a, i32 0
  %splata = shufflevector <4 x i32> %va, <4 x i32> undef, <4 x i32> zeroinitializer
  %splatb = shufflevector <4 x i32> %vb, <4 x i32> undef, <4 x i32> zeroinitializer
  %div = srem <4 x i32> %splata, %splatb
  ret <4 x i32> %div
}

define <4 x i32> @udiv(<4 x i32> %a, <4 x i32> %b) {
; CHECK-LABEL: udiv:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addd $r12 = $r12, -64
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 56[$r12] = $r16
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    sd 48[$r12] = $r22
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    sq 32[$r12] = $r20r21
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    sq 16[$r12] = $r18r19
; CHECK-NEXT:    copyd $r18 = $r3
; CHECK-NEXT:    copyd $r19 = $r2
; CHECK-NEXT:    copyd $r20 = $r1
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    srad $r0 = $r20, 32
; CHECK-NEXT:    srad $r1 = $r18, 32
; CHECK-NEXT:    copyd $r21 = $r0
; CHECK-NEXT:    call __udivsi3
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    copyd $r0 = $r20
; CHECK-NEXT:    copyd $r1 = $r18
; CHECK-NEXT:    copyd $r22 = $r0
; CHECK-NEXT:    call __udivsi3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    srad $r0 = $r21, 32
; CHECK-NEXT:    srad $r1 = $r19, 32
; CHECK-NEXT:    copyd $r18 = $r0
; CHECK-NEXT:    call __udivsi3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    copyd $r0 = $r21
; CHECK-NEXT:    copyd $r1 = $r19
; CHECK-NEXT:    copyd $r20 = $r0
; CHECK-NEXT:    call __udivsi3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    insf $r0 = $r20, 63, 32
; CHECK-NEXT:    insf $r18 = $r22, 63, 32
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    lq $r18r19 = 16[$r12]
; CHECK-NEXT:    copyd $r1 = $r18
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    lq $r20r21 = 32[$r12]
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    ld $r22 = 48[$r12]
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    ld $r16 = 56[$r12]
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 64
; CHECK-NEXT:    ;; # (end cycle 9)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %r = udiv <4 x i32> %a, %b
  ret <4 x i32> %r
}

define <4 x i32> @udiv_vs(<4 x i32> %a, i32 %b) {
; CHECK-LABEL: udiv_vs:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addd $r12 = $r12, -64
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 56[$r12] = $r16
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    sd 48[$r12] = $r22
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    sq 32[$r12] = $r20r21
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    sq 16[$r12] = $r18r19
; CHECK-NEXT:    copyd $r18 = $r2
; CHECK-NEXT:    copyd $r19 = $r1
; CHECK-NEXT:    copyd $r20 = $r0
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    srad $r0 = $r19, 32
; CHECK-NEXT:    copyd $r1 = $r18
; CHECK-NEXT:    call __udivsi3
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    copyd $r0 = $r19
; CHECK-NEXT:    copyd $r1 = $r18
; CHECK-NEXT:    copyd $r21 = $r0
; CHECK-NEXT:    call __udivsi3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    srad $r0 = $r20, 32
; CHECK-NEXT:    copyd $r1 = $r18
; CHECK-NEXT:    copyd $r19 = $r0
; CHECK-NEXT:    call __udivsi3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    copyd $r0 = $r20
; CHECK-NEXT:    copyd $r1 = $r18
; CHECK-NEXT:    copyd $r22 = $r0
; CHECK-NEXT:    call __udivsi3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    insf $r0 = $r22, 63, 32
; CHECK-NEXT:    insf $r19 = $r21, 63, 32
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    lq $r18r19 = 16[$r12]
; CHECK-NEXT:    copyd $r1 = $r19
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    lq $r20r21 = 32[$r12]
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    ld $r22 = 48[$r12]
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    ld $r16 = 56[$r12]
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 64
; CHECK-NEXT:    ;; # (end cycle 9)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %v0 = insertelement <4 x i32> undef, i32 %b, i32 0
  %splat = shufflevector <4 x i32> %v0, <4 x i32> undef, <4 x i32> zeroinitializer
  %div = udiv <4 x i32> %a, %splat
  ret <4 x i32> %div
}

define <4 x i32> @udiv_sv(<4 x i32> %a, i32 %b) {
; CHECK-LABEL: udiv_sv:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addd $r12 = $r12, -64
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 56[$r12] = $r16
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    sd 48[$r12] = $r22
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    sq 32[$r12] = $r20r21
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    sq 16[$r12] = $r18r19
; CHECK-NEXT:    copyd $r18 = $r2
; CHECK-NEXT:    copyd $r19 = $r1
; CHECK-NEXT:    copyd $r20 = $r0
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    copyd $r0 = $r18
; CHECK-NEXT:    srad $r1 = $r19, 32
; CHECK-NEXT:    call __udivsi3
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    copyd $r0 = $r18
; CHECK-NEXT:    copyd $r1 = $r19
; CHECK-NEXT:    copyd $r21 = $r0
; CHECK-NEXT:    call __udivsi3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    copyd $r0 = $r18
; CHECK-NEXT:    srad $r1 = $r20, 32
; CHECK-NEXT:    copyd $r19 = $r0
; CHECK-NEXT:    call __udivsi3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    copyd $r0 = $r18
; CHECK-NEXT:    copyd $r1 = $r20
; CHECK-NEXT:    copyd $r22 = $r0
; CHECK-NEXT:    call __udivsi3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    insf $r0 = $r22, 63, 32
; CHECK-NEXT:    insf $r19 = $r21, 63, 32
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    lq $r18r19 = 16[$r12]
; CHECK-NEXT:    copyd $r1 = $r19
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    lq $r20r21 = 32[$r12]
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    ld $r22 = 48[$r12]
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    ld $r16 = 56[$r12]
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 64
; CHECK-NEXT:    ;; # (end cycle 9)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %v0 = insertelement <4 x i32> undef, i32 %b, i32 0
  %splat = shufflevector <4 x i32> %v0, <4 x i32> undef, <4 x i32> zeroinitializer
  %div = udiv <4 x i32> %splat, %a
  ret <4 x i32> %div
}

define <4 x i32> @udiv_ss(i32 %a, i32 %b) {
; CHECK-LABEL: udiv_ss:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addd $r12 = $r12, -32
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 24[$r12] = $r16
; CHECK-NEXT:    copyd $r0 = $r1
; CHECK-NEXT:    copyd $r1 = $r0
; CHECK-NEXT:    call __udivsi3
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    insf $r0 = $r0, 63, 32
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    copyd $r1 = $r0
; CHECK-NEXT:    ld $r16 = 24[$r12]
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 32
; CHECK-NEXT:    ;; # (end cycle 6)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %va = insertelement <4 x i32> undef, i32 %b, i32 0
  %vb = insertelement <4 x i32> undef, i32 %a, i32 0
  %splata = shufflevector <4 x i32> %va, <4 x i32> undef, <4 x i32> zeroinitializer
  %splatb = shufflevector <4 x i32> %vb, <4 x i32> undef, <4 x i32> zeroinitializer
  %div = udiv <4 x i32> %splata, %splatb
  ret <4 x i32> %div
}

define <4 x i32> @urem(<4 x i32> %a, <4 x i32> %b) {
; CHECK-LABEL: urem:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addd $r12 = $r12, -64
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 56[$r12] = $r16
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    sd 48[$r12] = $r22
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    sq 32[$r12] = $r20r21
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    sq 16[$r12] = $r18r19
; CHECK-NEXT:    copyd $r18 = $r3
; CHECK-NEXT:    copyd $r19 = $r2
; CHECK-NEXT:    copyd $r20 = $r1
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    srad $r0 = $r20, 32
; CHECK-NEXT:    srad $r1 = $r18, 32
; CHECK-NEXT:    copyd $r21 = $r0
; CHECK-NEXT:    call __umodsi3
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    copyd $r0 = $r20
; CHECK-NEXT:    copyd $r1 = $r18
; CHECK-NEXT:    copyd $r22 = $r0
; CHECK-NEXT:    call __umodsi3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    srad $r0 = $r21, 32
; CHECK-NEXT:    srad $r1 = $r19, 32
; CHECK-NEXT:    copyd $r18 = $r0
; CHECK-NEXT:    call __umodsi3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    copyd $r0 = $r21
; CHECK-NEXT:    copyd $r1 = $r19
; CHECK-NEXT:    copyd $r20 = $r0
; CHECK-NEXT:    call __umodsi3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    insf $r0 = $r20, 63, 32
; CHECK-NEXT:    insf $r18 = $r22, 63, 32
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    lq $r18r19 = 16[$r12]
; CHECK-NEXT:    copyd $r1 = $r18
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    lq $r20r21 = 32[$r12]
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    ld $r22 = 48[$r12]
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    ld $r16 = 56[$r12]
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 64
; CHECK-NEXT:    ;; # (end cycle 9)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %r = urem <4 x i32> %a, %b
  ret <4 x i32> %r
}

define <4 x i32> @urem_vs(<4 x i32> %a, i32 %b) {
; CHECK-LABEL: urem_vs:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addd $r12 = $r12, -64
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 56[$r12] = $r16
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    sd 48[$r12] = $r22
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    sq 32[$r12] = $r20r21
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    sq 16[$r12] = $r18r19
; CHECK-NEXT:    copyd $r18 = $r2
; CHECK-NEXT:    copyd $r19 = $r1
; CHECK-NEXT:    copyd $r20 = $r0
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    srad $r0 = $r19, 32
; CHECK-NEXT:    copyd $r1 = $r18
; CHECK-NEXT:    call __umodsi3
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    copyd $r0 = $r19
; CHECK-NEXT:    copyd $r1 = $r18
; CHECK-NEXT:    copyd $r21 = $r0
; CHECK-NEXT:    call __umodsi3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    srad $r0 = $r20, 32
; CHECK-NEXT:    copyd $r1 = $r18
; CHECK-NEXT:    copyd $r19 = $r0
; CHECK-NEXT:    call __umodsi3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    copyd $r0 = $r20
; CHECK-NEXT:    copyd $r1 = $r18
; CHECK-NEXT:    copyd $r22 = $r0
; CHECK-NEXT:    call __umodsi3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    insf $r0 = $r22, 63, 32
; CHECK-NEXT:    insf $r19 = $r21, 63, 32
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    lq $r18r19 = 16[$r12]
; CHECK-NEXT:    copyd $r1 = $r19
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    lq $r20r21 = 32[$r12]
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    ld $r22 = 48[$r12]
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    ld $r16 = 56[$r12]
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 64
; CHECK-NEXT:    ;; # (end cycle 9)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %v0 = insertelement <4 x i32> undef, i32 %b, i32 0
  %splat = shufflevector <4 x i32> %v0, <4 x i32> undef, <4 x i32> zeroinitializer
  %div = urem <4 x i32> %a, %splat
  ret <4 x i32> %div
}

define <4 x i32> @urem_sv(<4 x i32> %a, i32 %b) {
; CHECK-LABEL: urem_sv:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addd $r12 = $r12, -64
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 56[$r12] = $r16
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    sd 48[$r12] = $r22
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    sq 32[$r12] = $r20r21
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    sq 16[$r12] = $r18r19
; CHECK-NEXT:    copyd $r18 = $r2
; CHECK-NEXT:    copyd $r19 = $r1
; CHECK-NEXT:    copyd $r20 = $r0
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    copyd $r0 = $r18
; CHECK-NEXT:    srad $r1 = $r19, 32
; CHECK-NEXT:    call __umodsi3
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    copyd $r0 = $r18
; CHECK-NEXT:    copyd $r1 = $r19
; CHECK-NEXT:    copyd $r21 = $r0
; CHECK-NEXT:    call __umodsi3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    copyd $r0 = $r18
; CHECK-NEXT:    srad $r1 = $r20, 32
; CHECK-NEXT:    copyd $r19 = $r0
; CHECK-NEXT:    call __umodsi3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    copyd $r0 = $r18
; CHECK-NEXT:    copyd $r1 = $r20
; CHECK-NEXT:    copyd $r22 = $r0
; CHECK-NEXT:    call __umodsi3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    insf $r0 = $r22, 63, 32
; CHECK-NEXT:    insf $r19 = $r21, 63, 32
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    lq $r18r19 = 16[$r12]
; CHECK-NEXT:    copyd $r1 = $r19
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    lq $r20r21 = 32[$r12]
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    ld $r22 = 48[$r12]
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    ld $r16 = 56[$r12]
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 64
; CHECK-NEXT:    ;; # (end cycle 9)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %v0 = insertelement <4 x i32> undef, i32 %b, i32 0
  %splat = shufflevector <4 x i32> %v0, <4 x i32> undef, <4 x i32> zeroinitializer
  %div = urem <4 x i32> %splat, %a
  ret <4 x i32> %div
}

define <4 x i32> @urem_ss(i32 %a, i32 %b) {
; CHECK-LABEL: urem_ss:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addd $r12 = $r12, -32
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 24[$r12] = $r16
; CHECK-NEXT:    copyd $r0 = $r1
; CHECK-NEXT:    copyd $r1 = $r0
; CHECK-NEXT:    call __umodsi3
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    insf $r0 = $r0, 63, 32
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    copyd $r1 = $r0
; CHECK-NEXT:    ld $r16 = 24[$r12]
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 32
; CHECK-NEXT:    ;; # (end cycle 6)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %va = insertelement <4 x i32> undef, i32 %b, i32 0
  %vb = insertelement <4 x i32> undef, i32 %a, i32 0
  %splata = shufflevector <4 x i32> %va, <4 x i32> undef, <4 x i32> zeroinitializer
  %splatb = shufflevector <4 x i32> %vb, <4 x i32> undef, <4 x i32> zeroinitializer
  %div = urem <4 x i32> %splata, %splatb
  ret <4 x i32> %div
}
