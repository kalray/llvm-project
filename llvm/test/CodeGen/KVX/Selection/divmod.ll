; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mcpu=kv3-1 -o - %s -O2 | FileCheck %s
; RUN: llc -mcpu=kv3-2 -o - %s -O2 | FileCheck %s
; RUN: clang -O2 -march=kv3-1 -c -o /dev/null %s
; RUN: clang -O2 -march=kv3-2 -c -o /dev/null %s

target triple = "kvx-kalray-cos"

define void @divmodsi4(i32 %x, i32 %y, i32* nocapture %P) nounwind ssp {
; CHECK-LABEL: divmodsi4:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    addd $r12 = $r12, -32
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 24[$r12] = $r16
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    sd 16[$r12] = $r18
; CHECK-NEXT:    addd $r2 = $r12, 12
; CHECK-NEXT:    copyd $r18 = $r2
; CHECK-NEXT:    call __divmodsi4
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    sw 0[$r18] = $r0
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    lwz $r0 = 12[$r12]
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    sw 4[$r18] = $r0
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    ld $r18 = 16[$r12]
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    ld $r16 = 24[$r12]
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 32
; CHECK-NEXT:    ;; # (end cycle 10)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %div = sdiv i32 %x, %y
  store i32 %div, i32* %P, align 4
  %rem = srem i32 %x, %y
  %arrayidx6 = getelementptr inbounds i32, i32* %P, i32 1
  store i32 %rem, i32* %arrayidx6, align 4
  ret void
}

define void @udivmodsi4(i32 %x, i32 %y, i32* nocapture %P) nounwind ssp {
; CHECK-LABEL: udivmodsi4:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    addd $r12 = $r12, -32
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 24[$r12] = $r16
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    sd 16[$r12] = $r18
; CHECK-NEXT:    addd $r2 = $r12, 12
; CHECK-NEXT:    copyd $r18 = $r2
; CHECK-NEXT:    call __udivmodsi4
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    sw 0[$r18] = $r0
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    lwz $r0 = 12[$r12]
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    sw 4[$r18] = $r0
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    ld $r18 = 16[$r12]
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    ld $r16 = 24[$r12]
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 32
; CHECK-NEXT:    ;; # (end cycle 10)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %div = udiv i32 %x, %y
  store i32 %div, i32* %P, align 4
  %rem = urem i32 %x, %y
  %arrayidx6 = getelementptr inbounds i32, i32* %P, i32 1
  store i32 %rem, i32* %arrayidx6, align 4
  ret void
}

define void @divmoddi4(i64 %x, i64 %y, i64* nocapture %P) nounwind ssp {
; CHECK-LABEL: divmoddi4:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    addd $r12 = $r12, -32
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 24[$r12] = $r16
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    sd 16[$r12] = $r18
; CHECK-NEXT:    addd $r2 = $r12, 8
; CHECK-NEXT:    copyd $r18 = $r2
; CHECK-NEXT:    call __udivmoddi4
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    sd 0[$r18] = $r0
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    ld $r0 = 8[$r12]
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    sd 8[$r18] = $r0
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    ld $r18 = 16[$r12]
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    ld $r16 = 24[$r12]
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 32
; CHECK-NEXT:    ;; # (end cycle 10)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %div = sdiv i64 %x, %y
  store i64 %div, i64* %P, align 4
  %rem = srem i64 %x, %y
  %arrayidx6 = getelementptr inbounds i64, i64* %P, i64 1
  store i64 %rem, i64* %arrayidx6, align 4
  ret void
}

define void @udivmoddi4(i64 %x, i64 %y, i64* nocapture %P) nounwind ssp {
; CHECK-LABEL: udivmoddi4:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    addd $r12 = $r12, -32
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 24[$r12] = $r16
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    sd 16[$r12] = $r20
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    sq 0[$r12] = $r18r19
; CHECK-NEXT:    copyd $r18 = $r2
; CHECK-NEXT:    copyd $r19 = $r1
; CHECK-NEXT:    copyd $r20 = $r0
; CHECK-NEXT:    call __udivdi3
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    sd 0[$r18] = $r0
; CHECK-NEXT:    copyd $r0 = $r20
; CHECK-NEXT:    copyd $r1 = $r19
; CHECK-NEXT:    call __umoddi3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 8[$r18] = $r0
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    lq $r18r19 = 0[$r12]
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    ld $r20 = 16[$r12]
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    ld $r16 = 24[$r12]
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 32
; CHECK-NEXT:    ;; # (end cycle 8)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %div = udiv i64 %x, %y
  store i64 %div, i64* %P, align 4
  %rem = urem i64 %x, %y
  %arrayidx6 = getelementptr inbounds i64, i64* %P, i64 1
  store i64 %rem, i64* %arrayidx6, align 4
  ret void
}
