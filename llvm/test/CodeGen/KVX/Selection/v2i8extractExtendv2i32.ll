; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mcpu=kv3-1 -O2 -o - %s | FileCheck %s --check-prefix=CV1
; RUN: llc -mcpu=kv3-2 -O2 -o - %s | FileCheck %s --check-prefix=CV2
; RUN: clang -O2 -march=kv3-1 -c -o /dev/null %s
; RUN: clang -O2 -march=kv3-2 -c -o /dev/null %s

target triple = "kvx-kalray-cos"

define void @sbmm8_bug(ptr addrspace(1) %p) {
; CV1-LABEL: sbmm8_bug:
; CV1:       # %bb.0:
; CV1-NEXT:    ld $r1 = 0[$r0]
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    sbmm8 $r2 = $r1, 0x200000001
; CV1-NEXT:    sbmm8 $r3 = $r1, 0x800000004
; CV1-NEXT:    ;; # (end cycle 3)
; CV1-NEXT:    sbmm8 $r1 = $r1, 0x8000000040
; CV1-NEXT:    sbmm8 $r4 = $r1, 0x2000000010
; CV1-NEXT:    ;; # (end cycle 4)
; CV1-NEXT:    cbswp $r2 = $r2
; CV1-NEXT:    cbswp $r3 = $r3
; CV1-NEXT:    ;; # (end cycle 5)
; CV1-NEXT:    cbswp $r1 = $r1
; CV1-NEXT:    cbswp $r4 = $r4
; CV1-NEXT:    ;; # (end cycle 6)
; CV1-NEXT:    sbmm8 $r2 = $r2, 0x1001
; CV1-NEXT:    sbmm8 $r3 = $r3, 0x1001
; CV1-NEXT:    ;; # (end cycle 7)
; CV1-NEXT:    sbmm8 $r1 = $r1, 0x1001
; CV1-NEXT:    sbmm8 $r4 = $r4, 0x1001
; CV1-NEXT:    ;; # (end cycle 8)
; CV1-NEXT:    insf $r2 = $r3, 31, 16
; CV1-NEXT:    insf $r4 = $r1, 31, 16
; CV1-NEXT:    ;; # (end cycle 9)
; CV1-NEXT:    insf $r2 = $r4, 63, 32
; CV1-NEXT:    ;; # (end cycle 10)
; CV1-NEXT:    sd 0[$r0] = $r2
; CV1-NEXT:    ret
; CV1-NEXT:    ;; # (end cycle 11)
;
; CV2-LABEL: sbmm8_bug:
; CV2:       # %bb.0:
; CV2-NEXT:    ld $r1 = 0[$r0]
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    sbmm8 $r2 = $r1, 0x200000001
; CV2-NEXT:    sbmm8 $r3 = $r1, 0x800000004
; CV2-NEXT:    sbmm8 $r4 = $r1, 0x2000000010
; CV2-NEXT:    ;; # (end cycle 3)
; CV2-NEXT:    sbmm8 $r1 = $r1, 0x8000000040
; CV2-NEXT:    cbswp $r2 = $r2
; CV2-NEXT:    cbswp $r3 = $r3
; CV2-NEXT:    ;; # (end cycle 4)
; CV2-NEXT:    cbswp $r1 = $r1
; CV2-NEXT:    sbmm8 $r2 = $r2, 0x1001
; CV2-NEXT:    sbmm8 $r3 = $r3, 0x1001
; CV2-NEXT:    cbswp $r4 = $r4
; CV2-NEXT:    ;; # (end cycle 5)
; CV2-NEXT:    sbmm8 $r1 = $r1, 0x1001
; CV2-NEXT:    insf $r2 = $r3, 31, 16
; CV2-NEXT:    sbmm8 $r4 = $r4, 0x1001
; CV2-NEXT:    ;; # (end cycle 6)
; CV2-NEXT:    insf $r4 = $r1, 31, 16
; CV2-NEXT:    ;; # (end cycle 7)
; CV2-NEXT:    insf $r2 = $r4, 63, 32
; CV2-NEXT:    ;; # (end cycle 8)
; CV2-NEXT:    sd 0[$r0] = $r2
; CV2-NEXT:    ret
; CV2-NEXT:    ;; # (end cycle 9)
  %v8 = load <8 x i8>, ptr addrspace(1) %p
  %shv0 = shufflevector <8 x i8> %v8, <8 x i8> undef, <2 x i32> <i32 0, i32 1>
  %pop_0 = tail call <2 x i8> @llvm.ctpop.v2i8(<2 x i8> %shv0)
  %shv1 = shufflevector <8 x i8> %v8, <8 x i8> undef, <2 x i32> <i32 2, i32 3>
  %pop_1 = tail call <2 x i8> @llvm.ctpop.v2i8(<2 x i8> %shv1)
  %shv2 = shufflevector <2 x i8> %pop_0, <2 x i8> %pop_1, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %shv3 = shufflevector <8 x i8> %v8, <8 x i8> undef, <2 x i32> <i32 4, i32 5>
  %pop_2 = tail call <2 x i8> @llvm.ctpop.v2i8(<2 x i8> %shv3)
  %shv4 = shufflevector <8 x i8> %v8, <8 x i8> undef, <2 x i32> <i32 6, i32 7>
  %pop_3 = tail call <2 x i8> @llvm.ctpop.v2i8(<2 x i8> %shv4)
  %shv5 = shufflevector <2 x i8> %pop_2, <2 x i8> %pop_3, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %shv6 = shufflevector <4 x i8> %shv2, <4 x i8> %shv5, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
  store <8 x i8> %shv6, ptr addrspace(1) %p
  ret void
}

declare <2 x i8> @llvm.ctpop.v2i8(<2 x i8>)
