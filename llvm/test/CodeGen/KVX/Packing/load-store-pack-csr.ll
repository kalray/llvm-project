; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -o - %s -O2 -disable-kvx-loadstore-packing=false | FileCheck %s --check-prefixes=CHECK
; RUN: llc -mcpu=kv3-2 -o - %s -O2 -disable-kvx-loadstore-packing=false | FileCheck %s --check-prefixes=CHECK
; RUN: clang -O2 -mllvm -disable-kvx-loadstore-packing=false -c -o /dev/null %s
; RUN: clang -O2 -march=kv3-2 -mllvm -disable-kvx-loadstore-packing=false -c -o /dev/null %s

target triple = "kvx-kalray-cos"

@v = common global [50 x i64] zeroinitializer, align 8

define i64 @f_1_nopack(){
; CHECK-LABEL: f_1_nopack:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    make $r0 = v
; CHECK-NEXT:    addd $r12 = $r12, -32
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 24[$r12] = $r16
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    sd 16[$r12] = $r18
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    ld $r18 = 0[$r0]
; CHECK-NEXT:    call foo
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    copyd $r0 = $r18
; CHECK-NEXT:    ld $r18 = 16[$r12]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    ld $r16 = 24[$r12]
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 32
; CHECK-NEXT:    ;; # (end cycle 6)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = load i64, ptr getelementptr inbounds ([50 x i64], ptr @v, i64 0, i64 0), align 8
  tail call void bitcast (void (...)* @foo to void ()*)() #2
  ret i64 %0
}

declare void @foo(...) #1

define i64 @f_2_pairpack(){
; CHECK-LABEL: f_2_pairpack:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    make $r0 = v
; CHECK-NEXT:    addd $r12 = $r12, -32
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 24[$r12] = $r16
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    sq 8[$r12] = $r18r19
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    lq $r18r19 = 0[$r0]
; CHECK-NEXT:    call foo
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    lq $r18r19 = 8[$r12]
; CHECK-NEXT:    addd $r0 = $r19, $r18
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    ld $r16 = 24[$r12]
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 32
; CHECK-NEXT:    ;; # (end cycle 6)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = load i64, ptr getelementptr inbounds ([50 x i64], ptr @v, i64 0, i64 0), align 8
  %1 = load i64, ptr getelementptr inbounds ([50 x i64], ptr @v, i64 0, i64 1), align 8
  tail call void bitcast (void (...)* @foo to void ()*)() #2
  %add = add nsw i64 %1, %0
  ret i64 %add
}

define i64 @f_3_pairpack(){
; CHECK-LABEL: f_3_pairpack:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    make $r0 = v
; CHECK-NEXT:    addd $r12 = $r12, -32
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 24[$r12] = $r16
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    sd 16[$r12] = $r20
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    sq 0[$r12] = $r18r19
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    lq $r18r19 = 0[$r0]
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    ld $r20 = 16[$r0]
; CHECK-NEXT:    call foo
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    lq $r18r19 = 0[$r12]
; CHECK-NEXT:    addd $r0 = $r19, $r18
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    addd $r0 = $r0, $r20
; CHECK-NEXT:    ld $r20 = 16[$r12]
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    ld $r16 = 24[$r12]
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 32
; CHECK-NEXT:    ;; # (end cycle 7)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = load i64, ptr getelementptr inbounds ([50 x i64], ptr @v, i64 0, i64 0), align 8
  %1 = load i64, ptr getelementptr inbounds ([50 x i64], ptr @v, i64 0, i64 1), align 8
  %2 = load i64, ptr getelementptr inbounds ([50 x i64], ptr @v, i64 0, i64 2), align 8
  tail call void bitcast (void (...)* @foo to void ()*)() #2
  %add = add nsw i64 %1, %0
  %add1 = add nsw i64 %add, %2
  ret i64 %add1
}

define i64 @f_4_quadpack(){
; CHECK-LABEL: f_4_quadpack:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    make $r0 = v
; CHECK-NEXT:    addd $r12 = $r12, -64
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 56[$r12] = $r16
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    so 24[$r12] = $r20r21r22r23
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    lo $r20r21r22r23 = 0[$r0]
; CHECK-NEXT:    call foo
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    addd $r0 = $r21, $r20
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    addd $r0 = $r0, $r22
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    lo $r20r21r22r23 = 24[$r12]
; CHECK-NEXT:    addd $r0 = $r0, $r23
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    ld $r16 = 56[$r12]
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 64
; CHECK-NEXT:    ;; # (end cycle 8)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = load i64, ptr getelementptr inbounds ([50 x i64], ptr @v, i64 0, i64 0), align 8
  %1 = load i64, ptr getelementptr inbounds ([50 x i64], ptr @v, i64 0, i64 1), align 8
  %2 = load i64, ptr getelementptr inbounds ([50 x i64], ptr @v, i64 0, i64 2), align 8
  %3 = load i64, ptr getelementptr inbounds ([50 x i64], ptr @v, i64 0, i64 3), align 8
  tail call void bitcast (void (...)* @foo to void ()*)() #2
  %add = add nsw i64 %1, %0
  %add1 = add nsw i64 %add, %2
  %add2 = add nsw i64 %add1, %3
  ret i64 %add2
}

define i64 @f_5_quadpack(){
; CHECK-LABEL: f_5_quadpack:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    make $r0 = v
; CHECK-NEXT:    addd $r12 = $r12, -64
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 56[$r12] = $r16
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    so 24[$r12] = $r20r21r22r23
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    sd 16[$r12] = $r18
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    lo $r20r21r22r23 = 0[$r0]
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    ld $r18 = 32[$r0]
; CHECK-NEXT:    call foo
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    addd $r0 = $r21, $r20
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    addd $r0 = $r0, $r22
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    addd $r0 = $r0, $r23
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    addd $r0 = $r0, $r18
; CHECK-NEXT:    ld $r18 = 16[$r12]
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    lo $r20r21r22r23 = 24[$r12]
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    ld $r16 = 56[$r12]
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 64
; CHECK-NEXT:    ;; # (end cycle 10)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = load i64, ptr getelementptr inbounds ([50 x i64], ptr @v, i64 0, i64 0), align 8
  %1 = load i64, ptr getelementptr inbounds ([50 x i64], ptr @v, i64 0, i64 1), align 8
  %2 = load i64, ptr getelementptr inbounds ([50 x i64], ptr @v, i64 0, i64 2), align 8
  %3 = load i64, ptr getelementptr inbounds ([50 x i64], ptr @v, i64 0, i64 3), align 8
  %4 = load i64, ptr getelementptr inbounds ([50 x i64], ptr @v, i64 0, i64 4), align 8
  tail call void bitcast (void (...)* @foo to void ()*)() #2
  %add = add nsw i64 %1, %0
  %add1 = add nsw i64 %add, %2
  %add2 = add nsw i64 %add1, %3
  %add3 = add nsw i64 %add2, %4
  ret i64 %add3
}

define i64 @f_6_1quad1pairpack(){
; CHECK-LABEL: f_6_1quad1pairpack:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    make $r0 = v
; CHECK-NEXT:    addd $r12 = $r12, -64
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 56[$r12] = $r16
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    so 24[$r12] = $r20r21r22r23
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    sq 8[$r12] = $r18r19
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    lo $r20r21r22r23 = 0[$r0]
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    lq $r18r19 = 32[$r0]
; CHECK-NEXT:    call foo
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    addd $r0 = $r21, $r20
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    addd $r0 = $r0, $r22
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    addd $r0 = $r0, $r23
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    addd $r0 = $r0, $r18
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    lq $r18r19 = 8[$r12]
; CHECK-NEXT:    addd $r0 = $r0, $r19
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    lo $r20r21r22r23 = 24[$r12]
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    ld $r16 = 56[$r12]
; CHECK-NEXT:    ;; # (end cycle 6)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 64
; CHECK-NEXT:    ;; # (end cycle 11)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = load i64, ptr getelementptr inbounds ([50 x i64], ptr @v, i64 0, i64 0), align 8
  %1 = load i64, ptr getelementptr inbounds ([50 x i64], ptr @v, i64 0, i64 1), align 8
  %2 = load i64, ptr getelementptr inbounds ([50 x i64], ptr @v, i64 0, i64 2), align 8
  %3 = load i64, ptr getelementptr inbounds ([50 x i64], ptr @v, i64 0, i64 3), align 8
  %4 = load i64, ptr getelementptr inbounds ([50 x i64], ptr @v, i64 0, i64 4), align 8
  %5 = load i64, ptr getelementptr inbounds ([50 x i64], ptr @v, i64 0, i64 5), align 8
  tail call void bitcast (void (...)* @foo to void ()*)() #2
  %add = add nsw i64 %1, %0
  %add1 = add nsw i64 %add, %2
  %add2 = add nsw i64 %add1, %3
  %add3 = add nsw i64 %add2, %4
  %add4 = add nsw i64 %add3, %5
  ret i64 %add4
}

define i64 @f_14_3quad1pairpack(){
; CHECK-LABEL: f_14_3quad1pairpack:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    make $r0 = v
; CHECK-NEXT:    addd $r12 = $r12, -128
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 120[$r12] = $r16
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    so 88[$r12] = $r28r29r30r31
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    so 56[$r12] = $r24r25r26r27
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    so 24[$r12] = $r20r21r22r23
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    sq 8[$r12] = $r18r19
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    lo $r20r21r22r23 = 0[$r0]
; CHECK-NEXT:    ;; # (end cycle 6)
; CHECK-NEXT:    lo $r24r25r26r27 = 32[$r0]
; CHECK-NEXT:    ;; # (end cycle 7)
; CHECK-NEXT:    lo $r28r29r30r31 = 64[$r0]
; CHECK-NEXT:    ;; # (end cycle 8)
; CHECK-NEXT:    lq $r18r19 = 96[$r0]
; CHECK-NEXT:    call foo
; CHECK-NEXT:    ;; # (end cycle 9)
; CHECK-NEXT:    addd $r0 = $r21, $r20
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    addd $r0 = $r0, $r22
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    addd $r0 = $r0, $r23
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    addd $r0 = $r0, $r24
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    addd $r0 = $r0, $r25
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    addd $r0 = $r0, $r26
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    addd $r0 = $r0, $r27
; CHECK-NEXT:    ;; # (end cycle 6)
; CHECK-NEXT:    addd $r0 = $r0, $r28
; CHECK-NEXT:    ;; # (end cycle 7)
; CHECK-NEXT:    addd $r0 = $r0, $r29
; CHECK-NEXT:    ;; # (end cycle 8)
; CHECK-NEXT:    addd $r0 = $r0, $r30
; CHECK-NEXT:    ;; # (end cycle 9)
; CHECK-NEXT:    addd $r0 = $r0, $r31
; CHECK-NEXT:    ;; # (end cycle 10)
; CHECK-NEXT:    addd $r0 = $r0, $r18
; CHECK-NEXT:    ;; # (end cycle 11)
; CHECK-NEXT:    lq $r18r19 = 8[$r12]
; CHECK-NEXT:    addd $r0 = $r0, $r19
; CHECK-NEXT:    ;; # (end cycle 12)
; CHECK-NEXT:    lo $r20r21r22r23 = 24[$r12]
; CHECK-NEXT:    ;; # (end cycle 13)
; CHECK-NEXT:    lo $r24r25r26r27 = 56[$r12]
; CHECK-NEXT:    ;; # (end cycle 14)
; CHECK-NEXT:    lo $r28r29r30r31 = 88[$r12]
; CHECK-NEXT:    ;; # (end cycle 15)
; CHECK-NEXT:    ld $r16 = 120[$r12]
; CHECK-NEXT:    ;; # (end cycle 16)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 128
; CHECK-NEXT:    ;; # (end cycle 21)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = load i64, ptr getelementptr inbounds ([50 x i64], ptr @v, i64 0, i64 0), align 8
  %1 = load i64, ptr getelementptr inbounds ([50 x i64], ptr @v, i64 0, i64 1), align 8
  %2 = load i64, ptr getelementptr inbounds ([50 x i64], ptr @v, i64 0, i64 2), align 8
  %3 = load i64, ptr getelementptr inbounds ([50 x i64], ptr @v, i64 0, i64 3), align 8
  %4 = load i64, ptr getelementptr inbounds ([50 x i64], ptr @v, i64 0, i64 4), align 8
  %5 = load i64, ptr getelementptr inbounds ([50 x i64], ptr @v, i64 0, i64 5), align 8
  %6 = load i64, ptr getelementptr inbounds ([50 x i64], ptr @v, i64 0, i64 6), align 8
  %7 = load i64, ptr getelementptr inbounds ([50 x i64], ptr @v, i64 0, i64 7), align 8
  %8 = load i64, ptr getelementptr inbounds ([50 x i64], ptr @v, i64 0, i64 8), align 8
  %9 = load i64, ptr getelementptr inbounds ([50 x i64], ptr @v, i64 0, i64 9), align 8
  %10 = load i64, ptr getelementptr inbounds ([50 x i64], ptr @v, i64 0, i64 10), align 8
  %11 = load i64, ptr getelementptr inbounds ([50 x i64], ptr @v, i64 0, i64 11), align 8
  %12 = load i64, ptr getelementptr inbounds ([50 x i64], ptr @v, i64 0, i64 12), align 8
  %13 = load i64, ptr getelementptr inbounds ([50 x i64], ptr @v, i64 0, i64 13), align 8
  tail call void bitcast (void (...)* @foo to void ()*)() #2
  %add = add nsw i64 %1, %0
  %add1 = add nsw i64 %add, %2
  %add2 = add nsw i64 %add1, %3
  %add3 = add nsw i64 %add2, %4
  %add4 = add nsw i64 %add3, %5
  %add5 = add nsw i64 %add4, %6
  %add6 = add nsw i64 %add5, %7
  %add7 = add nsw i64 %add6, %8
  %add8 = add nsw i64 %add7, %9
  %add9 = add nsw i64 %add8, %10
  %add10 = add nsw i64 %add9, %11
  %add11 = add nsw i64 %add10, %12
  %add12 = add nsw i64 %add11, %13
  ret i64 %add12
}

define i64 @f_15_3quad1pairpack(){
; CHECK-LABEL: f_15_3quad1pairpack:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    make $r0 = v
; CHECK-NEXT:    addd $r12 = $r12, -128
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 120[$r12] = $r16
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    so 88[$r12] = $r28r29r30r31
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    so 56[$r12] = $r24r25r26r27
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    so 24[$r12] = $r20r21r22r23
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    sq 8[$r12] = $r18r19
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    lo $r20r21r22r23 = 0[$r0]
; CHECK-NEXT:    ;; # (end cycle 6)
; CHECK-NEXT:    lo $r24r25r26r27 = 32[$r0]
; CHECK-NEXT:    ;; # (end cycle 7)
; CHECK-NEXT:    lo $r28r29r30r31 = 64[$r0]
; CHECK-NEXT:    ;; # (end cycle 8)
; CHECK-NEXT:    lq $r18r19 = 96[$r0]
; CHECK-NEXT:    ;; # (end cycle 9)
; CHECK-NEXT:    ld $r0 = 112[$r0]
; CHECK-NEXT:    ;; # (end cycle 10)
; CHECK-NEXT:    sd 0[$r12] = $r0
; CHECK-NEXT:    call foo
; CHECK-NEXT:    ;; # (end cycle 12)
; CHECK-NEXT:    addd $r0 = $r21, $r20
; CHECK-NEXT:    ld $r1 = 0[$r12]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    addd $r0 = $r0, $r22
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    addd $r0 = $r0, $r23
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    addd $r0 = $r0, $r24
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    addd $r0 = $r0, $r25
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    addd $r0 = $r0, $r26
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    addd $r0 = $r0, $r27
; CHECK-NEXT:    ;; # (end cycle 6)
; CHECK-NEXT:    addd $r0 = $r0, $r28
; CHECK-NEXT:    ;; # (end cycle 7)
; CHECK-NEXT:    addd $r0 = $r0, $r29
; CHECK-NEXT:    ;; # (end cycle 8)
; CHECK-NEXT:    addd $r0 = $r0, $r30
; CHECK-NEXT:    ;; # (end cycle 9)
; CHECK-NEXT:    addd $r0 = $r0, $r31
; CHECK-NEXT:    ;; # (end cycle 10)
; CHECK-NEXT:    addd $r0 = $r0, $r18
; CHECK-NEXT:    ;; # (end cycle 11)
; CHECK-NEXT:    lq $r18r19 = 8[$r12]
; CHECK-NEXT:    addd $r0 = $r0, $r19
; CHECK-NEXT:    ;; # (end cycle 12)
; CHECK-NEXT:    lo $r20r21r22r23 = 24[$r12]
; CHECK-NEXT:    addd $r0 = $r0, $r1
; CHECK-NEXT:    ;; # (end cycle 13)
; CHECK-NEXT:    lo $r24r25r26r27 = 56[$r12]
; CHECK-NEXT:    ;; # (end cycle 14)
; CHECK-NEXT:    lo $r28r29r30r31 = 88[$r12]
; CHECK-NEXT:    ;; # (end cycle 15)
; CHECK-NEXT:    ld $r16 = 120[$r12]
; CHECK-NEXT:    ;; # (end cycle 16)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 128
; CHECK-NEXT:    ;; # (end cycle 21)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = load i64, ptr getelementptr inbounds ([50 x i64], ptr @v, i64 0, i64 0), align 8
  %1 = load i64, ptr getelementptr inbounds ([50 x i64], ptr @v, i64 0, i64 1), align 8
  %2 = load i64, ptr getelementptr inbounds ([50 x i64], ptr @v, i64 0, i64 2), align 8
  %3 = load i64, ptr getelementptr inbounds ([50 x i64], ptr @v, i64 0, i64 3), align 8
  %4 = load i64, ptr getelementptr inbounds ([50 x i64], ptr @v, i64 0, i64 4), align 8
  %5 = load i64, ptr getelementptr inbounds ([50 x i64], ptr @v, i64 0, i64 5), align 8
  %6 = load i64, ptr getelementptr inbounds ([50 x i64], ptr @v, i64 0, i64 6), align 8
  %7 = load i64, ptr getelementptr inbounds ([50 x i64], ptr @v, i64 0, i64 7), align 8
  %8 = load i64, ptr getelementptr inbounds ([50 x i64], ptr @v, i64 0, i64 8), align 8
  %9 = load i64, ptr getelementptr inbounds ([50 x i64], ptr @v, i64 0, i64 9), align 8
  %10 = load i64, ptr getelementptr inbounds ([50 x i64], ptr @v, i64 0, i64 10), align 8
  %11 = load i64, ptr getelementptr inbounds ([50 x i64], ptr @v, i64 0, i64 11), align 8
  %12 = load i64, ptr getelementptr inbounds ([50 x i64], ptr @v, i64 0, i64 12), align 8
  %13 = load i64, ptr getelementptr inbounds ([50 x i64], ptr @v, i64 0, i64 13), align 8
  %14 = load i64, ptr getelementptr inbounds ([50 x i64], ptr @v, i64 0, i64 14), align 8
  tail call void bitcast (void (...)* @foo to void ()*)() #2
  %add = add nsw i64 %1, %0
  %add1 = add nsw i64 %add, %2
  %add2 = add nsw i64 %add1, %3
  %add3 = add nsw i64 %add2, %4
  %add4 = add nsw i64 %add3, %5
  %add5 = add nsw i64 %add4, %6
  %add6 = add nsw i64 %add5, %7
  %add7 = add nsw i64 %add6, %8
  %add8 = add nsw i64 %add7, %9
  %add9 = add nsw i64 %add8, %10
  %add10 = add nsw i64 %add9, %11
  %add11 = add nsw i64 %add10, %12
  %add12 = add nsw i64 %add11, %13
  %add13 = add nsw i64 %add12, %14
  ret i64 %add13
}

