; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -O2 -o - %s | FileCheck %s --check-prefixes=KV3_1
; RUN: llc -mcpu=kv3-2 -O2 -o - %s | FileCheck %s --check-prefixes=KV3_2
; RUN: clang -O2 -c -o /dev/null %s
; RUN: clang -O2 -march=kv3-2 -c -o /dev/null %s

target triple = "kvx-kalray-cos"

%struct.node = type { i16, double, [3 x double], i32, i32 }
%struct.bnode = type { i16, double, [3 x double], i32, i32, [3 x double], [3 x double], [3 x double], double, %struct.bnode*, %struct.bnode* }
%struct.hgstruct = type { %struct.bnode*, [3 x double], double, [3 x double] }
%struct.tree = type { [3 x double], double, %struct.node*, [64 x %struct.bnode*], [64 x %struct.bnode*] }
%struct.cnode = type { i16, double, [3 x double], i32, i32, [8 x %struct.node*], %struct.cnode* }

@.str = private unnamed_addr constant [27 x i8] c"nbody = %d, numnodes = %d\0A\00"
@nbody = common global i32 0
@NumNodes = common global i32 0
@.str.2 = private unnamed_addr constant [20 x i8] c"Bodies per %d = %d\0A\00"
@.str.3 = private unnamed_addr constant [22 x i8] c"Assertion Failure #%d\00"
@cp_free_list = global %struct.node* null
@bp_free_list = global %struct.bnode* null
@.str.5 = private unnamed_addr constant [24 x i8] c"%2d BODY@%x %f, %f, %f\0A\00"
@.str.6 = private unnamed_addr constant [24 x i8] c"%2d CELL@%x %f, %f, %f\0A\00"
@.str.7 = private unnamed_addr constant [15 x i8] c"%2d NULL TREE\0A\00"
@root = common global %struct.node* null
@rmin = common global [3 x double] zeroinitializer
@xxxrsize = common global double 0.000000e+00
@arg1 = common global i32 0
@str = private unnamed_addr constant [16 x i8] c"bodies created \00"

declare void @llvm.lifetime.start.p0i8(i64 immarg, i8* nocapture)

declare i32 @dealwithargs(...)

declare noundef i32 @printf(i8* nocapture noundef readonly, ...)

declare void @llvm.lifetime.end.p0i8(i64 immarg, i8* nocapture)

declare void @srand(i32)

declare noalias noundef i8* @malloc(i64)

declare void @llvm.memcpy.p0i8.p0i8.i64(i8* noalias nocapture writeonly, i8* noalias nocapture readonly, i64, i1 immarg)

declare void @abort()

declare double @llvm.sqrt.f64(double)

declare double @my_rand(...)

declare double @xrand(...)

declare double @llvm.pow.f64(double, double)

declare i32 @__fpclassifyd(double)

declare double @llvm.fabs.f64(double)

declare void @walksub(%struct.hgstruct* sret(%struct.hgstruct) align 8, %struct.node*, double, double, %struct.hgstruct*, i32)

define void @expandbox(%struct.bnode* nocapture readonly %0, %struct.tree* nocapture %1, i32 %2, i32 %3) {
; KV3_1-LABEL: expandbox:
; KV3_1:       # %bb.0:
; KV3_1-NEXT:    addd $r12 = $r12, -128
; KV3_1-NEXT:    get $r16 = $ra
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    sd 120[$r12] = $r16
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    so 88[$r12] = $r28r29r30r31
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    so 56[$r12] = $r24r25r26r27
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    so 24[$r12] = $r20r21r22r23
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    sq 8[$r12] = $r18r19
; KV3_1-NEXT:    copyd $r18 = $r1
; KV3_1-NEXT:    copyd $r19 = $r0
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    lq $r22r23 = 16[$r19]
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    ld $r26 = 0[$r18]
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    ld $r20 = 24[$r18]
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    ld $r24 = 32[$r19]
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    fsbfd $r0 = $r26, $r22
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    copyd $r1 = $r20
; KV3_1-NEXT:    call __divdf3
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    lq $r30r31 = 8[$r18]
; KV3_1-NEXT:    copyd $r1 = $r20
; KV3_1-NEXT:    copyd $r22 = $r0
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    fsbfd $r0 = $r30, $r23
; KV3_1-NEXT:    call __divdf3
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    fsbfd $r0 = $r31, $r24
; KV3_1-NEXT:    copyd $r1 = $r20
; KV3_1-NEXT:    copyd $r21 = $r0
; KV3_1-NEXT:    call __divdf3
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    make $r23 = 0x0
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    fcompd.ult $r1 = $r0, $r23
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    cb.wnez $r1 ? .LBB0_7
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:  # %bb.1:
; KV3_1-NEXT:    make $r1 = 0x3ff0000000000000
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    fcompd.uge $r0 = $r0, $r1
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    cb.wnez $r0 ? .LBB0_7
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:  # %bb.2:
; KV3_1-NEXT:    make $r0 = 0x0
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    fcompd.ult $r0 = $r22, $r0
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    cb.wnez $r0 ? .LBB0_7
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:  # %bb.3:
; KV3_1-NEXT:    make $r0 = 0x3ff0000000000000
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    fcompd.uge $r0 = $r22, $r0
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    cb.wnez $r0 ? .LBB0_7
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:  # %bb.4:
; KV3_1-NEXT:    make $r0 = 0x4000000000000000
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    fcompd.ult $r0 = $r0, $r22
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    cb.wnez $r0 ? .LBB0_7
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:  # %bb.5:
; KV3_1-NEXT:    make $r0 = 0x0
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    fcompd.ult $r0 = $r21, $r0
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    cb.wnez $r0 ? .LBB0_7
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:  # %bb.6:
; KV3_1-NEXT:    make $r0 = 0x3ff0000000000000
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    fcompd.olt $r0 = $r21, $r0
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    cb.wnez $r0 ? .LBB0_25
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:  .LBB0_7:
; KV3_1-NEXT:    make $r3 = cp_free_list
; KV3_1-NEXT:    make $r27 = 0x3ff0000000000000
; KV3_1-NEXT:    make $r28 = 0
; KV3_1-NEXT:    goto .LBB0_9
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:  .LBB0_8: # in Loop: Header=BB0_9 Depth=1
; KV3_1-NEXT:    make $r0 = 0
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    cb.wnez $r0 ? .LBB0_25
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:  .LBB0_9: # =>This Inner Loop Header: Depth=1
; KV3_1-NEXT:    make $r0 = 0x408f400000000000
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    fcompd.uge $r0 = $r20, $r0
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    cb.wnez $r0 ? .LBB0_27
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:  # %bb.10: # in Loop: Header=BB0_9 Depth=1
; KV3_1-NEXT:    fmuld $r0 = $r20, 0x3fe0000000000000
; KV3_1-NEXT:    ld $r1 = 16[$r19]
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    faddd $r22 = $r0, $r26
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    copyd $r1 = $r0
; KV3_1-NEXT:    fcompd.olt $r2 = $r1, $r22
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    fadddp $r24r25 = $r0r1, $r30r31
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    cb.weqz $r2 ? .LBB0_12
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:  # %bb.11: # in Loop: Header=BB0_9 Depth=1
; KV3_1-NEXT:    fsbfd $r26 = $r20, $r26
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    sd 0[$r18] = $r26
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:  .LBB0_12: # in Loop: Header=BB0_9 Depth=1
; KV3_1-NEXT:    ld $r0 = 24[$r19]
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    fcompd.olt $r0 = $r0, $r24
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    cb.weqz $r0 ? .LBB0_14
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:  # %bb.13: # in Loop: Header=BB0_9 Depth=1
; KV3_1-NEXT:    fsbfd $r30 = $r20, $r30
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    sd 8[$r18] = $r30
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:  .LBB0_14: # in Loop: Header=BB0_9 Depth=1
; KV3_1-NEXT:    ld $r0 = 32[$r19]
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    fcompd.uge $r0 = $r0, $r25
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    cb.wnez $r0 ? .LBB0_16
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:  # %bb.15: # in Loop: Header=BB0_9 Depth=1
; KV3_1-NEXT:    fsbfd $r31 = $r20, $r31
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    sd 16[$r18] = $r31
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:  .LBB0_16: # in Loop: Header=BB0_9 Depth=1
; KV3_1-NEXT:    ld $r0 = 32[$r18]
; KV3_1-NEXT:    faddd $r20 = $r20, $r20
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    sd 24[$r18] = $r20
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    cb.deqz $r0 ? .LBB0_8
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:  # %bb.17: # in Loop: Header=BB0_9 Depth=1
; KV3_1-NEXT:    ld $r21 = 0[$r3]
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    cb.deqz $r21 ? .LBB0_19
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:  # %bb.18: # in Loop: Header=BB0_9 Depth=1
; KV3_1-NEXT:    ld $r0 = 112[$r21]
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    sd 0[$r3] = $r0
; KV3_1-NEXT:    goto .LBB0_20
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:  .LBB0_19: # in Loop: Header=BB0_9 Depth=1
; KV3_1-NEXT:    make $r0 = 120
; KV3_1-NEXT:    call malloc
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    copyd $r21 = $r0
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:  .LBB0_20: # in Loop: Header=BB0_9 Depth=1
; KV3_1-NEXT:    sw 40[$r21] = $r28
; KV3_1-NEXT:    copyd $r29 = $r28
; KV3_1-NEXT:    copyd $r30 = $r28
; KV3_1-NEXT:    copyd $r31 = $r28
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    copyd $r0 = $r28
; KV3_1-NEXT:    make $r1 = 2
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    sh 0[$r21] = $r1
; KV3_1-NEXT:    copyd $r1 = $r28
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    so 48[$r21] = $r28r29r30r31
; KV3_1-NEXT:    copyd $r2 = $r28
; KV3_1-NEXT:    copyd $r3 = $r28
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    so 80[$r21] = $r0r1r2r3
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    ld $r26 = 0[$r18]
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    ld $r20 = 24[$r18]
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    fsbfd $r0 = $r26, $r22
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    copyd $r1 = $r20
; KV3_1-NEXT:    call __divdf3
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    lq $r30r31 = 8[$r18]
; KV3_1-NEXT:    copyd $r22 = $r0
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    fsbfdp $r24r25 = $r30r31, $r24r25
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    copyd $r0 = $r25
; KV3_1-NEXT:    copyd $r1 = $r20
; KV3_1-NEXT:    call __divdf3
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    copyd $r0 = $r24
; KV3_1-NEXT:    copyd $r1 = $r20
; KV3_1-NEXT:    copyd $r25 = $r0
; KV3_1-NEXT:    call __divdf3
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    fcompd.olt $r0 = $r25, $r27
; KV3_1-NEXT:    fcompd.oge $r1 = $r25, $r23
; KV3_1-NEXT:    make $r2 = -1
; KV3_1-NEXT:    copyd $r24 = $r0
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    make $r0 = -1
; KV3_1-NEXT:    cmoved.even $r0 ? $r2 = 0
; KV3_1-NEXT:    fcompd.olt $r3 = $r24, $r27
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    cmoved.even $r3 ? $r0 = 0
; KV3_1-NEXT:    fcompd.oge $r3 = $r24, $r23
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    cmoved.even $r3 ? $r0 = 0
; KV3_1-NEXT:    cmoved.even $r1 ? $r2 = 0
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    insf $r0 = $r2, 15, 8
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    extfz $r1 = $r0, 15, 8
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    cb.even $r1 ? .LBB0_26
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:  # %bb.21: # in Loop: Header=BB0_9 Depth=1
; KV3_1-NEXT:    zxbd $r0 = $r0
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    cb.even $r0 ? .LBB0_26
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:  # %bb.22: # in Loop: Header=BB0_9 Depth=1
; KV3_1-NEXT:    fcompd.ult $r0 = $r22, $r23
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    cb.wnez $r0 ? .LBB0_26
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:  # %bb.23: # in Loop: Header=BB0_9 Depth=1
; KV3_1-NEXT:    fcompd.olt $r0 = $r22, $r27
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    cb.weqz $r0 ? .LBB0_26
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:  # %bb.24: # in Loop: Header=BB0_9 Depth=1
; KV3_1-NEXT:    fmuld $r0 = $r25, 0x41d0000000000000
; KV3_1-NEXT:    call floor
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    fixedd.rz $r25 = $r0, 0
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    fmuld $r0 = $r24, 0x41d0000000000000
; KV3_1-NEXT:    call floor
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    fixedd.rz $r24 = $r0, 0
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    fmuld $r0 = $r22, 0x41d0000000000000
; KV3_1-NEXT:    call floor
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    fixedd.rz $r0 = $r0, 0
; KV3_1-NEXT:    srlw $r1 = $r24, 28
; KV3_1-NEXT:    extfz $r2 = $r25, 29, 29
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    andw $r1 = $r1, 2
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    srlw $r0 = $r0, 27
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    andw $r0 = $r0, 4
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    orw $r0 = $r1, $r0
; KV3_1-NEXT:    ld $r1 = 32[$r18]
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    orw $r0 = $r0, $r2
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    addx8d $r0 = $r0, $r21
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    sd 48[$r0] = $r1
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    sd 32[$r18] = $r21
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    ld $r0 = 16[$r19]
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    lq $r24r25 = 24[$r19]
; KV3_1-NEXT:    copyd $r1 = $r20
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    fsbfd $r0 = $r26, $r0
; KV3_1-NEXT:    call __divdf3
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    fcompd.olt $r0 = $r0, $r27
; KV3_1-NEXT:    fcompd.oge $r1 = $r0, $r23
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    fsbfd $r0 = $r30, $r24
; KV3_1-NEXT:    copyd $r1 = $r20
; KV3_1-NEXT:    andw $r21 = $r1, $r0
; KV3_1-NEXT:    call __divdf3
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    fcompd.olt $r0 = $r0, $r27
; KV3_1-NEXT:    fcompd.oge $r1 = $r0, $r23
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    andw $r0 = $r1, $r0
; KV3_1-NEXT:    copyd $r1 = $r20
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    fsbfd $r0 = $r31, $r25
; KV3_1-NEXT:    andw $r21 = $r21, $r0
; KV3_1-NEXT:    call __divdf3
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    fcompd.olt $r0 = $r0, $r27
; KV3_1-NEXT:    fcompd.oge $r1 = $r0, $r23
; KV3_1-NEXT:    make $r3 = cp_free_list
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    andw $r0 = $r1, $r0
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    andw $r0 = $r0, $r21
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    cb.weqz $r0 ? .LBB0_9
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:  .LBB0_25:
; KV3_1-NEXT:    lq $r18r19 = 8[$r12]
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    lo $r20r21r22r23 = 24[$r12]
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    lo $r24r25r26r27 = 56[$r12]
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    lo $r28r29r30r31 = 88[$r12]
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    ld $r16 = 120[$r12]
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    set $ra = $r16
; KV3_1-NEXT:    addd $r12 = $r12, 128
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    ret
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:  .LBB0_26:
; KV3_1-NEXT:    make $r0 = .L.str.3
; KV3_1-NEXT:    make $r1 = 1
; KV3_1-NEXT:    call printf
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    call abort
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:  .LBB0_27:
; KV3_1-NEXT:    make $r0 = .L.str.3
; KV3_1-NEXT:    make $r1 = 999
; KV3_1-NEXT:    call printf
; KV3_1-NEXT:    ;;
; KV3_1-NEXT:    call abort
; KV3_1-NEXT:    ;;
;
; KV3_2-LABEL: expandbox:
; KV3_2:       # %bb.0:
; KV3_2-NEXT:    addd $r12 = $r12, -128
; KV3_2-NEXT:    get $r16 = $ra
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    sd 120[$r12] = $r16
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    so 88[$r12] = $r28r29r30r31
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    so 56[$r12] = $r24r25r26r27
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    so 24[$r12] = $r20r21r22r23
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    sq 8[$r12] = $r18r19
; KV3_2-NEXT:    copyd $r18 = $r1
; KV3_2-NEXT:    copyd $r19 = $r0
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    lq $r22r23 = 16[$r19]
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    ld $r26 = 0[$r18]
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    ld $r20 = 24[$r18]
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    ld $r24 = 32[$r19]
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    fsbfd $r0 = $r26, $r22
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    copyd $r1 = $r20
; KV3_2-NEXT:    call __divdf3
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    lq $r30r31 = 8[$r18]
; KV3_2-NEXT:    copyd $r1 = $r20
; KV3_2-NEXT:    copyd $r22 = $r0
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    fsbfd $r0 = $r30, $r23
; KV3_2-NEXT:    call __divdf3
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    fsbfd $r0 = $r31, $r24
; KV3_2-NEXT:    copyd $r1 = $r20
; KV3_2-NEXT:    copyd $r21 = $r0
; KV3_2-NEXT:    call __divdf3
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    make $r23 = 0x0
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    fcompd.ult $r1 = $r0, $r23
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    cb.wnez $r1 ? .LBB0_7
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:  # %bb.1:
; KV3_2-NEXT:    make $r1 = 0x3ff0000000000000
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    fcompd.uge $r0 = $r0, $r1
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    cb.wnez $r0 ? .LBB0_7
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:  # %bb.2:
; KV3_2-NEXT:    make $r0 = 0x0
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    fcompd.ult $r0 = $r22, $r0
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    cb.wnez $r0 ? .LBB0_7
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:  # %bb.3:
; KV3_2-NEXT:    make $r0 = 0x3ff0000000000000
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    fcompd.uge $r0 = $r22, $r0
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    cb.wnez $r0 ? .LBB0_7
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:  # %bb.4:
; KV3_2-NEXT:    make $r0 = 0x4000000000000000
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    fcompd.ult $r0 = $r0, $r22
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    cb.wnez $r0 ? .LBB0_7
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:  # %bb.5:
; KV3_2-NEXT:    make $r0 = 0x0
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    fcompd.ult $r0 = $r21, $r0
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    cb.wnez $r0 ? .LBB0_7
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:  # %bb.6:
; KV3_2-NEXT:    make $r0 = 0x3ff0000000000000
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    fcompd.olt $r0 = $r21, $r0
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    cb.wnez $r0 ? .LBB0_25
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:  .LBB0_7:
; KV3_2-NEXT:    make $r3 = cp_free_list
; KV3_2-NEXT:    make $r27 = 0x3ff0000000000000
; KV3_2-NEXT:    make $r28 = 0
; KV3_2-NEXT:    goto .LBB0_9
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:  .LBB0_8: # in Loop: Header=BB0_9 Depth=1
; KV3_2-NEXT:    make $r0 = 0
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    cb.wnez $r0 ? .LBB0_25
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:  .LBB0_9: # =>This Inner Loop Header: Depth=1
; KV3_2-NEXT:    make $r0 = 0x408f400000000000
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    fcompd.uge $r0 = $r20, $r0
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    cb.wnez $r0 ? .LBB0_27
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:  # %bb.10: # in Loop: Header=BB0_9 Depth=1
; KV3_2-NEXT:    make $r0 = 0x3fe0000000000000
; KV3_2-NEXT:    ld $r1 = 16[$r19]
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    fmuld $r0 = $r20, $r0
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    faddd $r22 = $r0, $r26
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    copyd $r1 = $r0
; KV3_2-NEXT:    fcompd.olt $r2 = $r1, $r22
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    fadddp $r24r25 = $r0r1, $r30r31
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    cb.weqz $r2 ? .LBB0_12
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:  # %bb.11: # in Loop: Header=BB0_9 Depth=1
; KV3_2-NEXT:    fsbfd $r26 = $r20, $r26
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    sd 0[$r18] = $r26
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:  .LBB0_12: # in Loop: Header=BB0_9 Depth=1
; KV3_2-NEXT:    ld $r0 = 24[$r19]
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    fcompd.olt $r0 = $r0, $r24
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    cb.weqz $r0 ? .LBB0_14
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:  # %bb.13: # in Loop: Header=BB0_9 Depth=1
; KV3_2-NEXT:    fsbfd $r30 = $r20, $r30
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    sd 8[$r18] = $r30
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:  .LBB0_14: # in Loop: Header=BB0_9 Depth=1
; KV3_2-NEXT:    ld $r0 = 32[$r19]
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    fcompd.uge $r0 = $r0, $r25
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    cb.wnez $r0 ? .LBB0_16
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:  # %bb.15: # in Loop: Header=BB0_9 Depth=1
; KV3_2-NEXT:    fsbfd $r31 = $r20, $r31
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    sd 16[$r18] = $r31
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:  .LBB0_16: # in Loop: Header=BB0_9 Depth=1
; KV3_2-NEXT:    ld $r0 = 32[$r18]
; KV3_2-NEXT:    faddd $r20 = $r20, $r20
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    sd 24[$r18] = $r20
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    cb.deqz $r0 ? .LBB0_8
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:  # %bb.17: # in Loop: Header=BB0_9 Depth=1
; KV3_2-NEXT:    ld $r21 = 0[$r3]
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    cb.deqz $r21 ? .LBB0_19
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:  # %bb.18: # in Loop: Header=BB0_9 Depth=1
; KV3_2-NEXT:    ld $r0 = 112[$r21]
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    sd 0[$r3] = $r0
; KV3_2-NEXT:    goto .LBB0_20
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:  .LBB0_19: # in Loop: Header=BB0_9 Depth=1
; KV3_2-NEXT:    make $r0 = 120
; KV3_2-NEXT:    call malloc
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    copyd $r21 = $r0
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:  .LBB0_20: # in Loop: Header=BB0_9 Depth=1
; KV3_2-NEXT:    sw 40[$r21] = $r28
; KV3_2-NEXT:    copyd $r29 = $r28
; KV3_2-NEXT:    copyd $r30 = $r28
; KV3_2-NEXT:    copyd $r31 = $r28
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    copyd $r0 = $r28
; KV3_2-NEXT:    make $r1 = 2
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    sh 0[$r21] = $r1
; KV3_2-NEXT:    copyd $r1 = $r28
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    so 48[$r21] = $r28r29r30r31
; KV3_2-NEXT:    copyd $r2 = $r28
; KV3_2-NEXT:    copyd $r3 = $r28
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    so 80[$r21] = $r0r1r2r3
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    ld $r26 = 0[$r18]
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    ld $r20 = 24[$r18]
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    fsbfd $r0 = $r26, $r22
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    copyd $r1 = $r20
; KV3_2-NEXT:    call __divdf3
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    lq $r30r31 = 8[$r18]
; KV3_2-NEXT:    copyd $r22 = $r0
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    fsbfdp $r24r25 = $r30r31, $r24r25
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    copyd $r0 = $r25
; KV3_2-NEXT:    copyd $r1 = $r20
; KV3_2-NEXT:    call __divdf3
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    copyd $r0 = $r24
; KV3_2-NEXT:    copyd $r1 = $r20
; KV3_2-NEXT:    copyd $r25 = $r0
; KV3_2-NEXT:    call __divdf3
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    fcompd.oge $r1 = $r25, $r23
; KV3_2-NEXT:    fcompnd.olt $r2 = $r25, $r27
; KV3_2-NEXT:    copyd $r24 = $r0
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    fcompnd.olt $r0 = $r24, $r27
; KV3_2-NEXT:    cmoved.even $r1 ? $r2 = 0
; KV3_2-NEXT:    fcompd.oge $r3 = $r24, $r23
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    cmoved.even $r3 ? $r0 = 0
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    insf $r0 = $r2, 15, 8
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    extfz $r1 = $r0, 15, 8
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    cb.even $r1 ? .LBB0_26
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:  # %bb.21: # in Loop: Header=BB0_9 Depth=1
; KV3_2-NEXT:    zxbd $r0 = $r0
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    cb.even $r0 ? .LBB0_26
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:  # %bb.22: # in Loop: Header=BB0_9 Depth=1
; KV3_2-NEXT:    fcompd.ult $r0 = $r22, $r23
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    cb.wnez $r0 ? .LBB0_26
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:  # %bb.23: # in Loop: Header=BB0_9 Depth=1
; KV3_2-NEXT:    fcompd.olt $r0 = $r22, $r27
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    cb.weqz $r0 ? .LBB0_26
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:  # %bb.24: # in Loop: Header=BB0_9 Depth=1
; KV3_2-NEXT:    make $r29 = 0x41d0000000000000
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    fmuld $r0 = $r25, $r29
; KV3_2-NEXT:    call floor
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    fixedd.rz $r25 = $r0, 0
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    fmuld $r0 = $r24, $r29
; KV3_2-NEXT:    call floor
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    fixedd.rz $r24 = $r0, 0
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    fmuld $r0 = $r22, $r29
; KV3_2-NEXT:    call floor
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    fixedd.rz $r0 = $r0, 0
; KV3_2-NEXT:    srlw $r1 = $r24, 28
; KV3_2-NEXT:    extfz $r2 = $r25, 29, 29
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    andw $r1 = $r1, 2
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    srlw $r0 = $r0, 27
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    andw $r0 = $r0, 4
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    orw $r0 = $r1, $r0
; KV3_2-NEXT:    ld $r1 = 32[$r18]
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    orw $r0 = $r0, $r2
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    addx8d $r0 = $r0, $r21
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    sd 48[$r0] = $r1
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    sd 32[$r18] = $r21
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    ld $r0 = 16[$r19]
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    lq $r24r25 = 24[$r19]
; KV3_2-NEXT:    copyd $r1 = $r20
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    fsbfd $r0 = $r26, $r0
; KV3_2-NEXT:    call __divdf3
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    fcompd.olt $r0 = $r0, $r27
; KV3_2-NEXT:    fcompd.oge $r1 = $r0, $r23
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    fsbfd $r0 = $r30, $r24
; KV3_2-NEXT:    copyd $r1 = $r20
; KV3_2-NEXT:    andw $r21 = $r1, $r0
; KV3_2-NEXT:    call __divdf3
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    fcompd.olt $r0 = $r0, $r27
; KV3_2-NEXT:    fcompd.oge $r1 = $r0, $r23
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    andw $r0 = $r1, $r0
; KV3_2-NEXT:    copyd $r1 = $r20
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    fsbfd $r0 = $r31, $r25
; KV3_2-NEXT:    andw $r21 = $r21, $r0
; KV3_2-NEXT:    call __divdf3
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    fcompd.olt $r0 = $r0, $r27
; KV3_2-NEXT:    fcompd.oge $r1 = $r0, $r23
; KV3_2-NEXT:    make $r3 = cp_free_list
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    andw $r0 = $r1, $r0
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    andw $r0 = $r0, $r21
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    cb.weqz $r0 ? .LBB0_9
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:  .LBB0_25:
; KV3_2-NEXT:    lq $r18r19 = 8[$r12]
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    lo $r20r21r22r23 = 24[$r12]
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    lo $r24r25r26r27 = 56[$r12]
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    lo $r28r29r30r31 = 88[$r12]
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    ld $r16 = 120[$r12]
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    set $ra = $r16
; KV3_2-NEXT:    addd $r12 = $r12, 128
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    ret
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:  .LBB0_26:
; KV3_2-NEXT:    make $r0 = .L.str.3
; KV3_2-NEXT:    make $r1 = 1
; KV3_2-NEXT:    call printf
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    call abort
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:  .LBB0_27:
; KV3_2-NEXT:    make $r0 = .L.str.3
; KV3_2-NEXT:    make $r1 = 999
; KV3_2-NEXT:    call printf
; KV3_2-NEXT:    ;;
; KV3_2-NEXT:    call abort
; KV3_2-NEXT:    ;;
  %5 = getelementptr inbounds %struct.bnode, %struct.bnode* %0, i64 0, i32 2, i64 0
  %6 = load double, double* %5
  %7 = getelementptr inbounds %struct.bnode, %struct.bnode* %0, i64 0, i32 2, i64 1
  %8 = load double, double* %7
  %9 = getelementptr inbounds %struct.bnode, %struct.bnode* %0, i64 0, i32 2, i64 2
  %10 = load double, double* %9
  %11 = getelementptr inbounds %struct.tree, %struct.tree* %1, i64 0, i32 1
  %12 = load double, double* %11
  %13 = getelementptr inbounds %struct.tree, %struct.tree* %1, i64 0, i32 0, i64 0
  %14 = load double, double* %13
  %15 = fsub double %6, %14
  %16 = fdiv double %15, %12
  %17 = fcmp oge double %16, 0.000000e+00
  %18 = fcmp olt double %16, 1.000000e+00
  %toto = fcmp ole double %16, 2.000000e+00
  %19 = and i1 %17, %18
  %titi = and i1 %19, %toto
  %20 = getelementptr inbounds %struct.tree, %struct.tree* %1, i64 0, i32 0, i64 1
  %21 = getelementptr inbounds %struct.tree, %struct.tree* %1, i64 0, i32 0, i64 2
  %22 = bitcast double* %20 to <2 x double>*
  %23 = load <2 x double>, <2 x double>* %22
  %24 = extractelement <2 x double> %23, i32 0
  %25 = fsub double %8, %24
  %26 = fdiv double %25, %12
  %27 = fcmp oge double %26, 0.000000e+00
  %28 = fcmp olt double %26, 1.000000e+00
  %29 = and i1 %27, %28
  %30 = and i1 %titi, %29
  %31 = extractelement <2 x double> %23, i32 1
  %32 = fsub double %10, %31
  %33 = fdiv double %32, %12
  %34 = fcmp oge double %33, 0.000000e+00
  %35 = fcmp olt double %33, 1.000000e+00
  %36 = and i1 %34, %35
  %37 = and i1 %36, %30
  br i1 %37, label %155, label %38

38:
  %39 = getelementptr inbounds %struct.tree, %struct.tree* %1, i64 0, i32 2
  %40 = bitcast %struct.node** %39 to %struct.cnode**
  %41 = bitcast double* %20 to <2 x double>*
  br label %42

42:
  %43 = phi double [ %14, %38 ], [ %150, %149 ]
  %44 = phi double [ %12, %38 ], [ %151, %149 ]
  %45 = phi <2 x double> [ %23, %38 ], [ %153, %149 ]
  %46 = fcmp olt double %44, 1.000000e+03
  br i1 %46, label %47, label %55

47:
  %48 = fmul double %44, 5.000000e-01
  %49 = fadd double %48, %43
  %50 = insertelement <2 x double> poison, double %48, i32 0
  %51 = shufflevector <2 x double> %50, <2 x double> undef, <2 x i32> zeroinitializer
  %52 = fadd <2 x double> %51, %45
  %53 = load double, double* %5
  %54 = fcmp olt double %53, %49
  br i1 %54, label %57, label %59

55:
  %56 = tail call i32 (i8*, ...) @printf(i8* nonnull dereferenceable(1) getelementptr inbounds ([22 x i8], [22 x i8]* @.str.3, i64 0, i64 0), i32 999)
  tail call void @abort()
  unreachable

57:
  %58 = fsub double %43, %44
  store double %58, double* %13
  br label %59

59:
  %60 = phi double [ %43, %47 ], [ %58, %57 ]
  %61 = load double, double* %7
  %62 = extractelement <2 x double> %52, i32 0
  %63 = fcmp olt double %61, %62
  %64 = extractelement <2 x double> %45, i32 0
  br i1 %63, label %156, label %158

65:
  %66 = load %struct.node*, %struct.node** @cp_free_list
  %67 = icmp eq %struct.node* %66, null
  br i1 %67, label %73, label %68

68:
  %69 = bitcast %struct.node* %66 to %struct.cnode*
  %70 = getelementptr inbounds %struct.node, %struct.node* %66, i64 2, i32 2
  %71 = bitcast [3 x double]* %70 to %struct.node**
  %72 = load %struct.node*, %struct.node** %71
  store %struct.node* %72, %struct.node** @cp_free_list
  br label %76

73:
  %74 = tail call noalias dereferenceable_or_null(120) i8* @malloc(i64 120)
  %75 = bitcast i8* %74 to %struct.cnode*
  br label %76

76:
  %77 = phi %struct.cnode* [ %69, %68 ], [ %75, %73 ]
  %78 = getelementptr inbounds %struct.cnode, %struct.cnode* %77, i64 0, i32 0
  store i16 2, i16* %78
  %79 = getelementptr inbounds %struct.cnode, %struct.cnode* %77, i64 0, i32 3
  store i32 0, i32* %79
  %80 = getelementptr %struct.cnode, %struct.cnode* %77, i64 0, i32 5, i64 0
  %81 = bitcast %struct.node** %80 to i8*
  tail call void @llvm.memset.p0i8.i64(i8* nonnull align 8 dereferenceable(64) %81, i8 0, i64 64, i1 false)
  %82 = load double, double* %13
  %83 = fsub double %49, %82
  %84 = load double, double* %11
  %85 = fdiv double %83, %84
  %86 = fcmp oge double %85, 0.000000e+00
  %87 = fcmp olt double %85, 1.000000e+00
  %88 = and i1 %86, %87
  %89 = load <2 x double>, <2 x double>* %41
  %90 = fsub <2 x double> %52, %89
  %91 = insertelement <2 x double> poison, double %84, i32 0
  %92 = shufflevector <2 x double> %91, <2 x double> undef, <2 x i32> zeroinitializer
  %93 = fdiv <2 x double> %90, %92
  %94 = fcmp oge <2 x double> %93, zeroinitializer
  %95 = fcmp olt <2 x double> %93, <double 1.000000e+00, double 1.000000e+00>
  %96 = and <2 x i1> %94, %95
  %97 = extractelement <2 x i1> %96, i32 0
  %98 = and i1 %97, %88
  %99 = extractelement <2 x i1> %96, i32 1
  %100 = and i1 %99, %98
  br i1 %100, label %103, label %101

101:
  %102 = tail call i32 (i8*, ...) @printf(i8* nonnull dereferenceable(1) getelementptr inbounds ([22 x i8], [22 x i8]* @.str.3, i64 0, i64 0), i32 1)
  tail call void @abort()
  unreachable

103:
  %104 = extractelement <2 x double> %93, i32 1
  %105 = fmul double %104, 0x41D0000000000000
  %106 = tail call double @llvm.floor.f64(double %105)
  %107 = fptosi double %106 to i32
  %108 = extractelement <2 x double> %93, i32 0
  %109 = fmul double %108, 0x41D0000000000000
  %110 = tail call double @llvm.floor.f64(double %109)
  %111 = fptosi double %110 to i32
  %112 = fmul double %85, 0x41D0000000000000
  %113 = tail call double @llvm.floor.f64(double %112)
  %114 = fptosi double %113 to i32
  %115 = lshr i32 %114, 27
  %116 = and i32 %115, 4
  %117 = lshr i32 %111, 28
  %118 = and i32 %117, 2
  %119 = or i32 %118, %116
  %120 = lshr i32 %107, 29
  %121 = and i32 %120, 1
  %122 = or i32 %119, %121
  %123 = load %struct.node*, %struct.node** %39
  %124 = zext i32 %122 to i64
  %125 = getelementptr inbounds %struct.cnode, %struct.cnode* %77, i64 0, i32 5, i64 %124
  store %struct.node* %123, %struct.node** %125
  store %struct.cnode* %77, %struct.cnode** %40
  %126 = load double, double* %5
  %127 = load double, double* %7
  %128 = load double, double* %9
  %129 = fsub double %126, %82
  %130 = fdiv double %129, %84
  %131 = fcmp oge double %130, 0.000000e+00
  %132 = fcmp olt double %130, 1.000000e+00
  %133 = and i1 %131, %132
  %134 = extractelement <2 x double> %89, i32 0
  %135 = fsub double %127, %134
  %136 = fdiv double %135, %84
  %137 = fcmp oge double %136, 0.000000e+00
  %138 = fcmp olt double %136, 1.000000e+00
  %139 = and i1 %137, %138
  %140 = and i1 %133, %139
  %141 = extractelement <2 x double> %89, i32 1
  %142 = fsub double %128, %141
  %143 = fdiv double %142, %84
  %144 = fcmp oge double %143, 0.000000e+00
  %145 = fcmp olt double %143, 1.000000e+00
  %146 = and i1 %144, %145
  %147 = and i1 %146, %140
  %148 = zext i1 %147 to i32
  br label %149

149:
  %150 = phi double [ %82, %103 ], [ %60, %166 ]
  %151 = phi double [ %84, %103 ], [ %168, %166 ]
  %152 = phi i32 [ %148, %103 ], [ 0, %166 ]
  %153 = phi <2 x double> [ %89, %103 ], [ %172, %166 ]
  %154 = icmp eq i32 %152, 0
  br i1 %154, label %42, label %155

155:
  ret void

156:
  %157 = fsub double %64, %44
  store double %157, double* %20
  br label %158

158:
  %159 = phi double [ %157, %156 ], [ %64, %59 ]
  %160 = load double, double* %9
  %161 = extractelement <2 x double> %52, i32 1
  %162 = fcmp olt double %160, %161
  %163 = extractelement <2 x double> %45, i32 1
  br i1 %162, label %164, label %166

164:
  %165 = fsub double %163, %44
  store double %165, double* %21
  br label %166

166:
  %167 = phi double [ %165, %164 ], [ %163, %158 ]
  %168 = fmul double %44, 2.000000e+00
  store double %168, double* %11
  %169 = load %struct.node*, %struct.node** %39
  %170 = icmp eq %struct.node* %169, null
  %171 = insertelement <2 x double> poison, double %159, i32 0
  %172 = insertelement <2 x double> %171, double %167, i32 1
  br i1 %170, label %149, label %65
}

declare double @llvm.floor.f64(double)

declare double @llvm.ceil.f64(double)

declare noundef i32 @puts(i8* nocapture noundef readonly)

declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg)

declare <2 x double> @llvm.floor.v2f64(<2 x double>)

