; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -o - %s -O2 | FileCheck %s
target triple = "kvx-kalray-cos"

define void @st(i32* nocapture %0, i32 %1, i32 %2) {
; CHECK-LABEL: st:
; CHECK:       # %bb.0:
; CHECK-NEXT:    sw.wnez $r2 ? [$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = icmp eq i32 %2, 0
  br i1 %4, label %6, label %5

5:
  store i32 %1, i32* %0, align 4
  br label %6

6:
  ret void
}

define void @sw_weven(i32* nocapture %0, i32 %1, i32 %2) {
; CHECK-LABEL: sw_weven:
; CHECK:       # %bb.0:
; CHECK-NEXT:    sw.even $r2 ? [$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = and i32 %2, 1
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %6, label %7

6:
  store i32 %1, i32* %0, align 4
  br label %7

7:
  ret void
}

define void @sw_wodd(i32* nocapture %0, i32 %1, i32 %2) {
; CHECK-LABEL: sw_wodd:
; CHECK:       # %bb.0:
; CHECK-NEXT:    sw.odd $r2 ? [$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = and i32 %2, 1
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %7, label %6

6:
  store i32 %1, i32* %0, align 4
  br label %7

7:
  ret void
}

define void @sw_wgtz(i32* nocapture %0, i32 %1, i32 %2) {
; CHECK-LABEL: sw_wgtz:
; CHECK:       # %bb.0:
; CHECK-NEXT:    sw.wgtz $r2 ? [$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = icmp sgt i32 %2, 0
  br i1 %4, label %5, label %6

5:
  store i32 %1, i32* %0, align 4
  br label %6

6:
  ret void
}

define void @sw_wltz(i32* nocapture %0, i32 %1, i32 %2) {
; CHECK-LABEL: sw_wltz:
; CHECK:       # %bb.0:
; CHECK-NEXT:    sw.wltz $r2 ? [$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = icmp slt i32 %2, 0
  br i1 %4, label %5, label %6

5:
  store i32 %1, i32* %0, align 4
  br label %6

6:
  ret void
}

define void @sw_wlez(i32* nocapture %0, i32 %1, i32 %2) {
; CHECK-LABEL: sw_wlez:
; CHECK:       # %bb.0:
; CHECK-NEXT:    sw.wlez $r2 ? [$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = icmp slt i32 %2, 1
  br i1 %4, label %5, label %6

5:
  store i32 %1, i32* %0, align 4
  br label %6

6:
  ret void
}

define void @sw_wgez(i32* nocapture %0, i32 %1, i32 %2) {
; CHECK-LABEL: sw_wgez:
; CHECK:       # %bb.0:
; CHECK-NEXT:    sw.wgez $r2 ? [$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = icmp sgt i32 %2, -1
  br i1 %4, label %5, label %6

5:
  store i32 %1, i32* %0, align 4
  br label %6

6:
  ret void
}

define void @sw_weqz(i32* nocapture %0, i32 %1, i32 %2) {
; CHECK-LABEL: sw_weqz:
; CHECK:       # %bb.0:
; CHECK-NEXT:    sw.weqz $r2 ? [$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = icmp eq i32 %2, 0
  br i1 %4, label %5, label %6

5:
  store i32 %1, i32* %0, align 4
  br label %6

6:
  ret void
}

define void @sw_wnez(i32* nocapture %0, i32 %1, i32 %2) {
; CHECK-LABEL: sw_wnez:
; CHECK:       # %bb.0:
; CHECK-NEXT:    sw.wnez $r2 ? [$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = icmp eq i32 %2, 0
  br i1 %4, label %6, label %5

5:
  store i32 %1, i32* %0, align 4
  br label %6

6:
  ret void
}

define void @sw_wnez2(i32* nocapture %0, i32 %1, i32 %2, i32 %3) {
; CHECK-LABEL: sw_wnez2:
; CHECK:       # %bb.0:
; CHECK-NEXT:    sw.wnez $r2 ? 4[$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %5 = icmp eq i32 %2, 0
  br i1 %5, label %8, label %6

6:
  %7 = getelementptr inbounds i32, i32* %0, i64 1
  store i32 %1, i32* %7, align 4
  br label %8

8:
  ret void
}

define void @sw_and_cond1(i32* nocapture %0, i32 %1, i32 %2) {
; CHECK-LABEL: sw_and_cond1:
; CHECK:       # %bb.0:
; CHECK-NEXT:    andw $r2 = $r2, 0xf34d
; CHECK-NEXT:    ;;
; CHECK-NEXT:    sw.wnez $r2 ? [$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = and i32 %2, 62285
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %7, label %6

6:
  store i32 %1, i32* %0, align 4
  br label %7

7:
  ret void
}

define void @sw_compw_cond1(i32* nocapture %0, i32 %1, i32 %2) {
; CHECK-LABEL: sw_compw_cond1:
; CHECK:       # %bb.0:
; CHECK-NEXT:    compw.lt $r2 = $r2, 0xf34e
; CHECK-NEXT:    ;;
; CHECK-NEXT:    sw.even $r2 ? [$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = icmp sgt i32 %2, 62285
  br i1 %4, label %5, label %6

5:
  store i32 %1, i32* %0, align 4
  br label %6

6:
  ret void
}

define void @sw_ri27(i8* nocapture %0, i8 %1, i32 %2) {
; CHECK-LABEL: sw_ri27:
; CHECK:       # %bb.0:
; CHECK-NEXT:    sb.wnez $r2 ? 0x3ffffff[$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = icmp eq i32 %2, 0
  br i1 %4, label %7, label %5

5:
  %6 = getelementptr inbounds i8, i8* %0, i64 67108863
  store i8 %1, i8* %6, align 1
  br label %7

7:
  ret void
}

define void @sw_ri54(i8* nocapture %0, i8 %1, i32 %2) {
; CHECK-LABEL: sw_ri54:
; CHECK:       # %bb.0:
; CHECK-NEXT:    sb.wnez $r2 ? 0x4000000[$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = icmp eq i32 %2, 0
  br i1 %4, label %7, label %5

5:
  %6 = getelementptr inbounds i8, i8* %0, i64 67108864
  store i8 %1, i8* %6, align 1
  br label %7

7:
  ret void
}

define void @sw_ri54_max(i8* nocapture %0, i8 %1, i32 %2) {
; CHECK-LABEL: sw_ri54_max:
; CHECK:       # %bb.0:
; CHECK-NEXT:    sb.wnez $r2 ? 0x1fffffffffffff[$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = icmp eq i32 %2, 0
  br i1 %4, label %7, label %5

5:
  %6 = getelementptr inbounds i8, i8* %0, i64 9007199254740991
  store i8 %1, i8* %6, align 1
  br label %7

7:
  ret void
}

define void @sw_ri54_over_max(i8* nocapture %0, i8 %1, i32 %2) {
; CHECK-LABEL: sw_ri54_over_max:
; CHECK:       # %bb.0:
; CHECK-NEXT:    cb.weqz $r2 ? .LBB15_2
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    sb 0x20000000000000[$r0] = $r1
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB15_2:
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = icmp eq i32 %2, 0
  br i1 %4, label %7, label %5

5:
  %6 = getelementptr inbounds i8, i8* %0, i64 9007199254740992
  store i8 %1, i8* %6, align 1
  br label %7

7:
  ret void
}

define void @sw_ri54_min(i8* nocapture %0, i8 %1, i32 %2) {
; CHECK-LABEL: sw_ri54_min:
; CHECK:       # %bb.0:
; CHECK-NEXT:    sb.wnez $r2 ? 0xffe0000000000000[$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = icmp eq i32 %2, 0
  br i1 %4, label %7, label %5

5:
  %6 = getelementptr inbounds i8, i8* %0, i64 -9007199254740992
  store i8 %1, i8* %6, align 1
  br label %7

7:
  ret void
}

define void @sw_ri54_sub_min(i8* nocapture %0, i8 %1, i32 %2) {
; CHECK-LABEL: sw_ri54_sub_min:
; CHECK:       # %bb.0:
; CHECK-NEXT:    cb.weqz $r2 ? .LBB17_2
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    sb 0xffdfffffffffffff[$r0] = $r1
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB17_2:
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = icmp eq i32 %2, 0
  br i1 %4, label %7, label %5

5:
  %6 = getelementptr inbounds i8, i8* %0, i64 -9007199254740993
  store i8 %1, i8* %6, align 1
  br label %7

7:
  ret void
}

define void @sw_rr(i8* nocapture %0, i8 %1, i64 %2) {
; CHECK-LABEL: sw_rr:
; CHECK:       # %bb.0:
; CHECK-NEXT:    sb.dnez $r2 ? [$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = icmp eq i64 %2, 0
  br i1 %4, label %6, label %5

5:
  store i8 %1, i8* %0, align 1
  br label %6

6:
  ret void
}

define void @sw_rr_scale(i32* nocapture %0, i32 %1, i64 %2) {
; CHECK-LABEL: sw_rr_scale:
; CHECK:       # %bb.0:
; CHECK-NEXT:    cb.deqz $r2 ? .LBB19_2
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    sw.xs $r2[$r0] = $r1
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB19_2:
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = icmp eq i64 %2, 0
  br i1 %4, label %7, label %5

5:
  %6 = getelementptr inbounds i32, i32* %0, i64 %2
  store i32 %1, i32* %6, align 4
  br label %7

7:
  ret void
}

define void @sw_rr_scale_offset(i32* nocapture %0, i32 %1, i64 %2) {
; CHECK-LABEL: sw_rr_scale_offset:
; CHECK:       # %bb.0:
; CHECK-NEXT:    cb.deqz $r2 ? .LBB20_2
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    sw.xs $r2[$r0] = $r1
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB20_2:
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = icmp eq i64 %2, 0
  br i1 %4, label %7, label %5

5:
  %6 = getelementptr inbounds i32, i32* %0, i64 %2
  store i32 %1, i32* %6, align 4
  br label %7

7:
  ret void
}

define void @sw_rr_offset(i8* nocapture %0, i8 %1, i64 %2) {
; CHECK-LABEL: sw_rr_offset:
; CHECK:       # %bb.0:
; CHECK-NEXT:    cb.deqz $r2 ? .LBB21_2
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    sb $r2[$r0] = $r1
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB21_2:
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = icmp eq i64 %2, 0
  br i1 %4, label %7, label %5

5:
  %6 = getelementptr inbounds i8, i8* %0, i64 %2
  store i8 %1, i8* %6, align 1
  br label %7

7:
  ret void
}

define void @multiple_st(i32* %0, i32 %1, i32 %2) {
; CHECK-LABEL: multiple_st:
; CHECK:       # %bb.0:
; CHECK-NEXT:    sw.wnez $r2 ? [$r0] = $r1
; CHECK-NEXT:    ;;
; CHECK-NEXT:    sw.wnez $r2 ? 8[$r0] = $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = icmp eq i32 %2, 0
  br i1 %4, label %7, label %5

5:
  store volatile i32 %1, i32* %0, align 4
  %6 = getelementptr inbounds i32, i32* %0, i64 2
  store volatile i32 %2, i32* %6, align 4
  br label %7

7:
  ret void
}

define i32 @select_make(i32* %0, i32 %1, i32 %2) {
; CHECK-LABEL: select_make:
; CHECK:       # %bb.0:
; CHECK-NEXT:    sw.wnez $r2 ? [$r0] = $r1
; CHECK-NEXT:    cmoved.weqz $r2 ? $r1 = 0
; CHECK-NEXT:    ;;
; CHECK-NEXT:    copyd $r0 = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = icmp eq i32 %2, 0
  br i1 %4, label %6, label %5

5:
  store volatile i32 %1, i32* %0, align 4
  br label %6

6:
  %7 = phi i32 [ %1, %5 ], [ 0, %3 ]
  ret i32 %7
}

; TODO: Could improve if-predication to accept inverting
; the select condition of the output.
define i32 @select_make_inverted(i32* %0, i32 %1, i32 %2) {
; CHECK-LABEL: select_make_inverted:
; CHECK:       # %bb.0:
; CHECK-NEXT:    cb.weqz $r2 ? .LBB24_2
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    sw 0[$r0] = $r1
; CHECK-NEXT:    make $r1 = 0
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB24_2:
; CHECK-NEXT:    copyd $r0 = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = icmp eq i32 %2, 0
  br i1 %4, label %6, label %5

5:
  store volatile i32 %1, i32* %0, align 4
  br label %6

6:
  %7 = phi i32 [ 0, %5 ], [ %1, %3 ]
  ret i32 %7
}

define i32 @select_inputs(i32* %0, i32 %1, i32 %2, i32 %a) {
; CHECK-LABEL: select_inputs:
; CHECK:       # %bb.0:
; CHECK-NEXT:    sw.wnez $r2 ? [$r0] = $r1
; CHECK-NEXT:    cmoved.weqz $r2 ? $r1 = $r3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    copyd $r0 = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = icmp eq i32 %2, 0
  br i1 %4, label %6, label %5

5:
  store volatile i32 %1, i32* %0, align 4
  br label %6

6:
  %7 = phi i32 [ %1, %5 ], [ %a, %3 ]
  ret i32 %7
}
