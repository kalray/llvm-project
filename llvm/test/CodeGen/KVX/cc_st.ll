; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -verify-machineinstrs -o - %s -O2 | FileCheck %s
target triple = "kvx-kalray-cos"

define void @st(i32* nocapture %0, i32 %1, i32 %2) {
; CHECK-LABEL: st:
; CHECK:       # %bb.0:
; CHECK-NEXT:    sw.wnez $r2 ? [$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = icmp eq i32 %2, 0
  br i1 %4, label %6, label %5

5:
  store i32 %1, i32* %0, align 4
  br label %6

6:
  ret void
}

define void @sw_weven(i32* nocapture %0, i32 %1, i32 %2) {
; CHECK-LABEL: sw_weven:
; CHECK:       # %bb.0:
; CHECK-NEXT:    sw.even $r2 ? [$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = and i32 %2, 1
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %6, label %7

6:
  store i32 %1, i32* %0, align 4
  br label %7

7:
  ret void
}

define void @sw_wodd(i32* nocapture %0, i32 %1, i32 %2) {
; CHECK-LABEL: sw_wodd:
; CHECK:       # %bb.0:
; CHECK-NEXT:    sw.odd $r2 ? [$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = and i32 %2, 1
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %7, label %6

6:
  store i32 %1, i32* %0, align 4
  br label %7

7:
  ret void
}

define void @sw_wgtz(i32* nocapture %0, i32 %1, i32 %2) {
; CHECK-LABEL: sw_wgtz:
; CHECK:       # %bb.0:
; CHECK-NEXT:    sw.wgtz $r2 ? [$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = icmp sgt i32 %2, 0
  br i1 %4, label %5, label %6

5:
  store i32 %1, i32* %0, align 4
  br label %6

6:
  ret void
}

define void @sw_wltz(i32* nocapture %0, i32 %1, i32 %2) {
; CHECK-LABEL: sw_wltz:
; CHECK:       # %bb.0:
; CHECK-NEXT:    sw.wltz $r2 ? [$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = icmp slt i32 %2, 0
  br i1 %4, label %5, label %6

5:
  store i32 %1, i32* %0, align 4
  br label %6

6:
  ret void
}

define void @sw_wlez(i32* nocapture %0, i32 %1, i32 %2) {
; CHECK-LABEL: sw_wlez:
; CHECK:       # %bb.0:
; CHECK-NEXT:    sw.wlez $r2 ? [$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = icmp slt i32 %2, 1
  br i1 %4, label %5, label %6

5:
  store i32 %1, i32* %0, align 4
  br label %6

6:
  ret void
}

define void @sw_wgez(i32* nocapture %0, i32 %1, i32 %2) {
; CHECK-LABEL: sw_wgez:
; CHECK:       # %bb.0:
; CHECK-NEXT:    sw.wgez $r2 ? [$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = icmp sgt i32 %2, -1
  br i1 %4, label %5, label %6

5:
  store i32 %1, i32* %0, align 4
  br label %6

6:
  ret void
}

define void @sw_weqz(i32* nocapture %0, i32 %1, i32 %2) {
; CHECK-LABEL: sw_weqz:
; CHECK:       # %bb.0:
; CHECK-NEXT:    sw.weqz $r2 ? [$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = icmp eq i32 %2, 0
  br i1 %4, label %5, label %6

5:
  store i32 %1, i32* %0, align 4
  br label %6

6:
  ret void
}

define void @sw_wnez(i32* nocapture %0, i32 %1, i32 %2) {
; CHECK-LABEL: sw_wnez:
; CHECK:       # %bb.0:
; CHECK-NEXT:    sw.wnez $r2 ? [$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = icmp eq i32 %2, 0
  br i1 %4, label %6, label %5

5:
  store i32 %1, i32* %0, align 4
  br label %6

6:
  ret void
}

define void @sw_wnez2(i32* nocapture %0, i32 %1, i32 %2, i32 %3) {
; CHECK-LABEL: sw_wnez2:
; CHECK:       # %bb.0:
; CHECK-NEXT:    sw.wnez $r2 ? 4[$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %5 = icmp eq i32 %2, 0
  br i1 %5, label %8, label %6

6:
  %7 = getelementptr inbounds i32, i32* %0, i64 1
  store i32 %1, i32* %7, align 4
  br label %8

8:
  ret void
}

define void @sw_and_cond1(i32* nocapture %0, i32 %1, i32 %2) {
; CHECK-LABEL: sw_and_cond1:
; CHECK:       # %bb.0:
; CHECK-NEXT:    andw $r2 = $r2, 0xf34d
; CHECK-NEXT:    ;;
; CHECK-NEXT:    sw.wnez $r2 ? [$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = and i32 %2, 62285
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %7, label %6

6:
  store i32 %1, i32* %0, align 4
  br label %7

7:
  ret void
}

define void @sw_compw_cond1(i32* nocapture %0, i32 %1, i32 %2) {
; CHECK-LABEL: sw_compw_cond1:
; CHECK:       # %bb.0:
; CHECK-NEXT:    compw.lt $r2 = $r2, 0xf34e
; CHECK-NEXT:    ;;
; CHECK-NEXT:    sw.even $r2 ? [$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = icmp sgt i32 %2, 62285
  br i1 %4, label %5, label %6

5:
  store i32 %1, i32* %0, align 4
  br label %6

6:
  ret void
}

define void @sw_ri27(i8* nocapture %0, i8 %1, i32 %2) {
; CHECK-LABEL: sw_ri27:
; CHECK:       # %bb.0:
; CHECK-NEXT:    sb.wnez $r2 ? 0x3ffffff[$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = icmp eq i32 %2, 0
  br i1 %4, label %7, label %5

5:
  %6 = getelementptr inbounds i8, i8* %0, i64 67108863
  store i8 %1, i8* %6, align 1
  br label %7

7:
  ret void
}

define void @sw_ri54(i8* nocapture %0, i8 %1, i32 %2) {
; CHECK-LABEL: sw_ri54:
; CHECK:       # %bb.0:
; CHECK-NEXT:    sb.wnez $r2 ? 0x4000000[$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = icmp eq i32 %2, 0
  br i1 %4, label %7, label %5

5:
  %6 = getelementptr inbounds i8, i8* %0, i64 67108864
  store i8 %1, i8* %6, align 1
  br label %7

7:
  ret void
}

define void @sw_ri54_max(i8* nocapture %0, i8 %1, i32 %2) {
; CHECK-LABEL: sw_ri54_max:
; CHECK:       # %bb.0:
; CHECK-NEXT:    sb.wnez $r2 ? 0x1fffffffffffff[$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = icmp eq i32 %2, 0
  br i1 %4, label %7, label %5

5:
  %6 = getelementptr inbounds i8, i8* %0, i64 9007199254740991
  store i8 %1, i8* %6, align 1
  br label %7

7:
  ret void
}

define void @sw_ri54_over_max(i8* nocapture %0, i8 %1, i32 %2) {
; CHECK-LABEL: sw_ri54_over_max:
; CHECK:       # %bb.0:
; CHECK-NEXT:    cb.weqz $r2 ? .LBB15_2
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    sb 0x20000000000000[$r0] = $r1
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB15_2:
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = icmp eq i32 %2, 0
  br i1 %4, label %7, label %5

5:
  %6 = getelementptr inbounds i8, i8* %0, i64 9007199254740992
  store i8 %1, i8* %6, align 1
  br label %7

7:
  ret void
}

define void @sw_ri54_min(i8* nocapture %0, i8 %1, i32 %2) {
; CHECK-LABEL: sw_ri54_min:
; CHECK:       # %bb.0:
; CHECK-NEXT:    sb.wnez $r2 ? 0xffe0000000000000[$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = icmp eq i32 %2, 0
  br i1 %4, label %7, label %5

5:
  %6 = getelementptr inbounds i8, i8* %0, i64 -9007199254740992
  store i8 %1, i8* %6, align 1
  br label %7

7:
  ret void
}

define void @sw_ri54_sub_min(i8* nocapture %0, i8 %1, i32 %2) {
; CHECK-LABEL: sw_ri54_sub_min:
; CHECK:       # %bb.0:
; CHECK-NEXT:    cb.weqz $r2 ? .LBB17_2
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    sb 0xffdfffffffffffff[$r0] = $r1
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB17_2:
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = icmp eq i32 %2, 0
  br i1 %4, label %7, label %5

5:
  %6 = getelementptr inbounds i8, i8* %0, i64 -9007199254740993
  store i8 %1, i8* %6, align 1
  br label %7

7:
  ret void
}

define void @sw_rr(i8* nocapture %0, i8 %1, i64 %2) {
; CHECK-LABEL: sw_rr:
; CHECK:       # %bb.0:
; CHECK-NEXT:    sb.dnez $r2 ? [$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = icmp eq i64 %2, 0
  br i1 %4, label %6, label %5

5:
  store i8 %1, i8* %0, align 1
  br label %6

6:
  ret void
}

define void @sw_rr_scale(i32* nocapture %0, i32 %1, i64 %2) {
; CHECK-LABEL: sw_rr_scale:
; CHECK:       # %bb.0:
; CHECK-NEXT:    cb.deqz $r2 ? .LBB19_2
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    sw.xs $r2[$r0] = $r1
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB19_2:
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = icmp eq i64 %2, 0
  br i1 %4, label %7, label %5

5:
  %6 = getelementptr inbounds i32, i32* %0, i64 %2
  store i32 %1, i32* %6, align 4
  br label %7

7:
  ret void
}

define void @sw_rr_scale_offset(i32* nocapture %0, i32 %1, i64 %2) {
; CHECK-LABEL: sw_rr_scale_offset:
; CHECK:       # %bb.0:
; CHECK-NEXT:    cb.deqz $r2 ? .LBB20_2
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    sw.xs $r2[$r0] = $r1
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB20_2:
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = icmp eq i64 %2, 0
  br i1 %4, label %7, label %5

5:
  %6 = getelementptr inbounds i32, i32* %0, i64 %2
  store i32 %1, i32* %6, align 4
  br label %7

7:
  ret void
}

define void @sw_rr_offset(i8* nocapture %0, i8 %1, i64 %2) {
; CHECK-LABEL: sw_rr_offset:
; CHECK:       # %bb.0:
; CHECK-NEXT:    cb.deqz $r2 ? .LBB21_2
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    sb $r2[$r0] = $r1
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB21_2:
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = icmp eq i64 %2, 0
  br i1 %4, label %7, label %5

5:
  %6 = getelementptr inbounds i8, i8* %0, i64 %2
  store i8 %1, i8* %6, align 1
  br label %7

7:
  ret void
}

define void @multiple_st(i32* %0, i32 %1, i32 %2) {
; CHECK-LABEL: multiple_st:
; CHECK:       # %bb.0:
; CHECK-NEXT:    sw.wnez $r2 ? [$r0] = $r1
; CHECK-NEXT:    ;;
; CHECK-NEXT:    sw.wnez $r2 ? 8[$r0] = $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = icmp eq i32 %2, 0
  br i1 %4, label %7, label %5

5:
  store volatile i32 %1, i32* %0, align 4
  %6 = getelementptr inbounds i32, i32* %0, i64 2
  store volatile i32 %2, i32* %6, align 4
  br label %7

7:
  ret void
}

; TODO: Refine cost model, as this could be
; 2 bundles and should be profitable to if-cvt.
define i32 @select_make(i32* %0, i32 %1, i32 %2) {
; CHECK-LABEL: select_make:
; CHECK:       # %bb.0:
; CHECK-NEXT:    cb.weqz $r2 ? .LBB23_1
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.2:
; CHECK-NEXT:    sw 0[$r0] = $r1
; CHECK-NEXT:    copyd $r0 = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB23_1:
; CHECK-NEXT:    make $r1 = 0
; CHECK-NEXT:    ;;
; CHECK-NEXT:    copyd $r0 = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = icmp eq i32 %2, 0
  br i1 %4, label %6, label %5

5:
  store volatile i32 %1, i32* %0, align 4
  br label %6

6:
  %7 = phi i32 [ %1, %5 ], [ 0, %3 ]
  ret i32 %7
}

define i32 @select_make_inverted(i32* %0, i32 %1, i32 %2) {
; CHECK-LABEL: select_make_inverted:
; CHECK:       # %bb.0:
; CHECK-NEXT:    cb.weqz $r2 ? .LBB24_2
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    sw 0[$r0] = $r1
; CHECK-NEXT:    make $r1 = 0
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB24_2:
; CHECK-NEXT:    copyd $r0 = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = icmp eq i32 %2, 0
  br i1 %4, label %6, label %5

5:
  store volatile i32 %1, i32* %0, align 4
  br label %6

6:
  %7 = phi i32 [ 0, %5 ], [ %1, %3 ]
  ret i32 %7
}

define i32 @select_inputs(i32* %0, i32 %1, i32 %2, i32 %a) {
; CHECK-LABEL: select_inputs:
; CHECK:       # %bb.0:
; CHECK-NEXT:    cb.weqz $r2 ? .LBB25_2
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    sw 0[$r0] = $r1
; CHECK-NEXT:    copyd $r3 = $r1
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB25_2:
; CHECK-NEXT:    copyd $r0 = $r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = icmp eq i32 %2, 0
  br i1 %4, label %6, label %5

5:
  store volatile i32 %1, i32* %0, align 4
  br label %6

6:
  %7 = phi i32 [ %1, %5 ], [ %a, %3 ]
  ret i32 %7
}


define void @stq_cc(<2 x i64> %0, <2 x i64>* nocapture %1, i64 %2) {
; CHECK-LABEL: stq_cc:
; CHECK:       # %bb.0:
; CHECK-NEXT:    sq.dnez $r3 ? [$r2] = $r0r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = icmp eq i64 %2, 0
  br i1 %4, label %6, label %5

5:
  store <2 x i64> %0, <2 x i64>* %1, align 16
  br label %6

6:
  ret void
}


define void @sto_cc(<4 x i64> %0, <4 x i64>* nocapture %1, i64 %2) {
; CHECK-LABEL: sto_cc:
; CHECK:       # %bb.0:
; CHECK-NEXT:    so.dnez $r5 ? [$r4] = $r0r1r2r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = icmp eq i64 %2, 0
  br i1 %4, label %6, label %5

5:
  store <4 x i64> %0, <4 x i64>* %1, align 32
  br label %6

6:
  ret void
}

; TODO: Debug why these are not if-converted.
define <2 x i64> @select_inputs_paired(<2 x i64>* %0, <2 x i64> %1, <2 x i64> %a, i32 %2) {
; CHECK-LABEL: select_inputs_paired:
; CHECK:       # %bb.0:
; CHECK-NEXT:    copyd $r7 = $r4
; CHECK-NEXT:    copyd $r9 = $r2
; CHECK-NEXT:    copyd $r6 = $r3
; CHECK-NEXT:    copyd $r8 = $r1
; CHECK-NEXT:    cb.weqz $r5 ? .LBB28_2
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    sq 0[$r0] = $r8r9
; CHECK-NEXT:    copyq $r6r7 = $r8, $r9
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB28_2:
; CHECK-NEXT:    copyd $r0 = $r6
; CHECK-NEXT:    copyd $r1 = $r7
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = icmp eq i32 %2, 0
  br i1 %4, label %6, label %5

5:
  store volatile <2 x i64> %1, <2 x i64>* %0, align 4
  br label %6

6:
  %7 = phi <2 x i64> [ %1, %5 ], [ %a, %3 ]
  ret <2 x i64> %7
}

; TODO: 4 x copyd would be better than a single so performance wise
define <4 x i64> @select_inputs_quad(<4 x i64>* %0, <4 x i64> %1, <4 x i64> %a, i32 %2) {
; CHECK-LABEL: select_inputs_quad:
; CHECK:       # %bb.0:
; CHECK-NEXT:    copyd $r35 = $r8
; CHECK-NEXT:    copyd $r39 = $r4
; CHECK-NEXT:    copyd $r34 = $r7
; CHECK-NEXT:    copyd $r38 = $r3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    copyd $r33 = $r6
; CHECK-NEXT:    copyd $r37 = $r2
; CHECK-NEXT:    copyd $r32 = $r5
; CHECK-NEXT:    copyd $r36 = $r1
; CHECK-NEXT:    cb.weqz $r9 ? .LBB29_2
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    so 0[$r0] = $r36r37r38r39
; CHECK-NEXT:    ;;
; CHECK-NEXT:    copyo $r32r33r34r35 = $r36r37r38r39
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB29_2:
; CHECK-NEXT:    copyd $r0 = $r32
; CHECK-NEXT:    copyd $r1 = $r33
; CHECK-NEXT:    copyd $r2 = $r34
; CHECK-NEXT:    copyd $r3 = $r35
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = icmp eq i32 %2, 0
  br i1 %4, label %6, label %5

5:
  store volatile <4 x i64> %1, <4 x i64>* %0, align 4
  br label %6

6:
  %7 = phi <4 x i64> [ %1, %5 ], [ %a, %3 ]
  ret <4 x i64> %7
}
