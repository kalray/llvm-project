; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -disable-kvx-hwloops=false -O2 -mcpu=kv3-1 -o - %s -O2 | FileCheck %s --check-prefix=CHECK
; RUN: llc -disable-kvx-hwloops=false -O2 -mcpu=kv3-2 -o - %s -O2 | FileCheck %s --check-prefix=CHECK
; RUN: clang -march=kv3-1 -mllvm -disable-kvx-hwloops=false -O2 -c -o /dev/null %s
; RUN: clang -march=kv3-2 -mllvm -disable-kvx-hwloops=false -O2 -c -o /dev/null %s

target triple = "kvx-kalray-cos"

define void @set(i32* nocapture %x, i32 %num){
; CHECK-LABEL: set:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cb.weqz $r1 ? .LBB0_3
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.1: # %for.body.preheader
; CHECK-NEXT:    make $r1 = 0
; CHECK-NEXT:    zxwd $r2 = $r1
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    loopdo $r2, .__LOOPDO_0_END_
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_2: # %for.body
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    mulw $r2 = $r1, $r1
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sw.xs $r1[$r0] = $r2
; CHECK-NEXT:    addd $r1 = $r1, 1
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:  .__LOOPDO_0_END_:
; CHECK-NEXT:  .LBB0_3: # %for.cond.cleanup
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %cmp6 = icmp eq i32 %num, 0
  br i1 %cmp6, label %for.cond.cleanup, label %for.body.preheader

for.body.preheader:
  %0 = zext i32 %num to i64
  br label %for.body

for.cond.cleanup:
  ret void

for.body:
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ]
  %1 = trunc i64 %indvars.iv to i32
  %mul = mul nsw i32 %1, %1
  %arrayidx = getelementptr inbounds i32, i32* %x, i64 %indvars.iv
  store i32 %mul, i32* %arrayidx, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %cmp = icmp eq i64 %indvars.iv.next, %0
  br i1 %cmp, label %for.cond.cleanup, label %for.body
}

define i32 @f(i32 %num){
; CHECK-LABEL: f:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    addx4wd $r1 = $r0, 31
; CHECK-NEXT:    addd $r12 = $r12, -32
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 24[$r12] = $r16
; CHECK-NEXT:    andd $r1 = $r1, -32
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    sd 16[$r12] = $r14
; CHECK-NEXT:    sbfd $r1 = $r1, $r12
; CHECK-NEXT:    addd $r14 = $r12, 16
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    copyd $r12 = $r1
; CHECK-NEXT:    ;;
; CHECK-NEXT:    cb.weqz $r0 ? .LBB1_8
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.1: # %for.body.preheader.i
; CHECK-NEXT:    zxwd $r2 = $r0
; CHECK-NEXT:    make $r3 = 0
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    loopdo $r2, .__LOOPDO_3_END_
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB1_2: # %for.body.i
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    mulw $r4 = $r3, $r3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sw.xs $r3[$r1] = $r4
; CHECK-NEXT:    addd $r3 = $r3, 1
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:  .__LOOPDO_3_END_:
; CHECK-NEXT:  # %bb.3: # %set.exit
; CHECK-NEXT:    addx8wd $r3 = $r0, 31
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    andd $r3 = $r3, -32
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    sbfd $r3 = $r3, $r12
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    copyd $r12 = $r3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    make $r4 = 0
; CHECK-NEXT:    sllw $r5 = $r0, 1
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    loopdo $r5, .__LOOPDO_2_END_
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB1_4: # %for.body.i36
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    mulw $r5 = $r4, $r4
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sw.xs $r4[$r3] = $r5
; CHECK-NEXT:    addd $r4 = $r4, 1
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:  .__LOOPDO_2_END_:
; CHECK-NEXT:  # %bb.5: # %set.exit37
; CHECK-NEXT:    cb.weqz $r0 ? .LBB1_8
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.6: # %for.body.preheader
; CHECK-NEXT:    make $r0 = 0
; CHECK-NEXT:    sxwd $r4 = $r0
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    loopdo $r2, .__LOOPDO_1_END_
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB1_7: # %for.body
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    addd $r1 = $r1, 4
; CHECK-NEXT:    lwz $r2 = 0[$r1]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    lwz $r5 = 0[$r3]
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    addd $r3 = $r3, 4
; CHECK-NEXT:    lwz.xs $r6 = $r4[$r3]
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    addw $r0 = $r2, $r0
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    addw $r0 = $r0, $r5
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    addw $r0 = $r0, $r6
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:  .__LOOPDO_1_END_:
; CHECK-NEXT:    goto .LBB1_9
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB1_8:
; CHECK-NEXT:    make $r0 = 0
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:  .LBB1_9: # %for.cond.cleanup
; CHECK-NEXT:    addd $r12 = $r14, -16
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ld $r14 = 16[$r12]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    ld $r16 = 24[$r12]
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 32
; CHECK-NEXT:    ;; # (end cycle 6)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %mul = shl nsw i32 %num, 2
  %conv = sext i32 %mul to i64
  %0 = alloca i8, i64 %conv, align 8
  %1 = bitcast i8* %0 to i32*
  %cmp6.i = icmp eq i32 %num, 0
  br i1 %cmp6.i, label %for.cond.cleanup, label %for.body.preheader.i

for.body.preheader.i:
  %2 = zext i32 %num to i64
  br label %for.body.i

for.body.i:
  %indvars.iv.i = phi i64 [ 0, %for.body.preheader.i ], [ %indvars.iv.next.i, %for.body.i ]
  %3 = trunc i64 %indvars.iv.i to i32
  %mul.i = mul nsw i32 %3, %3
  %arrayidx.i = getelementptr inbounds i32, i32* %1, i64 %indvars.iv.i
  store i32 %mul.i, i32* %arrayidx.i, align 4
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %cmp.i = icmp eq i64 %indvars.iv.next.i, %2
  br i1 %cmp.i, label %set.exit, label %for.body.i

set.exit:
  %mul1 = shl nsw i32 %num, 3
  %conv2 = sext i32 %mul1 to i64
  %4 = alloca i8, i64 %conv2, align 8
  %5 = bitcast i8* %4 to i32*
  %mul3 = shl nsw i32 %num, 1
  %6 = zext i32 %mul3 to i64
  br label %for.body.i36

for.body.i36:
  %indvars.iv.i31 = phi i64 [ 0, %set.exit ], [ %indvars.iv.next.i34, %for.body.i36 ]
  %7 = trunc i64 %indvars.iv.i31 to i32
  %mul.i32 = mul nsw i32 %7, %7
  %arrayidx.i33 = getelementptr inbounds i32, i32* %5, i64 %indvars.iv.i31
  store i32 %mul.i32, i32* %arrayidx.i33, align 4
  %indvars.iv.next.i34 = add nuw nsw i64 %indvars.iv.i31, 1
  %cmp.i35 = icmp eq i64 %indvars.iv.next.i34, %6
  br i1 %cmp.i35, label %set.exit37, label %for.body.i36

set.exit37:
  br i1 %cmp6.i, label %for.cond.cleanup, label %for.body.preheader

for.body.preheader:
  %8 = sext i32 %num to i64
  %9 = zext i32 %num to i64
  br label %for.body

for.cond.cleanup:
  %sum.0.lcssa = phi i32 [ 0, %set.exit37 ], [ 0, %entry ], [ %add11, %for.body ]
  ret i32 %sum.0.lcssa

for.body:
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ]
  %sum.043 = phi i32 [ 0, %for.body.preheader ], [ %add11, %for.body ]
  %arrayidx = getelementptr inbounds i32, i32* %1, i64 %indvars.iv
  %10 = load i32, i32* %arrayidx, align 4
  %arrayidx6 = getelementptr inbounds i32, i32* %5, i64 %indvars.iv
  %11 = load i32, i32* %arrayidx6, align 4
  %12 = add nsw i64 %indvars.iv, %8
  %arrayidx9 = getelementptr inbounds i32, i32* %5, i64 %12
  %13 = load i32, i32* %arrayidx9, align 4
  %add = add i32 %10, %sum.043
  %add10 = add i32 %add, %11
  %add11 = add i32 %add10, %13
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %cmp = icmp eq i64 %indvars.iv.next, %9
  br i1 %cmp, label %for.cond.cleanup, label %for.body
}
