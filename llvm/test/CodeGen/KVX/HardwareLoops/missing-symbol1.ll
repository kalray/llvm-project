; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -disable-kvx-hwloops=false -O2 -o - %s | FileCheck %s

target triple = "kvx-kalray-cos"

@.str = private unnamed_addr constant [25 x i8] c"LAO Kernels - fircirc   \00", align 1
@x = common global [256 x i16] zeroinitializer, align 2
@h = common global [16 x i16] zeroinitializer, align 2
@y = common global [256 x i16] zeroinitializer, align 2

define void @InitDataSet(i32 %m, ptr %x, i32 %n, ptr %h) {
; CHECK-LABEL: InitDataSet:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cb.wlez $r0 ? .LBB0_4
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.1: # %for.body.preheader
; CHECK-NEXT:    make $r4 = 0
; CHECK-NEXT:    zxwd $r5 = $r0
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    loopdo $r5, .__LOOPDO_5_END_
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_2: # %for.body
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    sh.xs $r4[$r1] = $r4
; CHECK-NEXT:    addd $r4 = $r4, 1
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:  .__LOOPDO_5_END_:
; CHECK-NEXT:  # %bb.3: # %for.cond1.preheader
; CHECK-NEXT:    compw.gtu $r4 = $r0, 255
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    cb.even $r4 ? .LBB0_5
; CHECK-NEXT:    ;;
; CHECK-NEXT:    goto .LBB0_12
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_4:
; CHECK-NEXT:    make $r0 = 0
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:  .LBB0_5: # %for.body4.preheader
; CHECK-NEXT:    zxwd $r4 = $r0
; CHECK-NEXT:    compw.ne $r5 = $r0, 255
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    cb.even $r5 ? .LBB0_10
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.6: # %vector.ph
; CHECK-NEXT:    sbfuwd $r5 = $r0, 256
; CHECK-NEXT:    make $r7 = 0xffffffffdeaddead
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    andd $r0 = $r5, 510
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    addd $r6 = $r0, -2
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    srld $r6 = $r6, 1
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    addx2d $r6 = $r4, $r1
; CHECK-NEXT:    addd $r8 = $r6, 1
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    loopdo $r8, .__LOOPDO_4_END_
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_7: # %vector.body
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    sw 0[$r6] = $r7
; CHECK-NEXT:    addd $r6 = $r6, 4
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:  .__LOOPDO_4_END_:
; CHECK-NEXT:  # %bb.8: # %middle.block
; CHECK-NEXT:    compd.eq $r5 = $r5, $r0
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    cb.odd $r5 ? .LBB0_12
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.9:
; CHECK-NEXT:    adduwd $r4 = $r4, $r0
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:  .LBB0_10: # %for.body4.preheader87
; CHECK-NEXT:    maxud $r0 = $r4, 255
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sbfd $r0 = $r4, $r0
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    addx2d $r0 = $r4, $r1
; CHECK-NEXT:    make $r1 = 0xdead
; CHECK-NEXT:    addd $r5 = $r0, 1
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    loopdo $r5, .__LOOPDO_3_END_
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_11: # %for.body4
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    sh 0[$r0] = $r1
; CHECK-NEXT:    addd $r0 = $r0, 2
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:  .__LOOPDO_3_END_:
; CHECK-NEXT:  .LBB0_12: # %for.cond10.preheader
; CHECK-NEXT:    cb.wlez $r2 ? .LBB0_16
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.13: # %for.body13.preheader
; CHECK-NEXT:    zxwd $r0 = $r2
; CHECK-NEXT:    make $r1 = 0
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    loopdo $r0, .__LOOPDO_2_END_
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_14: # %for.body13
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    mulw $r4 = $r1, $r1
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sh.xs $r1[$r3] = $r4
; CHECK-NEXT:    addd $r1 = $r1, 1
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:  .__LOOPDO_2_END_:
; CHECK-NEXT:  # %bb.15: # %for.cond20.preheader
; CHECK-NEXT:    compw.gtu $r0 = $r0, 15
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    cb.even $r0 ? .LBB0_17
; CHECK-NEXT:    ;;
; CHECK-NEXT:    goto .LBB0_24
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_16:
; CHECK-NEXT:    make $r2 = 0
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:  .LBB0_17: # %for.body23.preheader
; CHECK-NEXT:    zxwd $r0 = $r2
; CHECK-NEXT:    compw.ne $r1 = $r2, 15
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    cb.even $r1 ? .LBB0_22
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.18: # %vector.ph74
; CHECK-NEXT:    sbfuwd $r2 = $r2, 16
; CHECK-NEXT:    make $r5 = 0xffffffffbeefbeef
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    andd $r1 = $r2, 30
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    addd $r4 = $r1, -2
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    srld $r4 = $r4, 1
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    addx2d $r4 = $r0, $r3
; CHECK-NEXT:    addd $r6 = $r4, 1
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    loopdo $r6, .__LOOPDO_1_END_
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_19: # %vector.body71
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    sw 0[$r4] = $r5
; CHECK-NEXT:    addd $r4 = $r4, 4
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:  .__LOOPDO_1_END_:
; CHECK-NEXT:  # %bb.20: # %middle.block69
; CHECK-NEXT:    compd.eq $r2 = $r2, $r1
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    cb.odd $r2 ? .LBB0_24
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.21:
; CHECK-NEXT:    adduwd $r0 = $r0, $r1
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:  .LBB0_22: # %for.body23.preheader86
; CHECK-NEXT:    maxud $r1 = $r0, 15
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    addx2d $r0 = $r0, $r3
; CHECK-NEXT:    sbfd $r1 = $r0, $r1
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    make $r1 = 0xbeef
; CHECK-NEXT:    addd $r2 = $r1, 1
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    loopdo $r2, .__LOOPDO_0_END_
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_23: # %for.body23
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    sh 0[$r0] = $r1
; CHECK-NEXT:    addd $r0 = $r0, 2
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:  .__LOOPDO_0_END_:
; CHECK-NEXT:  .LBB0_24: # %for.end28
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %cmp52 = icmp sgt i32 %m, 0
  br i1 %cmp52, label %for.body.preheader, label %for.body4.preheader

for.body.preheader:
  %wide.trip.count61 = zext nneg i32 %m to i64
  br label %for.body

for.cond1.preheader:
  %cmp250 = icmp ult i32 %m, 256
  br i1 %cmp250, label %for.body4.preheader, label %for.cond10.preheader

for.body4.preheader:
  %i.0.lcssa65 = phi i32 [ %m, %for.cond1.preheader ], [ 0, %entry ]
  %0 = zext nneg i32 %i.0.lcssa65 to i64
  %1 = sub nuw nsw i64 256, %0
  %min.iters.check = icmp eq i32 %i.0.lcssa65, 255
  br i1 %min.iters.check, label %for.body4.preheader87, label %vector.ph

for.body4.preheader87:
  %indvars.iv57.ph = phi i64 [ %0, %for.body4.preheader ], [ %ind.end, %middle.block ]
  %umax = tail call i64 @llvm.umax.i64(i64 %indvars.iv57.ph, i64 255)
  br label %for.body4

vector.ph:
  %n.vec = and i64 %1, 510
  %invariant.gep = getelementptr i16, ptr %x, i64 %0
  br label %vector.body

vector.body:
  %index = phi i64 [ 0, %vector.ph ], [ %index.next, %vector.body ]
  %gep = getelementptr i16, ptr %invariant.gep, i64 %index
  store <2 x i16> <i16 -8531, i16 -8531>, ptr %gep, align 2
  %index.next = add i64 %index, 2
  %2 = icmp eq i64 %index.next, %n.vec
  br i1 %2, label %middle.block, label %vector.body

middle.block:
  %ind.end = add nuw nsw i64 %n.vec, %0
  %cmp.n = icmp eq i64 %1, %n.vec
  br i1 %cmp.n, label %for.cond10.preheader, label %for.body4.preheader87

for.body:
  %indvars.iv59 = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next60, %for.body ]
  %conv = trunc i64 %indvars.iv59 to i16
  %arrayidx = getelementptr inbounds i16, ptr %x, i64 %indvars.iv59
  store i16 %conv, ptr %arrayidx, align 2
  %indvars.iv.next60 = add nuw nsw i64 %indvars.iv59, 1
  %exitcond62 = icmp eq i64 %indvars.iv.next60, %wide.trip.count61
  br i1 %exitcond62, label %for.cond1.preheader, label %for.body

for.cond10.preheader:
  %cmp1148 = icmp sgt i32 %n, 0
  br i1 %cmp1148, label %for.body13.preheader, label %for.body23.preheader

for.body13.preheader:
  %wide.trip.count = zext nneg i32 %n to i64
  br label %for.body13

for.body4:
  %indvars.iv57 = phi i64 [ %indvars.iv.next58, %for.body4 ], [ %indvars.iv57.ph, %for.body4.preheader87 ]
  %arrayidx6 = getelementptr inbounds i16, ptr %x, i64 %indvars.iv57
  store i16 -8531, ptr %arrayidx6, align 2
  %indvars.iv.next58 = add nuw nsw i64 %indvars.iv57, 1
  %exitcond4.not = icmp eq i64 %indvars.iv57, %umax
  br i1 %exitcond4.not, label %for.cond10.preheader, label %for.body4

for.cond20.preheader:
  %cmp2146 = icmp ult i32 %n, 16
  br i1 %cmp2146, label %for.body23.preheader, label %for.end28

for.body23.preheader:
  %i.2.lcssa68 = phi i32 [ %n, %for.cond20.preheader ], [ 0, %for.cond10.preheader ]
  %3 = zext nneg i32 %i.2.lcssa68 to i64
  %4 = sub nuw nsw i64 16, %3
  %min.iters.check73 = icmp eq i32 %i.2.lcssa68, 15
  br i1 %min.iters.check73, label %for.body23.preheader86, label %vector.ph74

for.body23.preheader86:
  %indvars.iv.ph = phi i64 [ %3, %for.body23.preheader ], [ %ind.end80, %middle.block69 ]
  %umax5 = tail call i64 @llvm.umax.i64(i64 %indvars.iv.ph, i64 15)
  br label %for.body23

vector.ph74:
  %n.vec76 = and i64 %4, 30
  %invariant.gep2 = getelementptr i16, ptr %h, i64 %3
  br label %vector.body71

vector.body71:
  %index77 = phi i64 [ 0, %vector.ph74 ], [ %index.next78, %vector.body71 ]
  %gep3 = getelementptr i16, ptr %invariant.gep2, i64 %index77
  store <2 x i16> <i16 -16657, i16 -16657>, ptr %gep3, align 2
  %index.next78 = add i64 %index77, 2
  %5 = icmp eq i64 %index.next78, %n.vec76
  br i1 %5, label %middle.block69, label %vector.body71

middle.block69:
  %ind.end80 = add nuw nsw i64 %n.vec76, %3
  %cmp.n81 = icmp eq i64 %4, %n.vec76
  br i1 %cmp.n81, label %for.end28, label %for.body23.preheader86

for.body13:
  %indvars.iv55 = phi i64 [ 0, %for.body13.preheader ], [ %indvars.iv.next56, %for.body13 ]
  %6 = trunc i64 %indvars.iv55 to i32
  %mul = mul nsw i32 %6, %6
  %conv14 = trunc i32 %mul to i16
  %arrayidx16 = getelementptr inbounds i16, ptr %h, i64 %indvars.iv55
  store i16 %conv14, ptr %arrayidx16, align 2
  %indvars.iv.next56 = add nuw nsw i64 %indvars.iv55, 1
  %exitcond = icmp eq i64 %indvars.iv.next56, %wide.trip.count
  br i1 %exitcond, label %for.cond20.preheader, label %for.body13

for.body23:
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body23 ], [ %indvars.iv.ph, %for.body23.preheader86 ]
  %arrayidx25 = getelementptr inbounds i16, ptr %h, i64 %indvars.iv
  store i16 -16657, ptr %arrayidx25, align 2
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond6.not = icmp eq i64 %indvars.iv, %umax5
  br i1 %exitcond6.not, label %for.end28, label %for.body23

for.end28:
  ret void
}

define i32 @main(i32 %argc, ptr readnone %argv) {
; CHECK-LABEL: main:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    make $r0 = .L.str
; CHECK-NEXT:    addd $r12 = $r12, -128
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 120[$r12] = $r16
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    so 88[$r12] = $r28r29r30r31
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    so 56[$r12] = $r24r25r26r27
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    so 24[$r12] = $r20r21r22r23
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    sq 8[$r12] = $r18r19
; CHECK-NEXT:    call BENCH_START
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    addd $r18 = $r12, 5
; CHECK-NEXT:    make $r21 = 0
; CHECK-NEXT:    make $r22 = 256
; CHECK-NEXT:    make $r23 = x
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    make $r24 = 0xffffffffdeaddead
; CHECK-NEXT:    make $r25 = h
; CHECK-NEXT:    make $r29 = 144
; CHECK-NEXT:    make $r30 = 169
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    make $r20 = 225
; CHECK-NEXT:    make $r26 = 0xdead
; CHECK-NEXT:    make $r27 = x
; CHECK-NEXT:    make $r31 = 196
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    make $r19 = 0
; CHECK-NEXT:    make $r28 = 1
; CHECK-NEXT:    goto .LBB1_2
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:  .LBB1_1: # %for.cond10.preheader.i
; CHECK-NEXT:    # in Loop: Header=BB1_2 Depth=1
; CHECK-NEXT:    sh 0[$r25] = $r21
; CHECK-NEXT:    make $r0 = 1
; CHECK-NEXT:    make $r1 = x
; CHECK-NEXT:    make $r6 = 1
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sh 2[$r25] = $r0
; CHECK-NEXT:    make $r0 = 4
; CHECK-NEXT:    make $r2 = 16
; CHECK-NEXT:    make $r3 = h
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    sh 4[$r25] = $r0
; CHECK-NEXT:    make $r0 = 9
; CHECK-NEXT:    make $r4 = 1
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    sh 6[$r25] = $r0
; CHECK-NEXT:    make $r0 = 16
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    sh 8[$r25] = $r0
; CHECK-NEXT:    make $r0 = 25
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    sh 10[$r25] = $r0
; CHECK-NEXT:    make $r0 = 36
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    sh 12[$r25] = $r0
; CHECK-NEXT:    make $r0 = 49
; CHECK-NEXT:    ;; # (end cycle 6)
; CHECK-NEXT:    sh 14[$r25] = $r0
; CHECK-NEXT:    make $r0 = 64
; CHECK-NEXT:    ;; # (end cycle 7)
; CHECK-NEXT:    sh 16[$r25] = $r0
; CHECK-NEXT:    make $r0 = 81
; CHECK-NEXT:    ;; # (end cycle 8)
; CHECK-NEXT:    sh 18[$r25] = $r0
; CHECK-NEXT:    make $r0 = 100
; CHECK-NEXT:    ;; # (end cycle 9)
; CHECK-NEXT:    sh 20[$r25] = $r0
; CHECK-NEXT:    make $r0 = 121
; CHECK-NEXT:    ;; # (end cycle 10)
; CHECK-NEXT:    sh 22[$r25] = $r0
; CHECK-NEXT:    compd.ltu $r0 = $r19, 4
; CHECK-NEXT:    ;; # (end cycle 11)
; CHECK-NEXT:    sh 24[$r25] = $r29
; CHECK-NEXT:    make $r0 = y
; CHECK-NEXT:    cmoved.even $r0 ? $r6 = 2
; CHECK-NEXT:    ;; # (end cycle 12)
; CHECK-NEXT:    sh 26[$r25] = $r30
; CHECK-NEXT:    ;; # (end cycle 13)
; CHECK-NEXT:    sh 28[$r25] = $r31
; CHECK-NEXT:    ;; # (end cycle 14)
; CHECK-NEXT:    sh 30[$r25] = $r20
; CHECK-NEXT:    copyd $r5 = $r19
; CHECK-NEXT:    copyd $r7 = $r19
; CHECK-NEXT:    call fircirc
; CHECK-NEXT:    ;; # (end cycle 15)
; CHECK-NEXT:    make $r0 = .L.str
; CHECK-NEXT:    call BENCH_STOP
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    addd $r19 = $r19, 1
; CHECK-NEXT:    addd $r22 = $r22, -1
; CHECK-NEXT:    addd $r27 = $r27, 2
; CHECK-NEXT:    addw $r28 = $r28, 1
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    compd.ne $r0 = $r19, 8
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    cb.even $r0 ? .LBB1_10
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB1_2: # %if.end
; CHECK-NEXT:    # =>This Loop Header: Depth=1
; CHECK-NEXT:    # Child Loop BB1_4 Depth 2
; CHECK-NEXT:    # Child Loop BB1_6 Depth 2
; CHECK-NEXT:    # Child Loop BB1_9 Depth 2
; CHECK-NEXT:    addw $r0 = $r28, 48
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sb 5[$r12] = $r0
; CHECK-NEXT:    make $r0 = .L.str
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    sb 6[$r12] = $r21
; CHECK-NEXT:    copyd $r1 = $r18
; CHECK-NEXT:    call BENCH_START_S
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    cb.deqz $r19 ? .LBB1_5
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.3: # %for.body.i.preheader
; CHECK-NEXT:    # in Loop: Header=BB1_2 Depth=1
; CHECK-NEXT:    make $r0 = 0
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    loopdo $r19, .__LOOPDO_8_END_
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB1_4: # %for.body.i
; CHECK-NEXT:    # Parent Loop BB1_2 Depth=1
; CHECK-NEXT:    # => This Inner Loop Header: Depth=2
; CHECK-NEXT:    sh.xs $r0[$r23] = $r0
; CHECK-NEXT:    addd $r0 = $r0, 1
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:  .__LOOPDO_8_END_:
; CHECK-NEXT:  .LBB1_5: # %vector.ph
; CHECK-NEXT:    # in Loop: Header=BB1_2 Depth=1
; CHECK-NEXT:    andd $r0 = $r22, -2
; CHECK-NEXT:    sbfd $r2 = $r19, 256
; CHECK-NEXT:    copyd $r4 = $r27
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    addd $r1 = $r0, -2
; CHECK-NEXT:    andd $r3 = $r2, 510
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    srld $r1 = $r1, 1
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    andd $r1 = $r22, 1
; CHECK-NEXT:    addd $r5 = $r1, 1
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    loopdo $r5, .__LOOPDO_9_END_
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB1_6: # %vector.body
; CHECK-NEXT:    # Parent Loop BB1_2 Depth=1
; CHECK-NEXT:    # => This Inner Loop Header: Depth=2
; CHECK-NEXT:    sw 0[$r4] = $r24
; CHECK-NEXT:    addd $r4 = $r4, 4
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:  .__LOOPDO_9_END_:
; CHECK-NEXT:  # %bb.7: # %middle.block
; CHECK-NEXT:    # in Loop: Header=BB1_2 Depth=1
; CHECK-NEXT:    compd.eq $r2 = $r2, $r3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    cb.odd $r2 ? .LBB1_1
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.8: # %for.body4.i.preheader
; CHECK-NEXT:    # in Loop: Header=BB1_2 Depth=1
; CHECK-NEXT:    loopdo $r1, .__LOOPDO_10_END_
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB1_9: # %for.body4.i
; CHECK-NEXT:    # Parent Loop BB1_2 Depth=1
; CHECK-NEXT:    # => This Inner Loop Header: Depth=2
; CHECK-NEXT:    sh.xs $r0[$r27] = $r26
; CHECK-NEXT:    addd $r0 = $r0, 1
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:  .__LOOPDO_10_END_:
; CHECK-NEXT:    goto .LBB1_1
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB1_10: # %for.body19.preheader
; CHECK-NEXT:    make $r18 = 8
; CHECK-NEXT:    addd $r19 = $r12, 5
; CHECK-NEXT:    make $r22 = 0
; CHECK-NEXT:    make $r23 = x
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    make $r24 = 0xffffffffdeaddead
; CHECK-NEXT:    make $r25 = h
; CHECK-NEXT:    make $r28 = 169
; CHECK-NEXT:    make $r29 = 196
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    make $r20 = 16
; CHECK-NEXT:    make $r21 = 9
; CHECK-NEXT:    make $r30 = 225
; CHECK-NEXT:    make $r31 = 0
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:  .LBB1_11: # %for.body19
; CHECK-NEXT:    # =>This Loop Header: Depth=1
; CHECK-NEXT:    # Child Loop BB1_12 Depth 2
; CHECK-NEXT:    # Child Loop BB1_14 Depth 2
; CHECK-NEXT:    muluwd $r0 = $r21, 0xcccccccd
; CHECK-NEXT:    compw.gtu $r1 = $r21, 9
; CHECK-NEXT:    copyd $r2 = $r21
; CHECK-NEXT:    slld $r3 = $r31, 5
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    srld $r0 = $r0, 32
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    srlw $r0 = $r0, 3
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    sbfd $r0 = $r3, 492
; CHECK-NEXT:    cmoved.wnez $r1 ? $r2 = $r0
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    srld $r0 = $r0, 2
; CHECK-NEXT:    addw $r1 = $r2, 48
; CHECK-NEXT:    slld $r2 = $r31, 4
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    sb 5[$r12] = $r1
; CHECK-NEXT:    make $r0 = .L.str
; CHECK-NEXT:    addd $r26 = $r0, 1
; CHECK-NEXT:    iord $r27 = $r2, 8
; CHECK-NEXT:    ;; # (end cycle 6)
; CHECK-NEXT:    sb 6[$r12] = $r22
; CHECK-NEXT:    copyd $r1 = $r19
; CHECK-NEXT:    call BENCH_START_S
; CHECK-NEXT:    ;; # (end cycle 7)
; CHECK-NEXT:    make $r0 = 0
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    loopdo $r27, .__LOOPDO_6_END_
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB1_12: # %for.body.i87
; CHECK-NEXT:    # Parent Loop BB1_11 Depth=1
; CHECK-NEXT:    # => This Inner Loop Header: Depth=2
; CHECK-NEXT:    sh.xs $r0[$r23] = $r0
; CHECK-NEXT:    addd $r0 = $r0, 1
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:  .__LOOPDO_6_END_:
; CHECK-NEXT:  # %bb.13: # %vector.body116.preheader
; CHECK-NEXT:    # in Loop: Header=BB1_11 Depth=1
; CHECK-NEXT:    copyd $r0 = $r20
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    loopdo $r26, .__LOOPDO_7_END_
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB1_14: # %vector.body116
; CHECK-NEXT:    # Parent Loop BB1_11 Depth=1
; CHECK-NEXT:    # => This Inner Loop Header: Depth=2
; CHECK-NEXT:    sw $r0[$r23] = $r24
; CHECK-NEXT:    addd $r0 = $r0, 4
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:  .__LOOPDO_7_END_:
; CHECK-NEXT:  # %bb.15: # %for.cond10.preheader.i88
; CHECK-NEXT:    # in Loop: Header=BB1_11 Depth=1
; CHECK-NEXT:    sh 0[$r25] = $r22
; CHECK-NEXT:    make $r0 = 1
; CHECK-NEXT:    make $r1 = x
; CHECK-NEXT:    srlw $r6 = $r18, 3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sh 2[$r25] = $r0
; CHECK-NEXT:    make $r0 = 4
; CHECK-NEXT:    make $r2 = 16
; CHECK-NEXT:    make $r3 = h
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    sh 4[$r25] = $r0
; CHECK-NEXT:    make $r0 = 9
; CHECK-NEXT:    make $r4 = 1
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    sh 6[$r25] = $r0
; CHECK-NEXT:    make $r0 = 16
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    sh 8[$r25] = $r0
; CHECK-NEXT:    make $r0 = 25
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    sh 10[$r25] = $r0
; CHECK-NEXT:    make $r0 = 36
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    sh 12[$r25] = $r0
; CHECK-NEXT:    make $r0 = 49
; CHECK-NEXT:    ;; # (end cycle 6)
; CHECK-NEXT:    sh 14[$r25] = $r0
; CHECK-NEXT:    make $r0 = 64
; CHECK-NEXT:    ;; # (end cycle 7)
; CHECK-NEXT:    sh 16[$r25] = $r0
; CHECK-NEXT:    make $r0 = 81
; CHECK-NEXT:    ;; # (end cycle 8)
; CHECK-NEXT:    sh 18[$r25] = $r0
; CHECK-NEXT:    make $r0 = 100
; CHECK-NEXT:    ;; # (end cycle 9)
; CHECK-NEXT:    sh 20[$r25] = $r0
; CHECK-NEXT:    make $r0 = 121
; CHECK-NEXT:    ;; # (end cycle 10)
; CHECK-NEXT:    sh 22[$r25] = $r0
; CHECK-NEXT:    make $r0 = 144
; CHECK-NEXT:    ;; # (end cycle 11)
; CHECK-NEXT:    sh 24[$r25] = $r0
; CHECK-NEXT:    make $r0 = y
; CHECK-NEXT:    ;; # (end cycle 12)
; CHECK-NEXT:    sh 26[$r25] = $r28
; CHECK-NEXT:    ;; # (end cycle 13)
; CHECK-NEXT:    sh 28[$r25] = $r29
; CHECK-NEXT:    ;; # (end cycle 14)
; CHECK-NEXT:    sh 30[$r25] = $r30
; CHECK-NEXT:    copyd $r5 = $r18
; CHECK-NEXT:    copyd $r7 = $r18
; CHECK-NEXT:    call fircirc
; CHECK-NEXT:    ;; # (end cycle 15)
; CHECK-NEXT:    make $r0 = .L.str
; CHECK-NEXT:    call BENCH_STOP
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    addd $r18 = $r18, 16
; CHECK-NEXT:    addd $r20 = $r20, 32
; CHECK-NEXT:    addw $r21 = $r21, 1
; CHECK-NEXT:    addd $r31 = $r31, 1
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    compw.ne $r0 = $r21, 13
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    cb.odd $r0 ? .LBB1_11
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.16: # %for.end42
; CHECK-NEXT:    make $r0 = 32
; CHECK-NEXT:    addd $r1 = $r12, 5
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sb 5[$r12] = $r0
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    sb 6[$r12] = $r0
; CHECK-NEXT:    make $r0 = 0
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    sb 7[$r12] = $r0
; CHECK-NEXT:    make $r0 = .L.str
; CHECK-NEXT:    call BENCH_STOP_S
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    lq $r18r19 = 8[$r12]
; CHECK-NEXT:    make $r0 = 0
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    lo $r20r21r22r23 = 24[$r12]
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    lo $r24r25r26r27 = 56[$r12]
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    lo $r28r29r30r31 = 88[$r12]
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    ld $r16 = 120[$r12]
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 128
; CHECK-NEXT:    ;; # (end cycle 9)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %str2 = alloca [3 x i8], align 1
  call void @llvm.lifetime.start.p0(i64 3, ptr nonnull %str2)
  tail call void @BENCH_START(ptr nonnull @.str)
  %arrayidx9 = getelementptr inbounds i8, ptr %str2, i64 1
  br label %if.end

if.end:
  %indvars.iv111 = phi i64 [ 0, %entry ], [ %indvars.iv.next112, %for.cond10.preheader.i ]
  %j.0105 = phi i32 [ 1, %entry ], [ %inc, %for.cond10.preheader.i ]
  %0 = sub nuw nsw i64 256, %indvars.iv111
  %1 = trunc i32 %j.0105 to i8
  %conv7 = add nuw nsw i8 %1, 48
  store i8 %conv7, ptr %str2, align 1
  store i8 0, ptr %arrayidx9, align 1
  call void @BENCH_START_S(ptr nonnull @.str, ptr nonnull %str2)
  %cmp52.i = icmp eq i64 %indvars.iv111, 0
  br i1 %cmp52.i, label %vector.ph, label %for.body.i

for.body4.i.preheader:
  %ind.end = add i64 %n.vec, %indvars.iv111
  br label %for.body4.i

vector.ph:
  %n.vec = and i64 %0, -2
  br label %vector.body

vector.body:
  %index = phi i64 [ 0, %vector.ph ], [ %index.next, %vector.body ]
  %offset.idx = add nuw nsw i64 %index, %indvars.iv111
  %2 = getelementptr inbounds [256 x i16], ptr @x, i64 0, i64 %offset.idx
  store <2 x i16> <i16 -8531, i16 -8531>, ptr %2, align 2
  %index.next = add nuw nsw i64 %index, 2
  %3 = icmp eq i64 %index.next, %n.vec
  br i1 %3, label %middle.block, label %vector.body

middle.block:
  %cmp.n = icmp eq i64 %0, %n.vec
  br i1 %cmp.n, label %for.cond10.preheader.i, label %for.body4.i.preheader

for.body.i:
  %indvars.iv59.i = phi i64 [ %indvars.iv.next60.i, %for.body.i ], [ 0, %if.end ]
  %conv.i = trunc i64 %indvars.iv59.i to i16
  %arrayidx.i = getelementptr inbounds [256 x i16], ptr @x, i64 0, i64 %indvars.iv59.i
  store i16 %conv.i, ptr %arrayidx.i, align 2
  %indvars.iv.next60.i = add nuw nsw i64 %indvars.iv59.i, 1
  %exitcond62.i = icmp eq i64 %indvars.iv.next60.i, %indvars.iv111
  br i1 %exitcond62.i, label %vector.ph, label %for.body.i

for.cond10.preheader.i:
  store i16 0, ptr @h, align 2
  store i16 1, ptr getelementptr inbounds ([16 x i16], ptr @h, i64 0, i64 1), align 2
  store i16 4, ptr getelementptr inbounds ([16 x i16], ptr @h, i64 0, i64 2), align 2
  store i16 9, ptr getelementptr inbounds ([16 x i16], ptr @h, i64 0, i64 3), align 2
  store i16 16, ptr getelementptr inbounds ([16 x i16], ptr @h, i64 0, i64 4), align 2
  store i16 25, ptr getelementptr inbounds ([16 x i16], ptr @h, i64 0, i64 5), align 2
  store i16 36, ptr getelementptr inbounds ([16 x i16], ptr @h, i64 0, i64 6), align 2
  store i16 49, ptr getelementptr inbounds ([16 x i16], ptr @h, i64 0, i64 7), align 2
  store i16 64, ptr getelementptr inbounds ([16 x i16], ptr @h, i64 0, i64 8), align 2
  store i16 81, ptr getelementptr inbounds ([16 x i16], ptr @h, i64 0, i64 9), align 2
  store i16 100, ptr getelementptr inbounds ([16 x i16], ptr @h, i64 0, i64 10), align 2
  store i16 121, ptr getelementptr inbounds ([16 x i16], ptr @h, i64 0, i64 11), align 2
  store i16 144, ptr getelementptr inbounds ([16 x i16], ptr @h, i64 0, i64 12), align 2
  store i16 169, ptr getelementptr inbounds ([16 x i16], ptr @h, i64 0, i64 13), align 2
  store i16 196, ptr getelementptr inbounds ([16 x i16], ptr @h, i64 0, i64 14), align 2
  store i16 225, ptr getelementptr inbounds ([16 x i16], ptr @h, i64 0, i64 15), align 2
  %cmp10 = icmp ult i64 %indvars.iv111, 4
  %. = select i1 %cmp10, i32 1, i32 2
  %4 = trunc i64 %indvars.iv111 to i32
  call void @fircirc(ptr nonnull @y, ptr nonnull @x, i32 16, ptr nonnull @h, i32 1, i32 %4, i32 %., i32 %4)
  call void @BENCH_STOP(ptr nonnull @.str)
  %indvars.iv.next112 = add nuw nsw i64 %indvars.iv111, 1
  %inc = add nuw nsw i32 %j.0105, 1
  %exitcond113 = icmp eq i64 %indvars.iv.next112, 8
  br i1 %exitcond113, label %for.body19, label %if.end

for.body4.i:
  %indvars.iv57.i = phi i64 [ %indvars.iv.next58.i, %for.body4.i ], [ %ind.end, %for.body4.i.preheader ]
  %arrayidx6.i = getelementptr inbounds [256 x i16], ptr @x, i64 0, i64 %indvars.iv57.i
  store i16 -8531, ptr %arrayidx6.i, align 2
  %indvars.iv.next58.i = add nuw nsw i64 %indvars.iv57.i, 1
  %exitcond110 = icmp eq i64 %indvars.iv.next58.i, 256
  br i1 %exitcond110, label %for.cond10.preheader.i, label %for.body4.i

for.body19:
  %indvar = phi i64 [ %indvar.next, %for.cond10.preheader.i88 ], [ 0, %for.cond10.preheader.i ]
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.cond10.preheader.i88 ], [ 8, %for.cond10.preheader.i ]
  %j.1102 = phi i32 [ %inc41, %for.cond10.preheader.i88 ], [ 9, %for.cond10.preheader.i ]
  %indvars1 = trunc i64 %indvars.iv to i32
  %cmp20 = icmp ugt i32 %j.1102, 9
  %div23 = udiv i32 %j.1102, 10
  %storemerge.in.in = select i1 %cmp20, i32 %div23, i32 %j.1102
  %storemerge.in = trunc i32 %storemerge.in.in to i8
  %storemerge = add i8 %storemerge.in, 48
  store i8 %storemerge, ptr %str2, align 1
  store i8 0, ptr %arrayidx9, align 1
  call void @BENCH_START_S(ptr nonnull @.str, ptr nonnull %str2)
  br label %for.body.i87

for.body.i87:
  %indvars.iv59.i82 = phi i64 [ 0, %for.body19 ], [ %indvars.iv.next60.i85, %for.body.i87 ]
  %conv.i83 = trunc i64 %indvars.iv59.i82 to i16
  %arrayidx.i84 = getelementptr inbounds [256 x i16], ptr @x, i64 0, i64 %indvars.iv59.i82
  store i16 %conv.i83, ptr %arrayidx.i84, align 2
  %indvars.iv.next60.i85 = add nuw nsw i64 %indvars.iv59.i82, 1
  %exitcond62.i86 = icmp eq i64 %indvars.iv.next60.i85, %indvars.iv
  br i1 %exitcond62.i86, label %vector.body116.preheader, label %for.body.i87

vector.body116.preheader:
  %5 = shl i64 %indvar, 4
  %6 = sub nuw nsw i64 246, %5
  br label %vector.body116

vector.body116:
  %index121 = phi i64 [ %index.next122, %vector.body116 ], [ 0, %vector.body116.preheader ]
  %offset.idx126 = add nuw nsw i64 %index121, %indvars.iv
  %7 = getelementptr inbounds [256 x i16], ptr @x, i64 0, i64 %offset.idx126
  store <2 x i16> <i16 -8531, i16 -8531>, ptr %7, align 2
  %index.next122 = add nuw nsw i64 %index121, 2
  %8 = icmp eq i64 %index121, %6
  br i1 %8, label %for.cond10.preheader.i88, label %vector.body116

for.cond10.preheader.i88:
  store i16 0, ptr @h, align 2
  store i16 1, ptr getelementptr inbounds ([16 x i16], ptr @h, i64 0, i64 1), align 2
  store i16 4, ptr getelementptr inbounds ([16 x i16], ptr @h, i64 0, i64 2), align 2
  store i16 9, ptr getelementptr inbounds ([16 x i16], ptr @h, i64 0, i64 3), align 2
  store i16 16, ptr getelementptr inbounds ([16 x i16], ptr @h, i64 0, i64 4), align 2
  store i16 25, ptr getelementptr inbounds ([16 x i16], ptr @h, i64 0, i64 5), align 2
  store i16 36, ptr getelementptr inbounds ([16 x i16], ptr @h, i64 0, i64 6), align 2
  store i16 49, ptr getelementptr inbounds ([16 x i16], ptr @h, i64 0, i64 7), align 2
  store i16 64, ptr getelementptr inbounds ([16 x i16], ptr @h, i64 0, i64 8), align 2
  store i16 81, ptr getelementptr inbounds ([16 x i16], ptr @h, i64 0, i64 9), align 2
  store i16 100, ptr getelementptr inbounds ([16 x i16], ptr @h, i64 0, i64 10), align 2
  store i16 121, ptr getelementptr inbounds ([16 x i16], ptr @h, i64 0, i64 11), align 2
  store i16 144, ptr getelementptr inbounds ([16 x i16], ptr @h, i64 0, i64 12), align 2
  store i16 169, ptr getelementptr inbounds ([16 x i16], ptr @h, i64 0, i64 13), align 2
  store i16 196, ptr getelementptr inbounds ([16 x i16], ptr @h, i64 0, i64 14), align 2
  store i16 225, ptr getelementptr inbounds ([16 x i16], ptr @h, i64 0, i64 15), align 2
  %9 = lshr exact i32 %indvars1, 3
  %10 = trunc i64 %indvars.iv to i32
  call void @fircirc(ptr nonnull @y, ptr nonnull @x, i32 16, ptr nonnull @h, i32 1, i32 %10, i32 %9, i32 %10)
  call void @BENCH_STOP(ptr nonnull @.str)
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 16
  %inc41 = add nuw nsw i32 %j.1102, 1
  %exitcond109 = icmp eq i32 %inc41, 13
  %indvar.next = add nuw nsw i64 %indvar, 1
  br i1 %exitcond109, label %for.end42, label %for.body19

for.end42:
  %arrayidx5 = getelementptr inbounds i8, ptr %str2, i64 2
  store i8 32, ptr %str2, align 1
  store i8 32, ptr %arrayidx9, align 1
  store i8 0, ptr %arrayidx5, align 1
  call void @BENCH_STOP_S(ptr nonnull @.str, ptr nonnull %str2)
  call void @llvm.lifetime.end.p0(i64 3, ptr nonnull %str2)
  ret i32 0
}

declare void @BENCH_START(ptr) local_unnamed_addr

declare void @BENCH_START_S(ptr, ptr) local_unnamed_addr

declare void @fircirc(ptr, ptr, i32, ptr, i32, i32, i32, i32) local_unnamed_addr

declare void @BENCH_STOP(ptr) local_unnamed_addr

declare void @BENCH_STOP_S(ptr, ptr) local_unnamed_addr

declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture)

declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture)

declare i64 @llvm.umax.i64(i64, i64)

