; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -disable-kvx-hwloops=false -O2 -o - %s | FileCheck %s
; RUN: clang -mllvm -disable-kvx-hwloops=false -O2 -c -o /dev/null %s
; This test is for all the backend, and not just the kvx-hwloops, as the BB
; generated by it gets deleted by simplify cfg.
; T14744

target triple = "kvx-kalray-cos"

@x = common global [256 x i16] zeroinitializer, align 2
@y = common global [256 x i16] zeroinitializer, align 2
@h = common global [16 x i16] zeroinitializer, align 2
@a = common global i32 0, align 4
@b = common global i32 0, align 4

define void @InitDataSet(i32 %m, ptr %x, i32 %n, ptr %h) {
; CHECK-LABEL: InitDataSet:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cb.wlez $r0 ? .LBB0_4
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.1: # %for.body.preheader
; CHECK-NEXT:    make $r4 = 0
; CHECK-NEXT:    zxwd $r5 = $r0
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    loopdo $r5, .__LOOPDO_5_END_
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_2: # %for.body
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    sh.xs $r4[$r1] = $r4
; CHECK-NEXT:    addd $r4 = $r4, 1
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:  .__LOOPDO_5_END_:
; CHECK-NEXT:  # %bb.3: # %for.cond1.preheader
; CHECK-NEXT:    compw.gtu $r4 = $r0, 255
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    cb.even $r4 ? .LBB0_5
; CHECK-NEXT:    ;;
; CHECK-NEXT:    goto .LBB0_12
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_4:
; CHECK-NEXT:    make $r0 = 0
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:  .LBB0_5: # %for.body4.preheader
; CHECK-NEXT:    zxwd $r4 = $r0
; CHECK-NEXT:    compw.ne $r5 = $r0, 255
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    cb.even $r5 ? .LBB0_10
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.6: # %vector.ph
; CHECK-NEXT:    sbfuwd $r5 = $r0, 256
; CHECK-NEXT:    make $r7 = 0xffffffffdeaddead
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    andd $r0 = $r5, 510
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    addd $r6 = $r0, -2
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    srld $r6 = $r6, 1
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    addx2d $r6 = $r4, $r1
; CHECK-NEXT:    addd $r8 = $r6, 1
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    loopdo $r8, .__LOOPDO_4_END_
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_7: # %vector.body
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    sw 0[$r6] = $r7
; CHECK-NEXT:    addd $r6 = $r6, 4
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:  .__LOOPDO_4_END_:
; CHECK-NEXT:  # %bb.8: # %middle.block
; CHECK-NEXT:    compd.eq $r5 = $r5, $r0
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    cb.odd $r5 ? .LBB0_12
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.9:
; CHECK-NEXT:    adduwd $r4 = $r4, $r0
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:  .LBB0_10: # %for.body4.preheader87
; CHECK-NEXT:    maxud $r0 = $r4, 255
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sbfd $r0 = $r4, $r0
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    addx2d $r0 = $r4, $r1
; CHECK-NEXT:    make $r1 = 0xdead
; CHECK-NEXT:    addd $r5 = $r0, 1
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    loopdo $r5, .__LOOPDO_3_END_
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_11: # %for.body4
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    sh 0[$r0] = $r1
; CHECK-NEXT:    addd $r0 = $r0, 2
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:  .__LOOPDO_3_END_:
; CHECK-NEXT:  .LBB0_12: # %for.cond10.preheader
; CHECK-NEXT:    cb.wlez $r2 ? .LBB0_16
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.13: # %for.body13.preheader
; CHECK-NEXT:    zxwd $r0 = $r2
; CHECK-NEXT:    make $r1 = 0
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    loopdo $r0, .__LOOPDO_2_END_
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_14: # %for.body13
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    mulw $r4 = $r1, $r1
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sh.xs $r1[$r3] = $r4
; CHECK-NEXT:    addd $r1 = $r1, 1
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:  .__LOOPDO_2_END_:
; CHECK-NEXT:  # %bb.15: # %for.cond20.preheader
; CHECK-NEXT:    compw.gtu $r0 = $r0, 15
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    cb.even $r0 ? .LBB0_17
; CHECK-NEXT:    ;;
; CHECK-NEXT:    goto .LBB0_24
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_16:
; CHECK-NEXT:    make $r2 = 0
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:  .LBB0_17: # %for.body23.preheader
; CHECK-NEXT:    zxwd $r0 = $r2
; CHECK-NEXT:    compw.ne $r1 = $r2, 15
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    cb.even $r1 ? .LBB0_22
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.18: # %vector.ph74
; CHECK-NEXT:    sbfuwd $r2 = $r2, 16
; CHECK-NEXT:    make $r5 = 0xffffffffbeefbeef
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    andd $r1 = $r2, 30
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    addd $r4 = $r1, -2
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    srld $r4 = $r4, 1
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    addx2d $r4 = $r0, $r3
; CHECK-NEXT:    addd $r6 = $r4, 1
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    loopdo $r6, .__LOOPDO_1_END_
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_19: # %vector.body71
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    sw 0[$r4] = $r5
; CHECK-NEXT:    addd $r4 = $r4, 4
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:  .__LOOPDO_1_END_:
; CHECK-NEXT:  # %bb.20: # %middle.block69
; CHECK-NEXT:    compd.eq $r2 = $r2, $r1
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    cb.odd $r2 ? .LBB0_24
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.21:
; CHECK-NEXT:    adduwd $r0 = $r0, $r1
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:  .LBB0_22: # %for.body23.preheader86
; CHECK-NEXT:    maxud $r1 = $r0, 15
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    addx2d $r0 = $r0, $r3
; CHECK-NEXT:    sbfd $r1 = $r0, $r1
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    make $r1 = 0xbeef
; CHECK-NEXT:    addd $r2 = $r1, 1
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    loopdo $r2, .__LOOPDO_0_END_
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_23: # %for.body23
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    sh 0[$r0] = $r1
; CHECK-NEXT:    addd $r0 = $r0, 2
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:  .__LOOPDO_0_END_:
; CHECK-NEXT:  .LBB0_24: # %for.end28
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %cmp52 = icmp sgt i32 %m, 0
  br i1 %cmp52, label %for.body.preheader, label %for.body4.preheader

for.body.preheader:
  %wide.trip.count61 = zext nneg i32 %m to i64
  br label %for.body

for.cond1.preheader:
  %cmp250 = icmp ult i32 %m, 256
  br i1 %cmp250, label %for.body4.preheader, label %for.cond10.preheader

for.body4.preheader:
  %i.0.lcssa65 = phi i32 [ %m, %for.cond1.preheader ], [ 0, %entry ]
  %0 = zext nneg i32 %i.0.lcssa65 to i64
  %1 = sub nuw nsw i64 256, %0
  %min.iters.check = icmp eq i32 %i.0.lcssa65, 255
  br i1 %min.iters.check, label %for.body4.preheader87, label %vector.ph

for.body4.preheader87:
  %indvars.iv57.ph = phi i64 [ %0, %for.body4.preheader ], [ %ind.end, %middle.block ]
  %umax = tail call i64 @llvm.umax.i64(i64 %indvars.iv57.ph, i64 255)
  br label %for.body4

vector.ph:
  %n.vec = and i64 %1, 510
  %invariant.gep = getelementptr i16, ptr %x, i64 %0
  br label %vector.body

vector.body:
  %index = phi i64 [ 0, %vector.ph ], [ %index.next, %vector.body ]
  %gep = getelementptr i16, ptr %invariant.gep, i64 %index
  store <2 x i16> <i16 -8531, i16 -8531>, ptr %gep, align 2
  %index.next = add i64 %index, 2
  %2 = icmp eq i64 %index.next, %n.vec
  br i1 %2, label %middle.block, label %vector.body

middle.block:
  %ind.end = add nuw nsw i64 %n.vec, %0
  %cmp.n = icmp eq i64 %1, %n.vec
  br i1 %cmp.n, label %for.cond10.preheader, label %for.body4.preheader87

for.body:
  %indvars.iv59 = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next60, %for.body ]
  %conv = trunc i64 %indvars.iv59 to i16
  %arrayidx = getelementptr inbounds i16, ptr %x, i64 %indvars.iv59
  store i16 %conv, ptr %arrayidx, align 2
  %indvars.iv.next60 = add nuw nsw i64 %indvars.iv59, 1
  %exitcond62 = icmp eq i64 %indvars.iv.next60, %wide.trip.count61
  br i1 %exitcond62, label %for.cond1.preheader, label %for.body

for.cond10.preheader:
  %cmp1148 = icmp sgt i32 %n, 0
  br i1 %cmp1148, label %for.body13.preheader, label %for.body23.preheader

for.body13.preheader:
  %wide.trip.count = zext nneg i32 %n to i64
  br label %for.body13

for.body4:
  %indvars.iv57 = phi i64 [ %indvars.iv.next58, %for.body4 ], [ %indvars.iv57.ph, %for.body4.preheader87 ]
  %arrayidx6 = getelementptr inbounds i16, ptr %x, i64 %indvars.iv57
  store i16 -8531, ptr %arrayidx6, align 2
  %indvars.iv.next58 = add nuw nsw i64 %indvars.iv57, 1
  %exitcond4.not = icmp eq i64 %indvars.iv57, %umax
  br i1 %exitcond4.not, label %for.cond10.preheader, label %for.body4

for.cond20.preheader:
  %cmp2146 = icmp ult i32 %n, 16
  br i1 %cmp2146, label %for.body23.preheader, label %for.end28

for.body23.preheader:
  %i.2.lcssa68 = phi i32 [ %n, %for.cond20.preheader ], [ 0, %for.cond10.preheader ]
  %3 = zext nneg i32 %i.2.lcssa68 to i64
  %4 = sub nuw nsw i64 16, %3
  %min.iters.check73 = icmp eq i32 %i.2.lcssa68, 15
  br i1 %min.iters.check73, label %for.body23.preheader86, label %vector.ph74

for.body23.preheader86:
  %indvars.iv.ph = phi i64 [ %3, %for.body23.preheader ], [ %ind.end80, %middle.block69 ]
  %umax5 = tail call i64 @llvm.umax.i64(i64 %indvars.iv.ph, i64 15)
  br label %for.body23

vector.ph74:
  %n.vec76 = and i64 %4, 30
  %invariant.gep2 = getelementptr i16, ptr %h, i64 %3
  br label %vector.body71

vector.body71:
  %index77 = phi i64 [ 0, %vector.ph74 ], [ %index.next78, %vector.body71 ]
  %gep3 = getelementptr i16, ptr %invariant.gep2, i64 %index77
  store <2 x i16> <i16 -16657, i16 -16657>, ptr %gep3, align 2
  %index.next78 = add i64 %index77, 2
  %5 = icmp eq i64 %index.next78, %n.vec76
  br i1 %5, label %middle.block69, label %vector.body71

middle.block69:
  %ind.end80 = add nuw nsw i64 %n.vec76, %3
  %cmp.n81 = icmp eq i64 %4, %n.vec76
  br i1 %cmp.n81, label %for.end28, label %for.body23.preheader86

for.body13:
  %indvars.iv55 = phi i64 [ 0, %for.body13.preheader ], [ %indvars.iv.next56, %for.body13 ]
  %6 = trunc i64 %indvars.iv55 to i32
  %mul = mul nsw i32 %6, %6
  %conv14 = trunc i32 %mul to i16
  %arrayidx16 = getelementptr inbounds i16, ptr %h, i64 %indvars.iv55
  store i16 %conv14, ptr %arrayidx16, align 2
  %indvars.iv.next56 = add nuw nsw i64 %indvars.iv55, 1
  %exitcond = icmp eq i64 %indvars.iv.next56, %wide.trip.count
  br i1 %exitcond, label %for.cond20.preheader, label %for.body13

for.body23:
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body23 ], [ %indvars.iv.ph, %for.body23.preheader86 ]
  %arrayidx25 = getelementptr inbounds i16, ptr %h, i64 %indvars.iv
  store i16 -16657, ptr %arrayidx25, align 2
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond6.not = icmp eq i64 %indvars.iv, %umax5
  br i1 %exitcond6.not, label %for.end28, label %for.body23

for.end28:
  ret void
}

define i32 @c() {
; CHECK-LABEL: c:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    addd $r12 = $r12, -32
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 24[$r12] = $r16
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    sd 16[$r12] = $r18
; CHECK-NEXT:    call e
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    copyd $r18 = $r0
; CHECK-NEXT:    call g
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    make $r1 = a
; CHECK-NEXT:    make $r2 = 0
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sw 0[$r1] = $r2
; CHECK-NEXT:    cb.wlez $r18 ? .LBB1_5
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:  # %bb.1: # %for.cond3.preheader.preheader
; CHECK-NEXT:    sxwd $r0 = $r0
; CHECK-NEXT:    make $r3 = g
; CHECK-NEXT:    make $r4 = b
; CHECK-NEXT:    zxwd $r5 = $r18
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    loopdo $r5, .__LOOPDO_6_END_
; CHECK-NEXT:    ;;
; CHECK-NEXT:    goto .LBB1_3
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB1_2: # %for.cond.loopexit
; CHECK-NEXT:    # in Loop: Header=BB1_3 Depth=1
; CHECK-NEXT:    sw 0[$r1] = $r2
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:  .__LOOPDO_6_END_:
; CHECK-NEXT:    goto .LBB1_5
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB1_3: # %for.cond3.preheader
; CHECK-NEXT:    # =>This Loop Header: Depth=1
; CHECK-NEXT:    # Child Loop BB1_4 Depth 2
; CHECK-NEXT:    addd $r2 = $r2, 1
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    lwz.xs $r5 = $r2[$r0]
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    cb.weqz $r5 ? .LBB1_2
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB1_4: # %for.body4
; CHECK-NEXT:    # Parent Loop BB1_3 Depth=1
; CHECK-NEXT:    # => This Inner Loop Header: Depth=2
; CHECK-NEXT:    sw 0[$r4] = $r3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    lwz.xs $r5 = $r2[$r0]
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    cb.wnez $r5 ? .LBB1_4
; CHECK-NEXT:    ;;
; CHECK-NEXT:    goto .LBB1_2
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB1_5: # %for.end5
; CHECK-NEXT:    ld $r18 = 16[$r12]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    ld $r16 = 24[$r12]
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 32
; CHECK-NEXT:    ;; # (end cycle 6)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %call = tail call i32 @e()
  %call1 = tail call i32 @g()
  %conv = sext i32 %call1 to i64
  %0 = inttoptr i64 %conv to ptr
  store i32 0, ptr @a, align 4
  %cmp9 = icmp sgt i32 %call, 0
  br i1 %cmp9, label %for.cond3.preheader.preheader, label %for.end5

for.cond3.preheader.preheader:
  %wide.trip.count = zext nneg i32 %call to i64
  br label %for.cond3.preheader

for.cond.loopexit:
  %1 = trunc i64 %indvars.iv.next to i32
  store i32 %1, ptr @a, align 4
  %exitcond = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond, label %for.end5, label %for.cond3.preheader

for.cond3.preheader:
  %indvars.iv = phi i64 [ 0, %for.cond3.preheader.preheader ], [ %indvars.iv.next, %for.cond.loopexit ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %arrayidx = getelementptr inbounds i32, ptr %0, i64 %indvars.iv.next
  %2 = load i32, ptr %arrayidx, align 4
  %tobool8 = icmp eq i32 %2, 0
  br i1 %tobool8, label %for.cond.loopexit, label %for.body4

for.body4:
  store i32 ptrtoint (ptr @g to i32), ptr @b, align 4
  %3 = load i32, ptr %arrayidx, align 4
  %tobool = icmp eq i32 %3, 0
  br i1 %tobool, label %for.cond.loopexit, label %for.body4

for.end5:
  ret i32 undef
}

declare i32 @e(...) local_unnamed_addr

declare i32 @g(...)

declare i64 @llvm.umax.i64(i64, i64)

