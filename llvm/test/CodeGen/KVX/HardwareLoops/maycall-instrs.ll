; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc  -disable-kvx-hwloops=false -O3 -o - %s | FileCheck %s
; RUN: clang -mllvm -disable-kvx-hwloops=false -O3 -c -o /dev/null %s

target triple = "kvx-kalray-cos"

define void @_pocl_kernel_math_kernel_nohwloop_frem( float %a, float %b, i64 %c, ptr addrspace(1) %d) {
; CHECK-LABEL: _pocl_kernel_math_kernel_nohwloop_frem:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addd $r12 = $r12, -64
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 56[$r12] = $r16
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    # implicit-def: $r22
; CHECK-NEXT:    sd 48[$r12] = $r22
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    sq 32[$r12] = $r20r21
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    sq 16[$r12] = $r18r19
; CHECK-NEXT:    copyd $r18 = $r3
; CHECK-NEXT:    copyd $r19 = $r2
; CHECK-NEXT:    copyd $r20 = $r1
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    copyd $r21 = $r0
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:  .LBB0_1: # %pregion_for_entry.pregion_for_init4.i
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    copyd $r0 = $r21
; CHECK-NEXT:    copyd $r1 = $r20
; CHECK-NEXT:    call fmodf
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sw.xs $r19[$r18] = $r0
; CHECK-NEXT:    addd $r22 = $r22, -1
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    cb.dnez $r22 ? .LBB0_1
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.2: # %math_kernel.exit
; CHECK-NEXT:    lq $r18r19 = 16[$r12]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    lq $r20r21 = 32[$r12]
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    ld $r22 = 48[$r12]
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    ld $r16 = 56[$r12]
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 64
; CHECK-NEXT:    ;; # (end cycle 8)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  br label %pregion_for_entry.pregion_for_init4.i

pregion_for_entry.pregion_for_init4.i:
  %_local_id_z.0 = phi i64 [ 0, %0 ], [ %2, %pregion_for_entry.pregion_for_init4.i ]
  %arrayidx.i.i.us = getelementptr inbounds float, ptr addrspace(1) %d, i64 %c
  %1 = frem float %a, %b
  store float %1, ptr addrspace(1) %arrayidx.i.i.us, align 4
  %2 = add nuw i64 %_local_id_z.0, 1
  %exitcond4.not = icmp eq i64 %2, undef
  br i1 %exitcond4.not, label %math_kernel.exit, label %pregion_for_entry.pregion_for_init4.i

math_kernel.exit:
  ret void
}


define void @_pocl_kernel_math_kernel_nohwloop_fdiv( float %a, float %b, i64 %c, ptr addrspace(1) %d) {
; CHECK-LABEL: _pocl_kernel_math_kernel_nohwloop_fdiv:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addd $r12 = $r12, -64
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 56[$r12] = $r16
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    # implicit-def: $r22
; CHECK-NEXT:    sd 48[$r12] = $r22
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    sq 32[$r12] = $r20r21
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    sq 16[$r12] = $r18r19
; CHECK-NEXT:    copyd $r18 = $r3
; CHECK-NEXT:    copyd $r19 = $r2
; CHECK-NEXT:    copyd $r20 = $r1
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    copyd $r21 = $r0
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:  .LBB1_1: # %pregion_for_entry.pregion_for_init4.i
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    copyd $r0 = $r21
; CHECK-NEXT:    copyd $r1 = $r20
; CHECK-NEXT:    call __divsf3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sw.xs $r19[$r18] = $r0
; CHECK-NEXT:    addd $r22 = $r22, -1
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    cb.dnez $r22 ? .LBB1_1
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.2: # %math_kernel.exit
; CHECK-NEXT:    lq $r18r19 = 16[$r12]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    lq $r20r21 = 32[$r12]
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    ld $r22 = 48[$r12]
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    ld $r16 = 56[$r12]
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 64
; CHECK-NEXT:    ;; # (end cycle 8)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
br label %pregion_for_entry.pregion_for_init4.i

pregion_for_entry.pregion_for_init4.i:
  %_local_id_z.0 = phi i64 [ 0, %0 ], [ %2, %pregion_for_entry.pregion_for_init4.i ]
  %arrayidx.i.i.us = getelementptr inbounds float, ptr addrspace(1) %d, i64 %c
  %1 = fdiv float %a, %b
  store float %1, ptr addrspace(1) %arrayidx.i.i.us, align 4
  %2 = add nuw i64 %_local_id_z.0, 1
  %exitcond4.not = icmp eq i64 %2, undef
  br i1 %exitcond4.not, label %math_kernel.exit, label %pregion_for_entry.pregion_for_init4.i

math_kernel.exit:
  ret void
}

define void @_pocl_kernel_math_kernel_nohwloop_fdiv_double( double %a, double %b, i64 %c, ptr addrspace(1) %d) {
; CHECK-LABEL: _pocl_kernel_math_kernel_nohwloop_fdiv_double:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addd $r12 = $r12, -64
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 56[$r12] = $r16
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    # implicit-def: $r22
; CHECK-NEXT:    sd 48[$r12] = $r22
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    sq 32[$r12] = $r20r21
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    sq 16[$r12] = $r18r19
; CHECK-NEXT:    copyd $r18 = $r3
; CHECK-NEXT:    copyd $r19 = $r2
; CHECK-NEXT:    copyd $r20 = $r1
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    copyd $r21 = $r0
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:  .LBB2_1: # %pregion_for_entry.pregion_for_init4.i
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    copyd $r0 = $r21
; CHECK-NEXT:    copyd $r1 = $r20
; CHECK-NEXT:    call __divdf3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd.xs $r19[$r18] = $r0
; CHECK-NEXT:    addd $r22 = $r22, -1
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    cb.dnez $r22 ? .LBB2_1
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.2: # %math_kernel.exit
; CHECK-NEXT:    lq $r18r19 = 16[$r12]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    lq $r20r21 = 32[$r12]
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    ld $r22 = 48[$r12]
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    ld $r16 = 56[$r12]
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 64
; CHECK-NEXT:    ;; # (end cycle 8)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
br label %pregion_for_entry.pregion_for_init4.i

pregion_for_entry.pregion_for_init4.i:
  %_local_id_z.0 = phi i64 [ 0, %0 ], [ %2, %pregion_for_entry.pregion_for_init4.i ]
  %arrayidx.i.i.us = getelementptr inbounds double, ptr addrspace(1) %d, i64 %c
  %1 = fdiv double %a, %b
  store double %1, ptr addrspace(1) %arrayidx.i.i.us, align 4
  %2 = add nuw i64 %_local_id_z.0, 1
  %exitcond4.not = icmp eq i64 %2, undef
  br i1 %exitcond4.not, label %math_kernel.exit, label %pregion_for_entry.pregion_for_init4.i

math_kernel.exit:
  ret void
}

define void @_pocl_kernel_math_kernel_nohwloop_fdiv_half( half %a, half %b, i64 %c, ptr addrspace(1) %d) {
; CHECK-LABEL: _pocl_kernel_math_kernel_nohwloop_fdiv_half:
; CHECK:       # %bb.0:
; CHECK-NEXT:    # implicit-def: $r4
; CHECK-NEXT:    fwidenlhw $r0 = $r0
; CHECK-NEXT:    fwidenlhw $r1 = $r1
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    frecw $r1 = $r1
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    fmulw $r0 = $r0, $r1
; CHECK-NEXT:    ;; # (end cycle 16)
; CHECK-NEXT:    fnarrowwh $r0 = $r0
; CHECK-NEXT:    ;; # (end cycle 20)
; CHECK-NEXT:  .LBB3_1: # %pregion_for_entry.pregion_for_init4.i
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    sh.xs $r2[$r3] = $r0
; CHECK-NEXT:    addd $r4 = $r4, -1
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    cb.dnez $r4 ? .LBB3_1
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.2: # %math_kernel.exit
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
br label %pregion_for_entry.pregion_for_init4.i

pregion_for_entry.pregion_for_init4.i:
  %_local_id_z.0 = phi i64 [ 0, %0 ], [ %2, %pregion_for_entry.pregion_for_init4.i ]
  %arrayidx.i.i.us = getelementptr inbounds half, ptr addrspace(1) %d, i64 %c
  %1 = fdiv half %a, %b
  store half %1, ptr addrspace(1) %arrayidx.i.i.us, align 4
  %2 = add nuw i64 %_local_id_z.0, 1
  %exitcond4.not = icmp eq i64 %2, undef
  br i1 %exitcond4.not, label %math_kernel.exit, label %pregion_for_entry.pregion_for_init4.i

math_kernel.exit:
  ret void
}

define void @_pocl_kernel_math_kernel_hwloop_fdiv_half_fast( half %a, half %b, i64 %c, ptr addrspace(1) %d) {
; CHECK-LABEL: _pocl_kernel_math_kernel_hwloop_fdiv_half_fast:
; CHECK:       # %bb.0:
; CHECK-NEXT:    fwidenlhw $r0 = $r0
; CHECK-NEXT:    fwidenlhw $r1 = $r1
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    frecw $r1 = $r1
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    fmulw $r0 = $r0, $r1
; CHECK-NEXT:    ;; # (end cycle 16)
; CHECK-NEXT:    fnarrowwh $r0 = $r0
; CHECK-NEXT:    ;; # (end cycle 20)
; CHECK-NEXT:    loopdo $r0, .__LOOPDO_0_END_
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB4_1: # %pregion_for_entry.pregion_for_init4.i
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    sh.xs $r2[$r3] = $r0
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:  .__LOOPDO_0_END_:
; CHECK-NEXT:  # %bb.2: # %math_kernel.exit
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
br label %pregion_for_entry.pregion_for_init4.i

pregion_for_entry.pregion_for_init4.i:
  %_local_id_z.0 = phi i64 [ 0, %0 ], [ %2, %pregion_for_entry.pregion_for_init4.i ]
  %arrayidx.i.i.us = getelementptr inbounds half, ptr addrspace(1) %d, i64 %c
  %1 = fdiv fast half %a, %b
  store half %1, ptr addrspace(1) %arrayidx.i.i.us, align 4
  %2 = add nuw i64 %_local_id_z.0, 1
  %exitcond4.not = icmp eq i64 %2, undef
  br i1 %exitcond4.not, label %math_kernel.exit, label %pregion_for_entry.pregion_for_init4.i

math_kernel.exit:
  ret void
}

define void @_pocl_kernel_math_kernel_hwloop_fdiv_fast( float %a, float %b, i64 %c, ptr addrspace(1) %d) {
; CHECK-LABEL: _pocl_kernel_math_kernel_hwloop_fdiv_fast:
; CHECK:       # %bb.0:
; CHECK-NEXT:    frecw $r1 = $r1
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    fmulw $r0 = $r0, $r1
; CHECK-NEXT:    ;; # (end cycle 15)
; CHECK-NEXT:    loopdo $r0, .__LOOPDO_1_END_
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB5_1: # %pregion_for_entry.pregion_for_init4.i
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    sw.xs $r2[$r3] = $r0
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:  .__LOOPDO_1_END_:
; CHECK-NEXT:  # %bb.2: # %math_kernel.exit
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
br label %pregion_for_entry.pregion_for_init4.i

pregion_for_entry.pregion_for_init4.i:
  %_local_id_z.0 = phi i64 [ 0, %0 ], [ %2, %pregion_for_entry.pregion_for_init4.i ]
  %arrayidx.i.i.us = getelementptr inbounds float, ptr addrspace(1) %d, i64 %c
  %1 = fdiv fast float %a, %b
  store float %1, ptr addrspace(1) %arrayidx.i.i.us, align 4
  %2 = add nuw i64 %_local_id_z.0, 1
  %exitcond4.not = icmp eq i64 %2, undef
  br i1 %exitcond4.not, label %math_kernel.exit, label %pregion_for_entry.pregion_for_init4.i

math_kernel.exit:
  ret void
}

define void @_pocl_kernel_math_kernel_nohwloop_fdiv_double_fast( double %a, double %b, i64 %c, ptr addrspace(1) %d) {
; CHECK-LABEL: _pocl_kernel_math_kernel_nohwloop_fdiv_double_fast:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addd $r12 = $r12, -64
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 56[$r12] = $r16
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    # implicit-def: $r22
; CHECK-NEXT:    sd 48[$r12] = $r22
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    sq 32[$r12] = $r20r21
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    sq 16[$r12] = $r18r19
; CHECK-NEXT:    copyd $r18 = $r3
; CHECK-NEXT:    copyd $r19 = $r2
; CHECK-NEXT:    copyd $r20 = $r1
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    copyd $r21 = $r0
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:  .LBB6_1: # %pregion_for_entry.pregion_for_init4.i
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    copyd $r0 = $r21
; CHECK-NEXT:    copyd $r1 = $r20
; CHECK-NEXT:    call __divdf3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd.xs $r19[$r18] = $r0
; CHECK-NEXT:    addd $r22 = $r22, -1
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    cb.dnez $r22 ? .LBB6_1
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.2: # %math_kernel.exit
; CHECK-NEXT:    lq $r18r19 = 16[$r12]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    lq $r20r21 = 32[$r12]
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    ld $r22 = 48[$r12]
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    ld $r16 = 56[$r12]
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 64
; CHECK-NEXT:    ;; # (end cycle 8)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
br label %pregion_for_entry.pregion_for_init4.i

pregion_for_entry.pregion_for_init4.i:
  %_local_id_z.0 = phi i64 [ 0, %0 ], [ %2, %pregion_for_entry.pregion_for_init4.i ]
  %arrayidx.i.i.us = getelementptr inbounds double, ptr addrspace(1) %d, i64 %c
  %1 = fdiv fast double %a, %b
  store double %1, ptr addrspace(1) %arrayidx.i.i.us, align 4
  %2 = add nuw i64 %_local_id_z.0, 1
  %exitcond4.not = icmp eq i64 %2, undef
  br i1 %exitcond4.not, label %math_kernel.exit, label %pregion_for_entry.pregion_for_init4.i

math_kernel.exit:
  ret void
}
