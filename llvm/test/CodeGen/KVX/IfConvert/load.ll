; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -verify-machineinstrs -O2 -o - %s| FileCheck %s
; RUN: clang -O2 -c -o /dev/null %s

target triple = "kvx-kalray-cos"

define i8 @ld_ri10(i8* nocapture readonly %p) {
; CHECK-LABEL: ld_ri10:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lbz $r0 = 511[$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %arrayidx = getelementptr inbounds i8, i8* %p, i64 511
  %0 = load i8, i8* %arrayidx, align 1
  ret i8 %0
}

define i8 @ld_ri10_neg(i8* nocapture readonly %p) {
; CHECK-LABEL: ld_ri10_neg:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lbz $r0 = -512[$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %arrayidx = getelementptr inbounds i8, i8* %p, i64 -512
  %0 = load i8, i8* %arrayidx, align 1
  ret i8 %0
}

define i8 @ld_ri37_pos_min(i8* nocapture readonly %p) {
; CHECK-LABEL: ld_ri37_pos_min:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lbz $r0 = 512[$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %arrayidx = getelementptr inbounds i8, i8* %p, i64 512
  %0 = load i8, i8* %arrayidx, align 1
  ret i8 %0
}

define i8 @ld_ri37_neg_max(i8* nocapture readonly %p) {
; CHECK-LABEL: ld_ri37_neg_max:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lbz $r0 = -513[$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %arrayidx = getelementptr inbounds i8, i8* %p, i64 -513
  %0 = load i8, i8* %arrayidx, align 1
  ret i8 %0
}

define i8 @ld_ri37_pos_max(i8* nocapture readonly %p) {
; CHECK-LABEL: ld_ri37_pos_max:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lbz $r0 = 0x1fffffffff[$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %arrayidx = getelementptr inbounds i8, i8* %p, i64 137438953471
  %0 = load i8, i8* %arrayidx, align 1
  ret i8 %0
}

define i8 @ld_ri37_neg_min(i8* nocapture readonly %p) {
; CHECK-LABEL: ld_ri37_neg_min:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lbz $r0 = 0xffffffe000000000[$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %arrayidx = getelementptr inbounds i8, i8* %p, i64 -137438953472
  %0 = load i8, i8* %arrayidx, align 1
  ret i8 %0
}

define i8 @ld_ri64_pos_min(i8* nocapture readonly %p) {
; CHECK-LABEL: ld_ri64_pos_min:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lbz $r0 = 0x2000000000[$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %arrayidx = getelementptr inbounds i8, i8* %p, i64 137438953472
  %0 = load i8, i8* %arrayidx, align 1
  ret i8 %0
}

define i8 @ld_ri64_neg_max(i8* nocapture readonly %p) {
; CHECK-LABEL: ld_ri64_neg_max:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lbz $r0 = 0xffffffdfffffffff[$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %arrayidx = getelementptr inbounds i8, i8* %p, i64 -137438953473
  %0 = load i8, i8* %arrayidx, align 1
  ret i8 %0
}

define i32 @cc_weqz_ld_rr(i32 %c, i32* nocapture readonly %p) {
; CHECK-LABEL: cc_weqz_ld_rr:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lwz.weqz $r0 ? $r0 = [$r1]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %tobool.not = icmp eq i32 %c, 0
  br i1 %tobool.not, label %if.then, label %return

if.then:
  %0 = load i32, i32* %p, align 4
  br label %return

return:
  %retval.0 = phi i32 [ %0, %if.then ], [ %c, %entry ]
  ret i32 %retval.0
}

define i64 @cc_deqz_rr(i64 %v, i64* nocapture readonly %p, i64 %c) {
; CHECK-LABEL: cc_deqz_rr:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ld.deqz $r2 ? $r0 = [$r1]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %tobool.not = icmp eq i64 %c, 0
  br i1 %tobool.not, label %if.then, label %return

if.then:
  %0 = load i64, i64* %p, align 8
  br label %return

return:
  %retval.0 = phi i64 [ %0, %if.then ], [ %v, %entry ]
  ret i64 %retval.0
}

define i32 @cc_wnez_ld_rr(i32 %c, i32* nocapture readonly %p) {
; CHECK-LABEL: cc_wnez_ld_rr:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cb.weqz $r0 ? .LBB10_2
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.1: # %if.then
; CHECK-NEXT:    lwz $r0 = 0[$r1]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:  .LBB10_2:
; CHECK-NEXT:    make $r0 = 0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %tobool.not = icmp eq i32 %c, 0
  br i1 %tobool.not, label %return, label %if.then

if.then:
  %0 = load i32, i32* %p, align 4
  br label %return

return:
  %retval.0 = phi i32 [ %0, %if.then ], [ 0, %entry ]
  ret i32 %retval.0
}

define i64 @cc_dnez_rr(i64 %v, i64* nocapture readonly %p, i64 %c) {
; CHECK-LABEL: cc_dnez_rr:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ld.dnez $r2 ? $r0 = [$r1]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %tobool.not = icmp eq i64 %c, 0
  br i1 %tobool.not, label %return, label %if.then

if.then:
  %0 = load i64, i64* %p, align 8
  br label %return

return:
  %retval.0 = phi i64 [ %0, %if.then ], [ %v, %entry ]
  ret i64 %retval.0
}

define i32 @cc_wgez_ld_rr(i32 %c, i32* nocapture readonly %p) {
; CHECK-LABEL: cc_wgez_ld_rr:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lwz.wgez $r0 ? $r0 = [$r1]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %cmp = icmp sgt i32 %c, -1
  br i1 %cmp, label %if.then, label %return

if.then:
  %0 = load i32, i32* %p, align 4
  br label %return

return:
  %retval.0 = phi i32 [ %0, %if.then ], [ %c, %entry ]
  ret i32 %retval.0
}

define i64 @cc_dgez_rr(i64 %v, i64* nocapture readonly %p, i64 %c) {
; CHECK-LABEL: cc_dgez_rr:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ld.dgez $r2 ? $r0 = [$r1]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %cmp = icmp sgt i64 %c, -1
  br i1 %cmp, label %if.then, label %return

if.then:
  %0 = load i64, i64* %p, align 8
  br label %return

return:
  %retval.0 = phi i64 [ %0, %if.then ], [ %v, %entry ]
  ret i64 %retval.0
}

define i32 @cc_wgtz_ld_rr(i32 %c, i32* nocapture readonly %p) {
; CHECK-LABEL: cc_wgtz_ld_rr:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lwz.wgtz $r0 ? $r0 = [$r1]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %cmp = icmp sgt i32 %c, 0
  br i1 %cmp, label %if.then, label %return

if.then:
  %0 = load i32, i32* %p, align 4
  br label %return

return:
  %retval.0 = phi i32 [ %0, %if.then ], [ %c, %entry ]
  ret i32 %retval.0
}

define i64 @cc_dgtz_rr(i64 %v, i64* nocapture readonly %p, i64 %c) {
; CHECK-LABEL: cc_dgtz_rr:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ld.dgtz $r2 ? $r0 = [$r1]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %cmp = icmp sgt i64 %c, 0
  br i1 %cmp, label %if.then, label %return

if.then:
  %0 = load i64, i64* %p, align 8
  br label %return

return:
  %retval.0 = phi i64 [ %0, %if.then ], [ %v, %entry ]
  ret i64 %retval.0
}

define i32 @cc_wgtz_ld_rr_2(i32 %c, i32* nocapture readonly %p) {
; CHECK-LABEL: cc_wgtz_ld_rr_2:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lwz.wgtz $r0 ? $r0 = [$r1]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %cmp = icmp sgt i32 %c, 0
  br i1 %cmp, label %if.then, label %return

if.then:
  %0 = load i32, i32* %p, align 4
  br label %return

return:
  %retval.0 = phi i32 [ %0, %if.then ], [ %c, %entry ]
  ret i32 %retval.0
}

define i64 @cc_dgtz_rr_2(i64 %v, i64* nocapture readonly %p, i64 %c) {
; CHECK-LABEL: cc_dgtz_rr_2:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ld.dgtz $r2 ? $r0 = [$r1]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %cmp = icmp sgt i64 %c, 0
  br i1 %cmp, label %if.then, label %return

if.then:
  %0 = load i64, i64* %p, align 8
  br label %return

return:
  %retval.0 = phi i64 [ %0, %if.then ], [ %v, %entry ]
  ret i64 %retval.0
}

define i32 @cc_wlez_ld_rr(i32 %c, i32* nocapture readonly %p) {
; CHECK-LABEL: cc_wlez_ld_rr:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lwz.wlez $r0 ? $r0 = [$r1]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %cmp = icmp slt i32 %c, 1
  br i1 %cmp, label %if.then, label %return

if.then:
  %0 = load i32, i32* %p, align 4
  br label %return

return:
  %retval.0 = phi i32 [ %0, %if.then ], [ %c, %entry ]
  ret i32 %retval.0
}

define i64 @cc_dlez_rr(i64 %v, i64* nocapture readonly %p, i64 %c) {
; CHECK-LABEL: cc_dlez_rr:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ld.dlez $r2 ? $r0 = [$r1]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %cmp = icmp slt i64 %c, 1
  br i1 %cmp, label %if.then, label %return

if.then:
  %0 = load i64, i64* %p, align 8
  br label %return

return:
  %retval.0 = phi i64 [ %0, %if.then ], [ %v, %entry ]
  ret i64 %retval.0
}

define i32 @cc_wltz_ld_rr(i32 %c, i32* nocapture readonly %p) {
; CHECK-LABEL: cc_wltz_ld_rr:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lwz.wltz $r0 ? $r0 = [$r1]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %cmp = icmp slt i32 %c, 0
  br i1 %cmp, label %if.then, label %return

if.then:
  %0 = load i32, i32* %p, align 4
  br label %return

return:
  %retval.0 = phi i32 [ %0, %if.then ], [ %c, %entry ]
  ret i32 %retval.0
}

define i64 @cc_dltz_rr(i64 %v, i64* nocapture readonly %p, i64 %c) {
; CHECK-LABEL: cc_dltz_rr:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ld.dltz $r2 ? $r0 = [$r1]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %cmp = icmp slt i64 %c, 0
  br i1 %cmp, label %if.then, label %return

if.then:
  %0 = load i64, i64* %p, align 8
  br label %return

return:
  %retval.0 = phi i64 [ %0, %if.then ], [ %v, %entry ]
  ret i64 %retval.0
}

define i32 @cc_wltz_ld_rr_2(i32 %c, i32* nocapture readonly %p) {
; CHECK-LABEL: cc_wltz_ld_rr_2:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lwz.wltz $r0 ? $r0 = [$r1]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %cmp = icmp slt i32 %c, 0
  br i1 %cmp, label %if.then, label %return

if.then:
  %0 = load i32, i32* %p, align 4
  br label %return

return:
  %retval.0 = phi i32 [ %0, %if.then ], [ %c, %entry ]
  ret i32 %retval.0
}

define i64 @cc_dltz_rr_2(i64 %v, i64* nocapture readonly %p, i64 %c) {
; CHECK-LABEL: cc_dltz_rr_2:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ld.dltz $r2 ? $r0 = [$r1]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %cmp = icmp slt i64 %c, 0
  br i1 %cmp, label %if.then, label %return

if.then:
  %0 = load i64, i64* %p, align 8
  br label %return

return:
  %retval.0 = phi i64 [ %0, %if.then ], [ %v, %entry ]
  ret i64 %retval.0
}

define i8 @cc_rr(i8 %v, i8* nocapture readonly %p, i32 %c) {
; CHECK-LABEL: cc_rr:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lbz.weqz $r2 ? $r0 = [$r1]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %tobool.not = icmp eq i32 %c, 0
  br i1 %tobool.not, label %if.then, label %return

if.then:
  %0 = load i8, i8* %p, align 1
  br label %return

return:
  %retval.0 = phi i8 [ %0, %if.then ], [ %v, %entry ]
  ret i8 %retval.0
}

define i8 @cc_ri27_pos_min(i8 %v, i8* nocapture readonly %p, i32 %c) {
; CHECK-LABEL: cc_ri27_pos_min:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lbz.weqz $r2 ? $r0 = 1[$r1]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %tobool.not = icmp eq i32 %c, 0
  br i1 %tobool.not, label %if.then, label %return

if.then:
  %arrayidx = getelementptr inbounds i8, i8* %p, i64 1
  %0 = load i8, i8* %arrayidx, align 1
  br label %return

return:
  %retval.0 = phi i8 [ %0, %if.then ], [ %v, %entry ]
  ret i8 %retval.0
}

define i8 @cc_ri27_neg_max(i8 %v, i8* nocapture readonly %p, i32 %c) {
; CHECK-LABEL: cc_ri27_neg_max:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lbz.weqz $r2 ? $r0 = -1[$r1]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %tobool.not = icmp eq i32 %c, 0
  br i1 %tobool.not, label %if.then, label %return

if.then:
  %arrayidx = getelementptr inbounds i8, i8* %p, i64 -1
  %0 = load i8, i8* %arrayidx, align 1
  br label %return

return:
  %retval.0 = phi i8 [ %0, %if.then ], [ %v, %entry ]
  ret i8 %retval.0
}

define i8 @cc_ri27_pos_max(i8 %v, i8* nocapture readonly %p, i32 %c) {
; CHECK-LABEL: cc_ri27_pos_max:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lbz.weqz $r2 ? $r0 = 0x3ffffff[$r1]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %tobool.not = icmp eq i32 %c, 0
  br i1 %tobool.not, label %if.then, label %return

if.then:
  %arrayidx = getelementptr inbounds i8, i8* %p, i64 67108863
  %0 = load i8, i8* %arrayidx, align 1
  br label %return

return:
  %retval.0 = phi i8 [ %0, %if.then ], [ %v, %entry ]
  ret i8 %retval.0
}

define i8 @cc_ri27_neg_min(i8 %v, i8* nocapture readonly %p, i32 %c) {
; CHECK-LABEL: cc_ri27_neg_min:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lbz.weqz $r2 ? $r0 = 0xfffffffffc000000[$r1]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %tobool.not = icmp eq i32 %c, 0
  br i1 %tobool.not, label %if.then, label %return

if.then:
  %arrayidx = getelementptr inbounds i8, i8* %p, i64 -67108864
  %0 = load i8, i8* %arrayidx, align 1
  br label %return

return:
  %retval.0 = phi i8 [ %0, %if.then ], [ %v, %entry ]
  ret i8 %retval.0
}

define i8 @cc_ri54_pos_max(i8 %v, i8* nocapture readonly %p, i32 %c) {
; CHECK-LABEL: cc_ri54_pos_max:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lbz.weqz $r2 ? $r0 = 0x1fffffffffffff[$r1]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %tobool.not = icmp eq i32 %c, 0
  br i1 %tobool.not, label %if.then, label %return

if.then:
  %arrayidx = getelementptr inbounds i8, i8* %p, i64 9007199254740991
  %0 = load i8, i8* %arrayidx, align 1
  br label %return

return:
  %retval.0 = phi i8 [ %0, %if.then ], [ %v, %entry ]
  ret i8 %retval.0
}

define i8 @cc_ri54_neg_min(i8 %v, i8* nocapture readonly %p, i32 %c) {
; CHECK-LABEL: cc_ri54_neg_min:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lbz.weqz $r2 ? $r0 = 0xffe0000000000000[$r1]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %tobool.not = icmp eq i32 %c, 0
  br i1 %tobool.not, label %if.then, label %return

if.then:
  %arrayidx = getelementptr inbounds i8, i8* %p, i64 -9007199254740992
  %0 = load i8, i8* %arrayidx, align 1
  br label %return

return:
  %retval.0 = phi i8 [ %0, %if.then ], [ %v, %entry ]
  ret i8 %retval.0
}

define i8 @cc_rr_make_offset_min(i8 %v, i8* nocapture readonly %p, i32 %c) {
; CHECK-LABEL: cc_rr_make_offset_min:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cb.weqz $r2 ? .LBB31_2
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.1: # %return
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB31_2: # %if.then
; CHECK-NEXT:    lbz $r0 = 0x20000000000000[$r1]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %tobool.not = icmp eq i32 %c, 0
  br i1 %tobool.not, label %if.then, label %return

if.then:
  %arrayidx = getelementptr inbounds i8, i8* %p, i64 9007199254740992
  %0 = load i8, i8* %arrayidx, align 1
  br label %return

return:
  %retval.0 = phi i8 [ %0, %if.then ], [ %v, %entry ]
  ret i8 %retval.0
}

define i8 @cc_rr_make_offset_max_neg(i8 %v, i8* nocapture readonly %p, i32 %c) {
; CHECK-LABEL: cc_rr_make_offset_max_neg:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cb.weqz $r2 ? .LBB32_2
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.1: # %return
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB32_2: # %if.then
; CHECK-NEXT:    lbz $r0 = 0xffdfffffffffffff[$r1]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %tobool.not = icmp eq i32 %c, 0
  br i1 %tobool.not, label %if.then, label %return

if.then:
  %arrayidx = getelementptr inbounds i8, i8* %p, i64 -9007199254740993
  %0 = load i8, i8* %arrayidx, align 1
  br label %return

return:
  %retval.0 = phi i8 [ %0, %if.then ], [ %v, %entry ]
  ret i8 %retval.0
}

define i64 @sext_32_rr(i64 %c, i32* nocapture readonly %p) {
; CHECK-LABEL: sext_32_rr:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lws.dgez $r0 ? $r0 = [$r1]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %cmp = icmp sge i64 %c, 0
  br i1 %cmp, label %if.then, label %return

if.then:
  %0 = load i32, i32* %p, align 4
  %1 = sext i32 %0 to i64
  br label %return

return:
  %retval.0 = phi i64 [ %1, %if.then ], [ %c, %entry ]
  ret i64 %retval.0
}

define <2 x i64> @ldq_cc(<2 x i64> %0, <2 x i64>* nocapture readonly %1, i64 %2) {
; CHECK-LABEL: ldq_cc:
; CHECK:       # %bb.0:
; CHECK-NEXT:    lq.dnez $r3 ? $r0r1 = [$r2]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %4 = icmp eq i64 %2, 0
  br i1 %4, label %7, label %5

5:
  %6 = load <2 x i64>, <2 x i64>* %1, align 16
  br label %7

7:
  %8 = phi <2 x i64> [ %6, %5 ], [ %0, %3 ]
  ret <2 x i64> %8
}

define <4 x i64> @ldo_cc(<4 x i64> %0, <4 x i64>* nocapture readonly %1, i64 %2) {
; CHECK-LABEL: ldo_cc:
; CHECK:       # %bb.0:
; CHECK-NEXT:    lo.dnez $r5 ? $r0r1r2r3 = [$r4]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %4 = icmp eq i64 %2, 0
  br i1 %4, label %7, label %5

5:
  %6 = load <4 x i64>, <4 x i64>* %1, align 32
  br label %7

7:
  %8 = phi <4 x i64> [ %6, %5 ], [ %0, %3 ]
  ret <4 x i64> %8
}

define <4 x i64> @select_v4(<4 x i64> %0, <4 x i64> %1, i32 %2, i32 %3, <4 x i64>* nocapture readonly %4) {
; CHECK-LABEL: select_v4:
; CHECK:       # %bb.0:
; CHECK-NEXT:    cb.weqz $r8 ? .LBB36_4
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    cb.weqz $r9 ? .LBB36_3
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.2:
; CHECK-NEXT:    lo $r4r5r6r7 = 0[$r10]
; CHECK-NEXT:    goto .LBB36_4
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:  .LBB36_3:
; CHECK-NEXT:    copyo $r4r5r6r7 = $r0r1r2r3
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:  .LBB36_4:
; CHECK-NEXT:    copyd $r0 = $r4
; CHECK-NEXT:    copyd $r1 = $r5
; CHECK-NEXT:    copyd $r2 = $r6
; CHECK-NEXT:    copyd $r3 = $r7
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %6 = icmp eq i32 %2, 0
  br i1 %6, label %11, label %7

7:
  %8 = icmp eq i32 %3, 0
  br i1 %8, label %11, label %9

9:
  %10 = load <4 x i64>, <4 x i64>* %4, align 32
  br label %11

11:
  %12 = phi <4 x i64> [ %10, %9 ], [ %0, %7 ], [ %1, %5 ]
  ret <4 x i64> %12
}
