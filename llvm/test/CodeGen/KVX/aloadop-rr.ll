; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mcpu=kv3-1 -O2 -o - %s | FileCheck %s --check-prefixes=CV1
; RUN: llc -mcpu=kv3-2 -O2 -o - %s | FileCheck %s --check-prefixes=CV2
; RUN: clang -O2 -c -o /dev/null %s
; RUN: clang -O2 -march=kv3-2 -c -o /dev/null %s
; ref: T13217

target triple = "kvx-kalray-cos"

@b = common global i32* null, align 8
@a = common global i64 0, align 8
@c = common global i64* null, align 8

define void @foo32() {
; CV1-LABEL: foo32:
; CV1:       # %bb.0: # %entry
; CV1-NEXT:    make $r0 = b
; CV1-NEXT:    make $r1 = a
; CV1-NEXT:    make $r2 = 0
; CV1-NEXT:    ;;
; CV1-NEXT:    ld $r1 = 0[$r1]
; CV1-NEXT:    ;;
; CV1-NEXT:    ld $r0 = 0[$r0]
; CV1-NEXT:    ;;
; CV1-NEXT:    fence
; CV1-NEXT:    ;;
; CV1-NEXT:    slld $r1 = $r1, 2
; CV1-NEXT:    ;;
; CV1-NEXT:  .LBB0_1: # %entry
; CV1-NEXT:    # =>This Inner Loop Header: Depth=1
; CV1-NEXT:    lwz.u $r5 = $r1[$r0]
; CV1-NEXT:    ;;
; CV1-NEXT:    orw $r4 = $r2, $r5
; CV1-NEXT:    ;;
; CV1-NEXT:    acswapw $r1[$r0] = $r4r5
; CV1-NEXT:    ;;
; CV1-NEXT:    cb.even $r4 ? .LBB0_1
; CV1-NEXT:    ;;
; CV1-NEXT:  # %bb.2: # %entry
; CV1-NEXT:    copyw $r0 = $r5
; CV1-NEXT:    fence
; CV1-NEXT:    ret
; CV1-NEXT:    ;;
;
; CV2-LABEL: foo32:
; CV2:       # %bb.0: # %entry
; CV2-NEXT:    make $r0 = b
; CV2-NEXT:    make $r1 = a
; CV2-NEXT:    make $r2 = 0
; CV2-NEXT:    ;;
; CV2-NEXT:    ld $r1 = 0[$r1]
; CV2-NEXT:    ;;
; CV2-NEXT:    ld $r0 = 0[$r0]
; CV2-NEXT:    ;;
; CV2-NEXT:    fence
; CV2-NEXT:    ;;
; CV2-NEXT:    slld $r1 = $r1, 2
; CV2-NEXT:    ;;
; CV2-NEXT:    addd $r0 = $r0, $r1
; CV2-NEXT:    ;;
; CV2-NEXT:  .LBB0_1: # %entry
; CV2-NEXT:    # =>This Inner Loop Header: Depth=1
; CV2-NEXT:    lwz.u $r5 = 0[$r0]
; CV2-NEXT:    ;;
; CV2-NEXT:    orw $r4 = $r2, $r5
; CV2-NEXT:    ;;
; CV2-NEXT:    acswapw $r4, [$r0] = $r4r5
; CV2-NEXT:    ;;
; CV2-NEXT:    cb.even $r4 ? .LBB0_1
; CV2-NEXT:    ;;
; CV2-NEXT:  # %bb.2: # %entry
; CV2-NEXT:    copyw $r0 = $r5
; CV2-NEXT:    fence
; CV2-NEXT:    ret
; CV2-NEXT:    ;;
entry:
  %0 = load i32*, i32** @b, align 8
  %1 = load i64, i64* @a, align 8
  %arrayidx = getelementptr inbounds i32, i32* %0, i64 %1
  %2 = atomicrmw or i32* %arrayidx, i32 0 seq_cst
  ret void
}

define void @foo64() {
; CV1-LABEL: foo64:
; CV1:       # %bb.0: # %entry
; CV1-NEXT:    make $r0 = c
; CV1-NEXT:    make $r1 = a
; CV1-NEXT:    make $r2 = 0
; CV1-NEXT:    ;;
; CV1-NEXT:    ld $r1 = 0[$r1]
; CV1-NEXT:    ;;
; CV1-NEXT:    ld $r0 = 0[$r0]
; CV1-NEXT:    ;;
; CV1-NEXT:    fence
; CV1-NEXT:    ;;
; CV1-NEXT:    slld $r1 = $r1, 3
; CV1-NEXT:    ;;
; CV1-NEXT:  .LBB1_1: # %entry
; CV1-NEXT:    # =>This Inner Loop Header: Depth=1
; CV1-NEXT:    ld.u $r5 = $r1[$r0]
; CV1-NEXT:    ;;
; CV1-NEXT:    ord $r4 = $r2, $r5
; CV1-NEXT:    ;;
; CV1-NEXT:    acswapd $r1[$r0] = $r4r5
; CV1-NEXT:    ;;
; CV1-NEXT:    cb.even $r4 ? .LBB1_1
; CV1-NEXT:    ;;
; CV1-NEXT:  # %bb.2: # %entry
; CV1-NEXT:    copyd $r0 = $r5
; CV1-NEXT:    fence
; CV1-NEXT:    ret
; CV1-NEXT:    ;;
;
; CV2-LABEL: foo64:
; CV2:       # %bb.0: # %entry
; CV2-NEXT:    make $r0 = c
; CV2-NEXT:    make $r1 = a
; CV2-NEXT:    make $r2 = 0
; CV2-NEXT:    ;;
; CV2-NEXT:    ld $r1 = 0[$r1]
; CV2-NEXT:    ;;
; CV2-NEXT:    ld $r0 = 0[$r0]
; CV2-NEXT:    ;;
; CV2-NEXT:    fence
; CV2-NEXT:    ;;
; CV2-NEXT:    slld $r1 = $r1, 3
; CV2-NEXT:    ;;
; CV2-NEXT:    addd $r0 = $r0, $r1
; CV2-NEXT:    ;;
; CV2-NEXT:  .LBB1_1: # %entry
; CV2-NEXT:    # =>This Inner Loop Header: Depth=1
; CV2-NEXT:    ld.u $r5 = 0[$r0]
; CV2-NEXT:    ;;
; CV2-NEXT:    ord $r4 = $r2, $r5
; CV2-NEXT:    ;;
; CV2-NEXT:    acswapd $r4, [$r0] = $r4r5
; CV2-NEXT:    ;;
; CV2-NEXT:    cb.even $r4 ? .LBB1_1
; CV2-NEXT:    ;;
; CV2-NEXT:  # %bb.2: # %entry
; CV2-NEXT:    copyd $r0 = $r5
; CV2-NEXT:    fence
; CV2-NEXT:    ret
; CV2-NEXT:    ;;
entry:
  %0 = load i64*, i64** @c, align 8
  %1 = load i64, i64* @a, align 8
  %arrayidx = getelementptr inbounds i64, i64* %0, i64 %1
  %2 = atomicrmw or i64* %arrayidx, i64 0 seq_cst
  ret void
}
