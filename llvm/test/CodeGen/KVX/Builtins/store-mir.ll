; NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
; RUN: llc -mcpu=kv3-2 --stop-before=kvx-preemit-expand-pseudo,3 -o - %s -O2 | FileCheck %s --check-prefixes=CHECK

target triple = "kvx-kalray-cos"

define void @storeb(i64 %a, ptr nocapture %ptr) {
  ; CHECK-LABEL: name: storeb
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   liveins: $r0, $r1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit killed $r1, implicit killed $r0, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     SBri10 0, killed $r1, killed $r0 :: (store (s8) into %ir.ptr)
  ; CHECK-NEXT:     RET implicit $ra
  ; CHECK-NEXT:   }
entry:
  %0 = trunc i64 %a to i8
  store i8 %0, ptr %ptr
  ret void
}

define i32 @storeb_r(i64 %a, ptr %ptr, ptr nocapture readonly %load) {
  ; CHECK-LABEL: name: storeb_r
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   liveins: $r0, $r1, $r2
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit-def $r2, implicit killed $r2 {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     $r2 = LWZri10 0, killed $r2, 0 :: (load (s32) from %ir.load)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r2, implicit killed $r2, implicit killed $r1, implicit killed $r0 {
  ; CHECK-NEXT:     MCYCLESp 3
  ; CHECK-NEXT:     $r2 = READYp1r killed $r2
  ; CHECK-NEXT:     STOREp killed $r1, killed $r0, 8, internal $r2
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r2, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 4
  ; CHECK-NEXT:     $r0 = COPYD killed $r2
  ; CHECK-NEXT:     RET implicit $ra, implicit internal $r0
  ; CHECK-NEXT:   }
entry:
  %0 = load i32, ptr %load
  %1 = tail call i64 (...) @llvm.kvx.ready(i32 %0)
  %conv = trunc i64 %1 to i32
  %2 = bitcast ptr %ptr to ptr 
  tail call void @llvm.kvx.store.i64.p0i64.i32(i64 %a, ptr %2, i32 8, i32 %conv)
  ret i32 %conv
}

declare i64 @llvm.kvx.ready(...)

declare void @llvm.kvx.store.i64.p0i64.i32(i64, ptr, i32, i32)

define void @storeh(i64 %a, ptr nocapture %ptr) {
  ; CHECK-LABEL: name: storeh
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   liveins: $r0, $r1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit killed $r1, implicit killed $r0, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     SHri10 0, killed $r1, killed $r0 :: (store (s16) into %ir.1)
  ; CHECK-NEXT:     RET implicit $ra
  ; CHECK-NEXT:   }
entry:
  %0 = trunc i64 %a to i16
  %1 = bitcast ptr %ptr to ptr 
  store i16 %0, ptr %1
  ret void
}

define i32 @storeh_r(i64 %a, ptr %ptr, ptr nocapture readonly %load) {
  ; CHECK-LABEL: name: storeh_r
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   liveins: $r0, $r1, $r2
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit-def $r2, implicit killed $r2 {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     $r2 = LWZri10 0, killed $r2, 0 :: (load (s32) from %ir.load)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r2, implicit killed $r2, implicit killed $r1, implicit killed $r0 {
  ; CHECK-NEXT:     MCYCLESp 3
  ; CHECK-NEXT:     $r2 = READYp1r killed $r2
  ; CHECK-NEXT:     STOREp killed $r1, killed $r0, 16, internal $r2
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r2, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 4
  ; CHECK-NEXT:     $r0 = COPYD killed $r2
  ; CHECK-NEXT:     RET implicit $ra, implicit internal $r0
  ; CHECK-NEXT:   }
entry:
  %0 = load i32, ptr %load
  %1 = tail call i64 (...) @llvm.kvx.ready(i32 %0)
  %conv = trunc i64 %1 to i32
  %2 = bitcast ptr %ptr to ptr 
  tail call void @llvm.kvx.store.i64.p0i64.i32(i64 %a, ptr %2, i32 16, i32 %conv)
  ret i32 %conv
}

define void @storew(i64 %a, ptr nocapture %ptr) {
  ; CHECK-LABEL: name: storew
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   liveins: $r0, $r1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit killed $r1, implicit killed $r0, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     SWri10 0, killed $r1, killed $r0 :: (store (s32) into %ir.1)
  ; CHECK-NEXT:     RET implicit $ra
  ; CHECK-NEXT:   }
entry:
  %0 = trunc i64 %a to i32
  %1 = bitcast ptr %ptr to ptr 
  store i32 %0, ptr %1
  ret void
}

define i32 @storew_r(i64 %a, ptr %ptr, ptr nocapture readonly %load) {
  ; CHECK-LABEL: name: storew_r
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   liveins: $r0, $r1, $r2
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit-def $r2, implicit killed $r2 {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     $r2 = LWZri10 0, killed $r2, 0 :: (load (s32) from %ir.load)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r2, implicit killed $r2, implicit killed $r1, implicit killed $r0 {
  ; CHECK-NEXT:     MCYCLESp 3
  ; CHECK-NEXT:     $r2 = READYp1r killed $r2
  ; CHECK-NEXT:     STOREp killed $r1, killed $r0, 32, internal $r2
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r2, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 4
  ; CHECK-NEXT:     $r0 = COPYD killed $r2
  ; CHECK-NEXT:     RET implicit $ra, implicit internal $r0
  ; CHECK-NEXT:   }
entry:
  %0 = load i32, ptr %load
  %1 = tail call i64 (...) @llvm.kvx.ready(i32 %0)
  %conv = trunc i64 %1 to i32
  %2 = bitcast ptr %ptr to ptr 
  tail call void @llvm.kvx.store.i64.p0i64.i32(i64 %a, ptr %2, i32 32, i32 %conv)
  ret i32 %conv
}

define void @stored(i64 %a, ptr nocapture %ptr) {
  ; CHECK-LABEL: name: stored
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   liveins: $r0, $r1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit killed $r1, implicit killed $r0, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     SDri10 0, killed $r1, killed $r0 :: (store (s64) into %ir.0)
  ; CHECK-NEXT:     RET implicit $ra
  ; CHECK-NEXT:   }
entry:
  %0 = bitcast ptr %ptr to ptr 
  store i64 %a, ptr %0
  ret void
}

define i32 @stored_r(i64 %a, ptr %ptr, ptr nocapture readonly %load) {
  ; CHECK-LABEL: name: stored_r
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   liveins: $r0, $r1, $r2
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit-def $r2, implicit killed $r2 {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     $r2 = LWZri10 0, killed $r2, 0 :: (load (s32) from %ir.load)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r2, implicit killed $r2, implicit killed $r1, implicit killed $r0 {
  ; CHECK-NEXT:     MCYCLESp 3
  ; CHECK-NEXT:     $r2 = READYp1r killed $r2
  ; CHECK-NEXT:     STOREp killed $r1, killed $r0, 64, internal $r2
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r2, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 4
  ; CHECK-NEXT:     $r0 = COPYD killed $r2
  ; CHECK-NEXT:     RET implicit $ra, implicit internal $r0
  ; CHECK-NEXT:   }
entry:
  %0 = load i32, ptr %load
  %1 = tail call i64 (...) @llvm.kvx.ready(i32 %0)
  %conv = trunc i64 %1 to i32
  %2 = bitcast ptr %ptr to ptr 
  tail call void @llvm.kvx.store.i64.p0i64.i32(i64 %a, ptr %2, i32 64, i32 %conv)
  ret i32 %conv
}

define void @storeq(i128 %a, ptr nocapture %ptr) {
  ; CHECK-LABEL: name: storeq
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   liveins: $r0, $r1, $r2
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit killed $r2, implicit killed $p0, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     SQri10 0, killed $r2, killed $p0 :: (store (s128) into %ir.0, align 8)
  ; CHECK-NEXT:     RET implicit $ra
  ; CHECK-NEXT:   }
entry:
  %0 = bitcast ptr %ptr to ptr 
  store i128 %a, ptr %0
  ret void
}

define i32 @storeq_r(i128 %a, ptr %ptr, ptr nocapture readonly %load) {
  ; CHECK-LABEL: name: storeq_r
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   liveins: $r0, $r1, $r2, $r3
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit-def $r3, implicit killed $r3 {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     $r3 = LWZri10 0, killed $r3, 0 :: (load (s32) from %ir.load)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r3, implicit killed $r3, implicit killed $r2, implicit killed $p0 {
  ; CHECK-NEXT:     MCYCLESp 3
  ; CHECK-NEXT:     $r3 = READYp1r killed $r3
  ; CHECK-NEXT:     STOREp killed $r2, killed $p0, 128, internal $r3
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r3, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 4
  ; CHECK-NEXT:     $r0 = COPYD killed $r3
  ; CHECK-NEXT:     RET implicit $ra, implicit internal $r0
  ; CHECK-NEXT:   }
entry:
  %0 = load i32, ptr %load
  %1 = tail call i64 (...) @llvm.kvx.ready(i32 %0)
  %conv = trunc i64 %1 to i32
  %2 = bitcast i128 %a to <2 x i64>
  %3 = bitcast ptr %ptr to ptr 
  tail call void @llvm.kvx.store.v2i64.p0v2i64.i32(<2 x i64> %2, ptr %3, i32 128, i32 %conv)
  ret i32 %conv
}

declare void @llvm.kvx.store.v2i64.p0v2i64.i32(<2 x i64>, ptr, i32, i32)

define void @storehf(half %a, ptr nocapture %ptr) {
  ; CHECK-LABEL: name: storehf
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   liveins: $r0, $r1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit killed $r1, implicit killed $r0, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     SHri10 0, killed $r1, killed $r0 :: (store (s16) into %ir.0)
  ; CHECK-NEXT:     RET implicit $ra
  ; CHECK-NEXT:   }
entry:
  %0 = bitcast ptr %ptr to ptr 
  store half %a, ptr %0
  ret void
}

define i32 @storehf_r(half %a, ptr %ptr, ptr nocapture readonly %load) {
  ; CHECK-LABEL: name: storehf_r
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   liveins: $r0, $r1, $r2
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit-def $r2, implicit killed $r2 {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     $r2 = LWZri10 0, killed $r2, 0 :: (load (s32) from %ir.load)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r2, implicit killed $r2, implicit killed $r1, implicit killed $r0 {
  ; CHECK-NEXT:     MCYCLESp 3
  ; CHECK-NEXT:     $r2 = READYp1r killed $r2
  ; CHECK-NEXT:     STOREp killed $r1, killed $r0, 16, internal $r2
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r2, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 4
  ; CHECK-NEXT:     $r0 = COPYD killed $r2
  ; CHECK-NEXT:     RET implicit $ra, implicit internal $r0
  ; CHECK-NEXT:   }
entry:
  %0 = load i32, ptr %load
  %1 = tail call i64 (...) @llvm.kvx.ready(i32 %0)
  %conv = trunc i64 %1 to i32
  %2 = bitcast ptr %ptr to ptr 
  tail call void @llvm.kvx.store.f16.p0f16.i32(half %a, ptr %2, i32 16, i32 %conv)
  ret i32 %conv
}

declare void @llvm.kvx.store.f16.p0f16.i32(half, ptr, i32, i32)

define void @storewf(float %a, ptr nocapture %ptr) {
  ; CHECK-LABEL: name: storewf
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   liveins: $r0, $r1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit killed $r1, implicit killed $r0, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     SWri10 0, killed $r1, killed $r0 :: (store (s32) into %ir.0)
  ; CHECK-NEXT:     RET implicit $ra
  ; CHECK-NEXT:   }
entry:
  %0 = bitcast ptr %ptr to ptr 
  store float %a, ptr %0
  ret void
}

define i32 @storewf_r(float %a, ptr %ptr, ptr nocapture readonly %load) {
  ; CHECK-LABEL: name: storewf_r
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   liveins: $r0, $r1, $r2
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit-def $r2, implicit killed $r2 {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     $r2 = LWZri10 0, killed $r2, 0 :: (load (s32) from %ir.load)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r2, implicit killed $r2, implicit killed $r1, implicit killed $r0 {
  ; CHECK-NEXT:     MCYCLESp 3
  ; CHECK-NEXT:     $r2 = READYp1r killed $r2
  ; CHECK-NEXT:     STOREp killed $r1, killed $r0, 32, internal $r2
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r2, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 4
  ; CHECK-NEXT:     $r0 = COPYD killed $r2
  ; CHECK-NEXT:     RET implicit $ra, implicit internal $r0
  ; CHECK-NEXT:   }
entry:
  %0 = load i32, ptr %load
  %1 = tail call i64 (...) @llvm.kvx.ready(i32 %0)
  %conv = trunc i64 %1 to i32
  %2 = bitcast ptr %ptr to ptr 
  tail call void @llvm.kvx.store.f32.p0f32.i32(float %a, ptr %2, i32 32, i32 %conv)
  ret i32 %conv
}

declare void @llvm.kvx.store.f32.p0f32.i32(float, ptr, i32, i32)

define void @storedf(double %a, ptr nocapture %ptr) {
  ; CHECK-LABEL: name: storedf
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   liveins: $r0, $r1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit killed $r1, implicit killed $r0, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     SDri10 0, killed $r1, killed $r0 :: (store (s64) into %ir.0)
  ; CHECK-NEXT:     RET implicit $ra
  ; CHECK-NEXT:   }
entry:
  %0 = bitcast ptr %ptr to ptr 
  store double %a, ptr %0
  ret void
}

define i32 @storedf_r(double %a, ptr %ptr, ptr nocapture readonly %load) {
  ; CHECK-LABEL: name: storedf_r
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   liveins: $r0, $r1, $r2
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit-def $r2, implicit killed $r2 {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     $r2 = LWZri10 0, killed $r2, 0 :: (load (s32) from %ir.load)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r2, implicit killed $r2, implicit killed $r1, implicit killed $r0 {
  ; CHECK-NEXT:     MCYCLESp 3
  ; CHECK-NEXT:     $r2 = READYp1r killed $r2
  ; CHECK-NEXT:     STOREp killed $r1, killed $r0, 64, internal $r2
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r2, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 4
  ; CHECK-NEXT:     $r0 = COPYD killed $r2
  ; CHECK-NEXT:     RET implicit $ra, implicit internal $r0
  ; CHECK-NEXT:   }
entry:
  %0 = load i32, ptr %load
  %1 = tail call i64 (...) @llvm.kvx.ready(i32 %0)
  %conv = trunc i64 %1 to i32
  %2 = bitcast ptr %ptr to ptr 
  tail call void @llvm.kvx.store.f64.p0f64.i32(double %a, ptr %2, i32 64, i32 %conv)
  ret i32 %conv
}

declare void @llvm.kvx.store.f64.p0f64.i32(double, ptr, i32, i32)

define void @store64(<2 x i32> %a, ptr nocapture %ptr) {
  ; CHECK-LABEL: name: store64
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   liveins: $r0, $r1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit killed $r1, implicit killed $r0, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     SDri10 0, killed $r1, killed $r0 :: (store (s64) into %ir.0)
  ; CHECK-NEXT:     RET implicit $ra
  ; CHECK-NEXT:   }
entry:
  %0 = bitcast ptr %ptr to ptr 
  store <2 x i32> %a, ptr %0
  ret void
}

define i32 @store64_r(<2 x i32> %a, ptr %ptr, ptr nocapture readonly %load) {
  ; CHECK-LABEL: name: store64_r
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   liveins: $r0, $r1, $r2
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit-def $r2, implicit killed $r2 {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     $r2 = LWZri10 0, killed $r2, 0 :: (load (s32) from %ir.load)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r2, implicit killed $r2, implicit killed $r1, implicit killed $r0 {
  ; CHECK-NEXT:     MCYCLESp 3
  ; CHECK-NEXT:     $r2 = READYp1r killed $r2
  ; CHECK-NEXT:     STOREp killed $r1, killed $r0, 64, internal $r2
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r2, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 4
  ; CHECK-NEXT:     $r0 = COPYD killed $r2
  ; CHECK-NEXT:     RET implicit $ra, implicit internal $r0
  ; CHECK-NEXT:   }
entry:
  %0 = load i32, ptr %load
  %1 = tail call i64 (...) @llvm.kvx.ready(i32 %0)
  %conv = trunc i64 %1 to i32
  %2 = bitcast <2 x i32> %a to <1 x i64>
  %3 = extractelement <1 x i64> %2, i32 0
  %4 = bitcast ptr %ptr to ptr 
  tail call void @llvm.kvx.store.i64.p0i64.i32(i64 %3, ptr %4, i32 64, i32 %conv)
  ret i32 %conv
}

define void @store128(<4 x i32> %a, ptr nocapture %ptr) {
  ; CHECK-LABEL: name: store128
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   liveins: $r0, $r1, $r2
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit killed $r2, implicit killed $p0, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     SQri10 0, killed $r2, killed $p0 :: (store (s128) into %ir.0)
  ; CHECK-NEXT:     RET implicit $ra
  ; CHECK-NEXT:   }
entry:
  %0 = bitcast ptr %ptr to ptr 
  store <4 x i32> %a, ptr %0
  ret void
}

define i32 @store128_r(<4 x i32> %a, ptr %ptr, ptr nocapture readonly %load) {
  ; CHECK-LABEL: name: store128_r
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   liveins: $r0, $r1, $r2, $r3
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit-def $r3, implicit killed $r3 {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     $r3 = LWZri10 0, killed $r3, 0 :: (load (s32) from %ir.load)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r3, implicit killed $r3, implicit killed $r2, implicit killed $p0 {
  ; CHECK-NEXT:     MCYCLESp 3
  ; CHECK-NEXT:     $r3 = READYp1r killed $r3
  ; CHECK-NEXT:     STOREp killed $r2, killed $p0, 128, internal $r3
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r3, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 4
  ; CHECK-NEXT:     $r0 = COPYD killed $r3
  ; CHECK-NEXT:     RET implicit $ra, implicit internal $r0
  ; CHECK-NEXT:   }
entry:
  %0 = load i32, ptr %load
  %1 = tail call i64 (...) @llvm.kvx.ready(i32 %0)
  %conv = trunc i64 %1 to i32
  %2 = bitcast <4 x i32> %a to <2 x i64>
  %3 = bitcast ptr %ptr to ptr 
  tail call void @llvm.kvx.store.v2i64.p0v2i64.i32(<2 x i64> %2, ptr %3, i32 128, i32 %conv)
  ret i32 %conv
}

define void @store256(<8 x i32> %a, ptr nocapture %ptr) {
  ; CHECK-LABEL: name: store256
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   liveins: $r0, $r1, $r2, $r3, $r4
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit killed $r4, implicit killed $q0, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     SOri10 0, killed $r4, killed $q0 :: (store (s256) into %ir.0)
  ; CHECK-NEXT:     RET implicit $ra
  ; CHECK-NEXT:   }
entry:
  %0 = bitcast ptr %ptr to ptr 
  store <8 x i32> %a, ptr %0
  ret void
}

define i32 @store256_r(<8 x i32> %a, ptr %ptr, ptr nocapture readonly %load) {
  ; CHECK-LABEL: name: store256_r
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   liveins: $r0, $r1, $r2, $r3, $r4, $r5
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit-def $r5, implicit killed $r5 {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     $r5 = LWZri10 0, killed $r5, 0 :: (load (s32) from %ir.load)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r5, implicit killed $r5, implicit killed $r4, implicit killed $q0 {
  ; CHECK-NEXT:     MCYCLESp 3
  ; CHECK-NEXT:     $r5 = READYp1r killed $r5
  ; CHECK-NEXT:     STOREp killed $r4, killed $q0, 256, internal $r5
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r5, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 4
  ; CHECK-NEXT:     $r0 = COPYD killed $r5
  ; CHECK-NEXT:     RET implicit $ra, implicit internal $r0
  ; CHECK-NEXT:   }
entry:
  %0 = load i32, ptr %load
  %1 = tail call i64 (...) @llvm.kvx.ready(i32 %0)
  %conv = trunc i64 %1 to i32
  %2 = bitcast <8 x i32> %a to <4 x i64>
  %3 = bitcast ptr %ptr to ptr 
  tail call void @llvm.kvx.store.v4i64.p0v4i64.i32(<4 x i64> %2, ptr %3, i32 256, i32 %conv)
  ret i32 %conv
}

declare void @llvm.kvx.store.v4i64.p0v4i64.i32(<4 x i64>, ptr, i32, i32)

define void @store_vol(i32 %a, ptr %ptr) {
  ; CHECK-LABEL: name: store_vol
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   liveins: $r0, $r1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit $r1, implicit $r0 {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     SWri10 0, $r1, $r0 :: (volatile store (s32) into %ir.0)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit killed $r1, implicit killed $r0, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 1
  ; CHECK-NEXT:     SWri10 0, killed $r1, killed $r0 :: (volatile store (s32) into %ir.0)
  ; CHECK-NEXT:     RET implicit $ra
  ; CHECK-NEXT:   }
entry:
  %0 = bitcast ptr %ptr to ptr 
  store volatile i32 %a, ptr %0
  store volatile i32 %a, ptr %0
  ret void
}

define void @store_novol(i32 %a, ptr nocapture %ptr) {
  ; CHECK-LABEL: name: store_novol
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   liveins: $r0, $r1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit killed $r1, implicit killed $r0, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     SWri10 0, killed $r1, killed $r0 :: (store (s32) into %ir.0)
  ; CHECK-NEXT:     RET implicit $ra
  ; CHECK-NEXT:   }
entry:
  %0 = bitcast ptr %ptr to ptr 
  store i32 %a, ptr %0
  ret void
}

define i32 @store_r_vol(i32 %a, ptr %ptr, ptr nocapture readonly %load) {
  ; CHECK-LABEL: name: store_r_vol
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   liveins: $r0, $r1, $r2
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit-def $r2, implicit-def $r3, implicit killed $r2, implicit killed $r0 {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     $r2 = LWZri10 0, killed $r2, 0 :: (load (s32) from %ir.load)
  ; CHECK-NEXT:     $r3 = SXWD killed $r0
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r2, implicit $r1, implicit $r3 {
  ; CHECK-NEXT:     MCYCLESp 3
  ; CHECK-NEXT:     $r0 = READYp1r killed $r2
  ; CHECK-NEXT:     STOREpv $r1, $r3, 32, internal $r0
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit killed $r1, implicit killed $r3, implicit killed $r0, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 4
  ; CHECK-NEXT:     STOREpv killed $r1, killed $r3, 32, $r0
  ; CHECK-NEXT:     RET implicit $ra, implicit killed $r0
  ; CHECK-NEXT:   }
entry:
  %0 = load i32, ptr %load
  %1 = tail call i64 (...) @llvm.kvx.ready(i32 %0)
  %conv = trunc i64 %1 to i32
  %conv1 = sext i32 %a to i64
  %2 = bitcast ptr %ptr to ptr 
  tail call void @llvm.kvx.store.vol.i64.p0i64.i32(i64 %conv1, ptr %2, i32 32, i32 %conv)
  tail call void @llvm.kvx.store.vol.i64.p0i64.i32(i64 %conv1, ptr %2, i32 32, i32 %conv)
  ret i32 %conv
}

declare void @llvm.kvx.store.vol.i64.p0i64.i32(i64, ptr, i32, i32)

define i32 @store_r_novol(i32 %a, ptr %ptr, ptr nocapture readonly %load) {
  ; CHECK-LABEL: name: store_r_novol
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   liveins: $r0, $r1, $r2
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit-def $r2, implicit-def $r3, implicit killed $r2, implicit killed $r0 {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     $r2 = LWZri10 0, killed $r2, 0 :: (load (s32) from %ir.load)
  ; CHECK-NEXT:     $r3 = SXWD killed $r0
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r2, implicit $r1, implicit $r3 {
  ; CHECK-NEXT:     MCYCLESp 3
  ; CHECK-NEXT:     $r0 = READYp1r killed $r2
  ; CHECK-NEXT:     STOREp $r1, $r3, 32, internal $r0
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit killed $r1, implicit killed $r3, implicit killed $r0, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 4
  ; CHECK-NEXT:     STOREp killed $r1, killed $r3, 32, $r0
  ; CHECK-NEXT:     RET implicit $ra, implicit killed $r0
  ; CHECK-NEXT:   }
entry:
  %0 = load i32, ptr %load
  %1 = tail call i64 (...) @llvm.kvx.ready(i32 %0)
  %conv = trunc i64 %1 to i32
  %conv1 = sext i32 %a to i64
  %2 = bitcast ptr %ptr to ptr 
  tail call void @llvm.kvx.store.i64.p0i64.i32(i64 %conv1, ptr %2, i32 32, i32 %conv)
  tail call void @llvm.kvx.store.i64.p0i64.i32(i64 %conv1, ptr %2, i32 32, i32 %conv)
  ret i32 %conv
}

define void @ready_then_store(ptr nocapture readonly %addr0, ptr nocapture readonly %addr1, ptr nocapture readonly %addr2, ptr %to0, ptr %to1, ptr %to2) {
  ; CHECK-LABEL: name: ready_then_store
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   liveins: $r0, $r1, $r2, $r3, $r4, $r5
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r0 {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     $r0 = LWSri10 0, killed $r0, 0 :: (load (s32) from %ir.addr0)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r1, implicit killed $r1 {
  ; CHECK-NEXT:     MCYCLESp 1
  ; CHECK-NEXT:     $r1 = LWSri10 0, killed $r1, 0 :: (load (s32) from %ir.addr1)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r2, implicit killed $r2 {
  ; CHECK-NEXT:     MCYCLESp 2
  ; CHECK-NEXT:     $r2 = LWSri10 0, killed $r2, 0 :: (load (s32) from %ir.addr2)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r6, implicit killed $r0, implicit $r1, implicit $r2, implicit killed $r3 {
  ; CHECK-NEXT:     MCYCLESp 5
  ; CHECK-NEXT:     $r6 = READYp3r $r0, $r1, $r2
  ; CHECK-NEXT:     STOREp killed $r3, killed $r0, 32, internal $r6
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit killed $r4, implicit killed $r1, implicit $r6 {
  ; CHECK-NEXT:     MCYCLESp 6
  ; CHECK-NEXT:     STOREp killed $r4, killed $r1, 32, $r6
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit killed $r5, implicit killed $r2, implicit killed $r6, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 7
  ; CHECK-NEXT:     STOREp killed $r5, killed $r2, 32, killed $r6
  ; CHECK-NEXT:     RET implicit $ra
  ; CHECK-NEXT:   }
entry:
  %0 = load i32, ptr %addr0
  %1 = load i32, ptr %addr1
  %2 = load i32, ptr %addr2
  %3 = tail call i64 (...) @llvm.kvx.ready(i32 %0, i32 %1, i32 %2)
  %conv = trunc i64 %3 to i32
  %conv1 = sext i32 %0 to i64
  %4 = bitcast ptr %to0 to ptr 
  tail call void @llvm.kvx.store.i64.p0i64.i32(i64 %conv1, ptr %4, i32 32, i32 %conv)
  %conv2 = sext i32 %1 to i64
  %5 = bitcast ptr %to1 to ptr 
  tail call void @llvm.kvx.store.i64.p0i64.i32(i64 %conv2, ptr %5, i32 32, i32 %conv)
  %conv3 = sext i32 %2 to i64
  %6 = bitcast ptr %to2 to ptr 
  tail call void @llvm.kvx.store.i64.p0i64.i32(i64 %conv3, ptr %6, i32 32, i32 %conv)
  ret void
}

define void @load_then_store(ptr nocapture readonly %addr0, ptr nocapture readonly %addr1, ptr nocapture readonly %addr2, ptr nocapture %to0, ptr nocapture %to1, ptr nocapture %to2) {
  ; CHECK-LABEL: name: load_then_store
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   liveins: $r0, $r1, $r2, $r3, $r4, $r5
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r0 {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     $r0 = LWZri10 0, killed $r0, 0 :: (load (s32) from %ir.addr0)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r1, implicit killed $r1 {
  ; CHECK-NEXT:     MCYCLESp 1
  ; CHECK-NEXT:     $r1 = LWZri10 0, killed $r1, 0 :: (load (s32) from %ir.addr1)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r2, implicit killed $r2 {
  ; CHECK-NEXT:     MCYCLESp 2
  ; CHECK-NEXT:     $r2 = LWZri10 0, killed $r2, 0 :: (load (s32) from %ir.addr2)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit killed $r3, implicit killed $r0 {
  ; CHECK-NEXT:     MCYCLESp 3
  ; CHECK-NEXT:     SWri10 0, killed $r3, killed $r0 :: (store (s32) into %ir.to0)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit killed $r4, implicit killed $r1 {
  ; CHECK-NEXT:     MCYCLESp 4
  ; CHECK-NEXT:     SWri10 0, killed $r4, killed $r1 :: (store (s32) into %ir.to1)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit killed $r5, implicit killed $r2, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 5
  ; CHECK-NEXT:     SWri10 0, killed $r5, killed $r2 :: (store (s32) into %ir.to2)
  ; CHECK-NEXT:     RET implicit $ra
  ; CHECK-NEXT:   }
entry:
  %0 = load i32, ptr %addr0
  %1 = load i32, ptr %addr1
  %2 = load i32, ptr %addr2
  store i32 %0, ptr %to0
  store i32 %1, ptr %to1
  store i32 %2, ptr %to2
  ret void
}

