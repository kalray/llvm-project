; NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
; RUN: llc -mcpu=kv3-2 --stop-before=kvx-preemit-expand-pseudo,3 -o - %s -O2 | FileCheck %s --check-prefixes=CHECK

target triple = "kvx-kalray-cos"

define void @storeb(i64 %a, i8* nocapture %ptr) {
  ; CHECK-LABEL: name: storeb
  ; CHECK: bb.0.entry:
  ; CHECK:   liveins: $r0, $r1
  ; CHECK:   BUNDLE implicit killed $r1, implicit killed $r0, implicit $ra {
  ; CHECK:     SBri10 0, killed $r1, killed $r0 :: (store 1 into %ir.ptr)
  ; CHECK:     RET implicit $ra
  ; CHECK:   }
entry:
  %0 = trunc i64 %a to i8
  store i8 %0, i8* %ptr
  ret void
}

define i32 @storeb_r(i64 %a, i8* %ptr, i32* nocapture readonly %load) {
  ; CHECK-LABEL: name: storeb_r
  ; CHECK: bb.0.entry:
  ; CHECK:   liveins: $r0, $r1, $r2
  ; CHECK:   BUNDLE implicit-def $r2, implicit killed $r2 {
  ; CHECK:     $r2 = LWZri10 0, killed $r2, 0 :: (load 4 from %ir.load)
  ; CHECK:   }
  ; CHECK:   BUNDLE implicit-def $r2, implicit killed $r2, implicit killed $r1, implicit killed $r0 {
  ; CHECK:     $r2 = READYp1r killed $r2
  ; CHECK:     STOREp killed $r1, killed $r0, 8, internal $r2
  ; CHECK:   }
  ; CHECK:   BUNDLE implicit-def $r0, implicit killed $r2, implicit $ra {
  ; CHECK:     $r0 = COPYD killed $r2
  ; CHECK:     RET implicit $ra, implicit internal $r0
  ; CHECK:   }
entry:
  %0 = load i32, i32* %load
  %1 = tail call i64 (...) @llvm.kvx.ready(i32 %0)
  %conv = trunc i64 %1 to i32
  %2 = bitcast i8* %ptr to i64*
  tail call void @llvm.kvx.store.i64.p0i64.i32(i64 %a, i64* %2, i32 8, i32 %conv)
  ret i32 %conv
}

declare i64 @llvm.kvx.ready(...)

declare void @llvm.kvx.store.i64.p0i64.i32(i64, i64*, i32, i32)

define void @storeh(i64 %a, i8* nocapture %ptr) {
  ; CHECK-LABEL: name: storeh
  ; CHECK: bb.0.entry:
  ; CHECK:   liveins: $r0, $r1
  ; CHECK:   BUNDLE implicit killed $r1, implicit killed $r0, implicit $ra {
  ; CHECK:     SHri10 0, killed $r1, killed $r0 :: (store 2 into %ir.1)
  ; CHECK:     RET implicit $ra
  ; CHECK:   }
entry:
  %0 = trunc i64 %a to i16
  %1 = bitcast i8* %ptr to i16*
  store i16 %0, i16* %1
  ret void
}

define i32 @storeh_r(i64 %a, i8* %ptr, i32* nocapture readonly %load) {
  ; CHECK-LABEL: name: storeh_r
  ; CHECK: bb.0.entry:
  ; CHECK:   liveins: $r0, $r1, $r2
  ; CHECK:   BUNDLE implicit-def $r2, implicit killed $r2 {
  ; CHECK:     $r2 = LWZri10 0, killed $r2, 0 :: (load 4 from %ir.load)
  ; CHECK:   }
  ; CHECK:   BUNDLE implicit-def $r2, implicit killed $r2, implicit killed $r1, implicit killed $r0 {
  ; CHECK:     $r2 = READYp1r killed $r2
  ; CHECK:     STOREp killed $r1, killed $r0, 16, internal $r2
  ; CHECK:   }
  ; CHECK:   BUNDLE implicit-def $r0, implicit killed $r2, implicit $ra {
  ; CHECK:     $r0 = COPYD killed $r2
  ; CHECK:     RET implicit $ra, implicit internal $r0
  ; CHECK:   }
entry:
  %0 = load i32, i32* %load
  %1 = tail call i64 (...) @llvm.kvx.ready(i32 %0)
  %conv = trunc i64 %1 to i32
  %2 = bitcast i8* %ptr to i64*
  tail call void @llvm.kvx.store.i64.p0i64.i32(i64 %a, i64* %2, i32 16, i32 %conv)
  ret i32 %conv
}

define void @storew(i64 %a, i8* nocapture %ptr) {
  ; CHECK-LABEL: name: storew
  ; CHECK: bb.0.entry:
  ; CHECK:   liveins: $r0, $r1
  ; CHECK:   BUNDLE implicit killed $r1, implicit killed $r0, implicit $ra {
  ; CHECK:     SWri10 0, killed $r1, killed $r0 :: (store 4 into %ir.1)
  ; CHECK:     RET implicit $ra
  ; CHECK:   }
entry:
  %0 = trunc i64 %a to i32
  %1 = bitcast i8* %ptr to i32*
  store i32 %0, i32* %1
  ret void
}

define i32 @storew_r(i64 %a, i8* %ptr, i32* nocapture readonly %load) {
  ; CHECK-LABEL: name: storew_r
  ; CHECK: bb.0.entry:
  ; CHECK:   liveins: $r0, $r1, $r2
  ; CHECK:   BUNDLE implicit-def $r2, implicit killed $r2 {
  ; CHECK:     $r2 = LWZri10 0, killed $r2, 0 :: (load 4 from %ir.load)
  ; CHECK:   }
  ; CHECK:   BUNDLE implicit-def $r2, implicit killed $r2, implicit killed $r1, implicit killed $r0 {
  ; CHECK:     $r2 = READYp1r killed $r2
  ; CHECK:     STOREp killed $r1, killed $r0, 32, internal $r2
  ; CHECK:   }
  ; CHECK:   BUNDLE implicit-def $r0, implicit killed $r2, implicit $ra {
  ; CHECK:     $r0 = COPYD killed $r2
  ; CHECK:     RET implicit $ra, implicit internal $r0
  ; CHECK:   }
entry:
  %0 = load i32, i32* %load
  %1 = tail call i64 (...) @llvm.kvx.ready(i32 %0)
  %conv = trunc i64 %1 to i32
  %2 = bitcast i8* %ptr to i64*
  tail call void @llvm.kvx.store.i64.p0i64.i32(i64 %a, i64* %2, i32 32, i32 %conv)
  ret i32 %conv
}

define void @stored(i64 %a, i8* nocapture %ptr) {
  ; CHECK-LABEL: name: stored
  ; CHECK: bb.0.entry:
  ; CHECK:   liveins: $r0, $r1
  ; CHECK:   BUNDLE implicit killed $r1, implicit killed $r0, implicit $ra {
  ; CHECK:     SDri10 0, killed $r1, killed $r0 :: (store 8 into %ir.0)
  ; CHECK:     RET implicit $ra
  ; CHECK:   }
entry:
  %0 = bitcast i8* %ptr to i64*
  store i64 %a, i64* %0
  ret void
}

define i32 @stored_r(i64 %a, i8* %ptr, i32* nocapture readonly %load) {
  ; CHECK-LABEL: name: stored_r
  ; CHECK: bb.0.entry:
  ; CHECK:   liveins: $r0, $r1, $r2
  ; CHECK:   BUNDLE implicit-def $r2, implicit killed $r2 {
  ; CHECK:     $r2 = LWZri10 0, killed $r2, 0 :: (load 4 from %ir.load)
  ; CHECK:   }
  ; CHECK:   BUNDLE implicit-def $r2, implicit killed $r2, implicit killed $r1, implicit killed $r0 {
  ; CHECK:     $r2 = READYp1r killed $r2
  ; CHECK:     STOREp killed $r1, killed $r0, 64, internal $r2
  ; CHECK:   }
  ; CHECK:   BUNDLE implicit-def $r0, implicit killed $r2, implicit $ra {
  ; CHECK:     $r0 = COPYD killed $r2
  ; CHECK:     RET implicit $ra, implicit internal $r0
  ; CHECK:   }
entry:
  %0 = load i32, i32* %load
  %1 = tail call i64 (...) @llvm.kvx.ready(i32 %0)
  %conv = trunc i64 %1 to i32
  %2 = bitcast i8* %ptr to i64*
  tail call void @llvm.kvx.store.i64.p0i64.i32(i64 %a, i64* %2, i32 64, i32 %conv)
  ret i32 %conv
}

define void @storeq(i128 %a, i8* nocapture %ptr) {
  ; CHECK-LABEL: name: storeq
  ; CHECK: bb.0.entry:
  ; CHECK:   liveins: $r0, $r1, $r2
  ; CHECK:   BUNDLE implicit killed $r2, implicit killed $p0, implicit $ra {
  ; CHECK:     SQri10 0, killed $r2, killed $p0 :: (store 16)
  ; CHECK:     RET implicit $ra
  ; CHECK:   }
entry:
  %0 = bitcast i8* %ptr to i128*
  store i128 %a, i128* %0
  ret void
}

define i32 @storeq_r(i128 %a, i8* %ptr, i32* nocapture readonly %load) {
  ; CHECK-LABEL: name: storeq_r
  ; CHECK: bb.0.entry:
  ; CHECK:   liveins: $r0, $r1, $r2, $r3
  ; CHECK:   BUNDLE implicit-def $r3, implicit killed $r3 {
  ; CHECK:     $r3 = LWZri10 0, killed $r3, 0 :: (load 4 from %ir.load)
  ; CHECK:   }
  ; CHECK:   BUNDLE implicit-def $r3, implicit killed $r3, implicit killed $r2, implicit killed $p0 {
  ; CHECK:     $r3 = READYp1r killed $r3
  ; CHECK:     STOREp killed $r2, killed $p0, 128, internal $r3
  ; CHECK:   }
  ; CHECK:   BUNDLE implicit-def $r0, implicit killed $r3, implicit $ra {
  ; CHECK:     $r0 = COPYD killed $r3
  ; CHECK:     RET implicit $ra, implicit internal $r0
  ; CHECK:   }
entry:
  %0 = load i32, i32* %load
  %1 = tail call i64 (...) @llvm.kvx.ready(i32 %0)
  %conv = trunc i64 %1 to i32
  %2 = bitcast i128 %a to <2 x i64>
  %3 = bitcast i8* %ptr to <2 x i64>*
  tail call void @llvm.kvx.store.v2i64.p0v2i64.i32(<2 x i64> %2, <2 x i64>* %3, i32 128, i32 %conv)
  ret i32 %conv
}

declare void @llvm.kvx.store.v2i64.p0v2i64.i32(<2 x i64>, <2 x i64>*, i32, i32)

define void @storehf(half %a, i8* nocapture %ptr) {
  ; CHECK-LABEL: name: storehf
  ; CHECK: bb.0.entry:
  ; CHECK:   liveins: $r0, $r1
  ; CHECK:   BUNDLE implicit killed $r1, implicit killed $r0, implicit $ra {
  ; CHECK:     SHri10 0, killed $r1, killed $r0 :: (store 2 into %ir.0)
  ; CHECK:     RET implicit $ra
  ; CHECK:   }
entry:
  %0 = bitcast i8* %ptr to half*
  store half %a, half* %0
  ret void
}

define i32 @storehf_r(half %a, i8* %ptr, i32* nocapture readonly %load) {
  ; CHECK-LABEL: name: storehf_r
  ; CHECK: bb.0.entry:
  ; CHECK:   liveins: $r0, $r1, $r2
  ; CHECK:   BUNDLE implicit-def $r2, implicit killed $r2 {
  ; CHECK:     $r2 = LWZri10 0, killed $r2, 0 :: (load 4 from %ir.load)
  ; CHECK:   }
  ; CHECK:   BUNDLE implicit-def $r2, implicit killed $r2, implicit killed $r1, implicit killed $r0 {
  ; CHECK:     $r2 = READYp1r killed $r2
  ; CHECK:     STOREp killed $r1, killed $r0, 16, internal $r2
  ; CHECK:   }
  ; CHECK:   BUNDLE implicit-def $r0, implicit killed $r2, implicit $ra {
  ; CHECK:     $r0 = COPYD killed $r2
  ; CHECK:     RET implicit $ra, implicit internal $r0
  ; CHECK:   }
entry:
  %0 = load i32, i32* %load
  %1 = tail call i64 (...) @llvm.kvx.ready(i32 %0)
  %conv = trunc i64 %1 to i32
  %2 = bitcast i8* %ptr to half*
  tail call void @llvm.kvx.store.f16.p0f16.i32(half %a, half* %2, i32 16, i32 %conv)
  ret i32 %conv
}

declare void @llvm.kvx.store.f16.p0f16.i32(half, half*, i32, i32)

define void @storewf(float %a, i8* nocapture %ptr) {
  ; CHECK-LABEL: name: storewf
  ; CHECK: bb.0.entry:
  ; CHECK:   liveins: $r0, $r1
  ; CHECK:   BUNDLE implicit killed $r1, implicit killed $r0, implicit $ra {
  ; CHECK:     SWri10 0, killed $r1, killed $r0 :: (store 4 into %ir.0)
  ; CHECK:     RET implicit $ra
  ; CHECK:   }
entry:
  %0 = bitcast i8* %ptr to float*
  store float %a, float* %0
  ret void
}

define i32 @storewf_r(float %a, i8* %ptr, i32* nocapture readonly %load) {
  ; CHECK-LABEL: name: storewf_r
  ; CHECK: bb.0.entry:
  ; CHECK:   liveins: $r0, $r1, $r2
  ; CHECK:   BUNDLE implicit-def $r2, implicit killed $r2 {
  ; CHECK:     $r2 = LWZri10 0, killed $r2, 0 :: (load 4 from %ir.load)
  ; CHECK:   }
  ; CHECK:   BUNDLE implicit-def $r2, implicit killed $r2, implicit killed $r1, implicit killed $r0 {
  ; CHECK:     $r2 = READYp1r killed $r2
  ; CHECK:     STOREp killed $r1, killed $r0, 32, internal $r2
  ; CHECK:   }
  ; CHECK:   BUNDLE implicit-def $r0, implicit killed $r2, implicit $ra {
  ; CHECK:     $r0 = COPYD killed $r2
  ; CHECK:     RET implicit $ra, implicit internal $r0
  ; CHECK:   }
entry:
  %0 = load i32, i32* %load
  %1 = tail call i64 (...) @llvm.kvx.ready(i32 %0)
  %conv = trunc i64 %1 to i32
  %2 = bitcast i8* %ptr to float*
  tail call void @llvm.kvx.store.f32.p0f32.i32(float %a, float* %2, i32 32, i32 %conv)
  ret i32 %conv
}

declare void @llvm.kvx.store.f32.p0f32.i32(float, float*, i32, i32)

define void @storedf(double %a, i8* nocapture %ptr) {
  ; CHECK-LABEL: name: storedf
  ; CHECK: bb.0.entry:
  ; CHECK:   liveins: $r0, $r1
  ; CHECK:   BUNDLE implicit killed $r1, implicit killed $r0, implicit $ra {
  ; CHECK:     SDri10 0, killed $r1, killed $r0 :: (store 8 into %ir.0)
  ; CHECK:     RET implicit $ra
  ; CHECK:   }
entry:
  %0 = bitcast i8* %ptr to double*
  store double %a, double* %0
  ret void
}

define i32 @storedf_r(double %a, i8* %ptr, i32* nocapture readonly %load) {
  ; CHECK-LABEL: name: storedf_r
  ; CHECK: bb.0.entry:
  ; CHECK:   liveins: $r0, $r1, $r2
  ; CHECK:   BUNDLE implicit-def $r2, implicit killed $r2 {
  ; CHECK:     $r2 = LWZri10 0, killed $r2, 0 :: (load 4 from %ir.load)
  ; CHECK:   }
  ; CHECK:   BUNDLE implicit-def $r2, implicit killed $r2, implicit killed $r1, implicit killed $r0 {
  ; CHECK:     $r2 = READYp1r killed $r2
  ; CHECK:     STOREp killed $r1, killed $r0, 64, internal $r2
  ; CHECK:   }
  ; CHECK:   BUNDLE implicit-def $r0, implicit killed $r2, implicit $ra {
  ; CHECK:     $r0 = COPYD killed $r2
  ; CHECK:     RET implicit $ra, implicit internal $r0
  ; CHECK:   }
entry:
  %0 = load i32, i32* %load
  %1 = tail call i64 (...) @llvm.kvx.ready(i32 %0)
  %conv = trunc i64 %1 to i32
  %2 = bitcast i8* %ptr to double*
  tail call void @llvm.kvx.store.f64.p0f64.i32(double %a, double* %2, i32 64, i32 %conv)
  ret i32 %conv
}

declare void @llvm.kvx.store.f64.p0f64.i32(double, double*, i32, i32)

define void @store64(<2 x i32> %a, i8* nocapture %ptr) {
  ; CHECK-LABEL: name: store64
  ; CHECK: bb.0.entry:
  ; CHECK:   liveins: $r0, $r1
  ; CHECK:   BUNDLE implicit killed $r1, implicit killed $r0, implicit $ra {
  ; CHECK:     SDri10 0, killed $r1, killed $r0 :: (store 8 into %ir.0)
  ; CHECK:     RET implicit $ra
  ; CHECK:   }
entry:
  %0 = bitcast i8* %ptr to <2 x i32>*
  store <2 x i32> %a, <2 x i32>* %0
  ret void
}

define i32 @store64_r(<2 x i32> %a, i8* %ptr, i32* nocapture readonly %load) {
  ; CHECK-LABEL: name: store64_r
  ; CHECK: bb.0.entry:
  ; CHECK:   liveins: $r0, $r1, $r2
  ; CHECK:   BUNDLE implicit-def $r2, implicit killed $r2 {
  ; CHECK:     $r2 = LWZri10 0, killed $r2, 0 :: (load 4 from %ir.load)
  ; CHECK:   }
  ; CHECK:   BUNDLE implicit-def $r2, implicit killed $r2, implicit killed $r1, implicit killed $r0 {
  ; CHECK:     $r2 = READYp1r killed $r2
  ; CHECK:     STOREp killed $r1, killed $r0, 64, internal $r2
  ; CHECK:   }
  ; CHECK:   BUNDLE implicit-def $r0, implicit killed $r2, implicit $ra {
  ; CHECK:     $r0 = COPYD killed $r2
  ; CHECK:     RET implicit $ra, implicit internal $r0
  ; CHECK:   }
entry:
  %0 = load i32, i32* %load
  %1 = tail call i64 (...) @llvm.kvx.ready(i32 %0)
  %conv = trunc i64 %1 to i32
  %2 = bitcast <2 x i32> %a to <1 x i64>
  %3 = extractelement <1 x i64> %2, i32 0
  %4 = bitcast i8* %ptr to i64*
  tail call void @llvm.kvx.store.i64.p0i64.i32(i64 %3, i64* %4, i32 64, i32 %conv)
  ret i32 %conv
}

define void @store128(<4 x i32> %a, i8* nocapture %ptr) {
  ; CHECK-LABEL: name: store128
  ; CHECK: bb.0.entry:
  ; CHECK:   liveins: $r0, $r1, $r2
  ; CHECK:   BUNDLE implicit killed $r2, implicit killed $p0, implicit $ra {
  ; CHECK:     SQri10 0, killed $r2, killed $p0 :: (store 16 into %ir.0)
  ; CHECK:     RET implicit $ra
  ; CHECK:   }
entry:
  %0 = bitcast i8* %ptr to <4 x i32>*
  store <4 x i32> %a, <4 x i32>* %0
  ret void
}

define i32 @store128_r(<4 x i32> %a, i8* %ptr, i32* nocapture readonly %load) {
  ; CHECK-LABEL: name: store128_r
  ; CHECK: bb.0.entry:
  ; CHECK:   liveins: $r0, $r1, $r2, $r3
  ; CHECK:   BUNDLE implicit-def $r3, implicit killed $r3 {
  ; CHECK:     $r3 = LWZri10 0, killed $r3, 0 :: (load 4 from %ir.load)
  ; CHECK:   }
  ; CHECK:   BUNDLE implicit-def $r3, implicit killed $r3, implicit killed $r2, implicit killed $p0 {
  ; CHECK:     $r3 = READYp1r killed $r3
  ; CHECK:     STOREp killed $r2, killed $p0, 128, internal $r3
  ; CHECK:   }
  ; CHECK:   BUNDLE implicit-def $r0, implicit killed $r3, implicit $ra {
  ; CHECK:     $r0 = COPYD killed $r3
  ; CHECK:     RET implicit $ra, implicit internal $r0
  ; CHECK:   }
entry:
  %0 = load i32, i32* %load
  %1 = tail call i64 (...) @llvm.kvx.ready(i32 %0)
  %conv = trunc i64 %1 to i32
  %2 = bitcast <4 x i32> %a to <2 x i64>
  %3 = bitcast i8* %ptr to <2 x i64>*
  tail call void @llvm.kvx.store.v2i64.p0v2i64.i32(<2 x i64> %2, <2 x i64>* %3, i32 128, i32 %conv)
  ret i32 %conv
}

define void @store256(<8 x i32> %a, i8* nocapture %ptr) {
  ; CHECK-LABEL: name: store256
  ; CHECK: bb.0.entry:
  ; CHECK:   liveins: $r0, $r1, $r2, $r3, $r4
  ; CHECK:   BUNDLE implicit killed $r4, implicit killed $q0, implicit $ra {
  ; CHECK:     SOri10 0, killed $r4, killed $q0 :: (store 32 into %ir.0)
  ; CHECK:     RET implicit $ra
  ; CHECK:   }
entry:
  %0 = bitcast i8* %ptr to <8 x i32>*
  store <8 x i32> %a, <8 x i32>* %0
  ret void
}

define i32 @store256_r(<8 x i32> %a, i8* %ptr, i32* nocapture readonly %load) {
  ; CHECK-LABEL: name: store256_r
  ; CHECK: bb.0.entry:
  ; CHECK:   liveins: $r0, $r1, $r2, $r3, $r4, $r5
  ; CHECK:   BUNDLE implicit-def $r5, implicit killed $r5 {
  ; CHECK:     $r5 = LWZri10 0, killed $r5, 0 :: (load 4 from %ir.load)
  ; CHECK:   }
  ; CHECK:   BUNDLE implicit-def $r5, implicit killed $r5, implicit killed $r4, implicit killed $q0 {
  ; CHECK:     $r5 = READYp1r killed $r5
  ; CHECK:     STOREp killed $r4, killed $q0, 256, internal $r5
  ; CHECK:   }
  ; CHECK:   BUNDLE implicit-def $r0, implicit killed $r5, implicit $ra {
  ; CHECK:     $r0 = COPYD killed $r5
  ; CHECK:     RET implicit $ra, implicit internal $r0
  ; CHECK:   }
entry:
  %0 = load i32, i32* %load
  %1 = tail call i64 (...) @llvm.kvx.ready(i32 %0)
  %conv = trunc i64 %1 to i32
  %2 = bitcast <8 x i32> %a to <4 x i64>
  %3 = bitcast i8* %ptr to <4 x i64>*
  tail call void @llvm.kvx.store.v4i64.p0v4i64.i32(<4 x i64> %2, <4 x i64>* %3, i32 256, i32 %conv)
  ret i32 %conv
}

declare void @llvm.kvx.store.v4i64.p0v4i64.i32(<4 x i64>, <4 x i64>*, i32, i32)

define void @store_vol(i32 %a, i8* %ptr) {
  ; CHECK-LABEL: name: store_vol
  ; CHECK: bb.0.entry:
  ; CHECK:   liveins: $r0, $r1
  ; CHECK:   BUNDLE implicit $r1, implicit $r0 {
  ; CHECK:     SWri10 0, $r1, $r0 :: (volatile store 4 into %ir.0)
  ; CHECK:   }
  ; CHECK:   BUNDLE implicit killed $r1, implicit killed $r0, implicit $ra {
  ; CHECK:     SWri10 0, killed $r1, killed $r0 :: (volatile store 4 into %ir.0)
  ; CHECK:     RET implicit $ra
  ; CHECK:   }
entry:
  %0 = bitcast i8* %ptr to i32*
  store volatile i32 %a, i32* %0
  store volatile i32 %a, i32* %0
  ret void
}

define void @store_novol(i32 %a, i8* nocapture %ptr) {
  ; CHECK-LABEL: name: store_novol
  ; CHECK: bb.0.entry:
  ; CHECK:   liveins: $r0, $r1
  ; CHECK:   BUNDLE implicit killed $r1, implicit killed $r0, implicit $ra {
  ; CHECK:     SWri10 0, killed $r1, killed $r0 :: (store 4 into %ir.0)
  ; CHECK:     RET implicit $ra
  ; CHECK:   }
entry:
  %0 = bitcast i8* %ptr to i32*
  store i32 %a, i32* %0
  ret void
}

define i32 @store_r_vol(i32 %a, i8* %ptr, i32* nocapture readonly %load) {
  ; CHECK-LABEL: name: store_r_vol
  ; CHECK: bb.0.entry:
  ; CHECK:   liveins: $r0, $r1, $r2
  ; CHECK:   BUNDLE implicit-def $r2, implicit-def $r3, implicit killed $r2, implicit killed $r0 {
  ; CHECK:     $r2 = LWZri10 0, killed $r2, 0 :: (load 4 from %ir.load)
  ; CHECK:     $r3 = SXWD killed $r0
  ; CHECK:   }
  ; CHECK:   BUNDLE implicit-def $r0, implicit killed $r2, implicit $r1, implicit $r3 {
  ; CHECK:     $r0 = READYp1r killed $r2
  ; CHECK:     STOREpv $r1, $r3, 32, internal $r0
  ; CHECK:   }
  ; CHECK:   BUNDLE implicit killed $r1, implicit killed $r3, implicit killed $r0, implicit $ra {
  ; CHECK:     STOREpv killed $r1, killed $r3, 32, $r0
  ; CHECK:     RET implicit $ra, implicit killed $r0
  ; CHECK:   }
entry:
  %0 = load i32, i32* %load
  %1 = tail call i64 (...) @llvm.kvx.ready(i32 %0)
  %conv = trunc i64 %1 to i32
  %conv1 = sext i32 %a to i64
  %2 = bitcast i8* %ptr to i64*
  tail call void @llvm.kvx.store.vol.i64.p0i64.i32(i64 %conv1, i64* %2, i32 32, i32 %conv)
  tail call void @llvm.kvx.store.vol.i64.p0i64.i32(i64 %conv1, i64* %2, i32 32, i32 %conv)
  ret i32 %conv
}

declare void @llvm.kvx.store.vol.i64.p0i64.i32(i64, i64*, i32, i32)

define i32 @store_r_novol(i32 %a, i8* %ptr, i32* nocapture readonly %load) {
  ; CHECK-LABEL: name: store_r_novol
  ; CHECK: bb.0.entry:
  ; CHECK:   liveins: $r0, $r1, $r2
  ; CHECK:   BUNDLE implicit-def $r2, implicit-def $r3, implicit killed $r2, implicit killed $r0 {
  ; CHECK:     $r2 = LWZri10 0, killed $r2, 0 :: (load 4 from %ir.load)
  ; CHECK:     $r3 = SXWD killed $r0
  ; CHECK:   }
  ; CHECK:   BUNDLE implicit-def $r0, implicit killed $r2, implicit $r1, implicit $r3 {
  ; CHECK:     $r0 = READYp1r killed $r2
  ; CHECK:     STOREp $r1, $r3, 32, internal $r0
  ; CHECK:   }
  ; CHECK:   BUNDLE implicit killed $r1, implicit killed $r3, implicit killed $r0, implicit $ra {
  ; CHECK:     STOREp killed $r1, killed $r3, 32, $r0
  ; CHECK:     RET implicit $ra, implicit killed $r0
  ; CHECK:   }
entry:
  %0 = load i32, i32* %load
  %1 = tail call i64 (...) @llvm.kvx.ready(i32 %0)
  %conv = trunc i64 %1 to i32
  %conv1 = sext i32 %a to i64
  %2 = bitcast i8* %ptr to i64*
  tail call void @llvm.kvx.store.i64.p0i64.i32(i64 %conv1, i64* %2, i32 32, i32 %conv)
  tail call void @llvm.kvx.store.i64.p0i64.i32(i64 %conv1, i64* %2, i32 32, i32 %conv)
  ret i32 %conv
}

define void @ready_then_store(i32* nocapture readonly %addr0, i32* nocapture readonly %addr1, i32* nocapture readonly %addr2, i32* %to0, i32* %to1, i32* %to2) {
  ; CHECK-LABEL: name: ready_then_store
  ; CHECK: bb.0.entry:
  ; CHECK:   liveins: $r0, $r1, $r2, $r3, $r4, $r5
  ; CHECK:   BUNDLE implicit-def $r0, implicit killed $r0 {
  ; CHECK:     $r0 = LWSri10 0, killed $r0, 0 :: (load 4 from %ir.addr0)
  ; CHECK:   }
  ; CHECK:   BUNDLE implicit-def $r1, implicit killed $r1 {
  ; CHECK:     $r1 = LWSri10 0, killed $r1, 0 :: (load 4 from %ir.addr1)
  ; CHECK:   }
  ; CHECK:   BUNDLE implicit-def $r2, implicit killed $r2 {
  ; CHECK:     $r2 = LWSri10 0, killed $r2, 0 :: (load 4 from %ir.addr2)
  ; CHECK:   }
  ; CHECK:   BUNDLE implicit-def $r6, implicit killed $r0, implicit $r1, implicit $r2, implicit killed $r3 {
  ; CHECK:     $r6 = READYp3r $r0, $r1, $r2
  ; CHECK:     STOREp killed $r3, killed $r0, 32, internal $r6
  ; CHECK:   }
  ; CHECK:   BUNDLE implicit killed $r4, implicit killed $r1, implicit $r6 {
  ; CHECK:     STOREp killed $r4, killed $r1, 32, $r6
  ; CHECK:   }
  ; CHECK:   BUNDLE implicit killed $r5, implicit killed $r2, implicit killed $r6, implicit $ra {
  ; CHECK:     STOREp killed $r5, killed $r2, 32, killed $r6
  ; CHECK:     RET implicit $ra
  ; CHECK:   }
entry:
  %0 = load i32, i32* %addr0
  %1 = load i32, i32* %addr1
  %2 = load i32, i32* %addr2
  %3 = tail call i64 (...) @llvm.kvx.ready(i32 %0, i32 %1, i32 %2)
  %conv = trunc i64 %3 to i32
  %conv1 = sext i32 %0 to i64
  %4 = bitcast i32* %to0 to i64*
  tail call void @llvm.kvx.store.i64.p0i64.i32(i64 %conv1, i64* %4, i32 32, i32 %conv)
  %conv2 = sext i32 %1 to i64
  %5 = bitcast i32* %to1 to i64*
  tail call void @llvm.kvx.store.i64.p0i64.i32(i64 %conv2, i64* %5, i32 32, i32 %conv)
  %conv3 = sext i32 %2 to i64
  %6 = bitcast i32* %to2 to i64*
  tail call void @llvm.kvx.store.i64.p0i64.i32(i64 %conv3, i64* %6, i32 32, i32 %conv)
  ret void
}

define void @load_then_store(i32* nocapture readonly %addr0, i32* nocapture readonly %addr1, i32* nocapture readonly %addr2, i32* nocapture %to0, i32* nocapture %to1, i32* nocapture %to2) {
  ; CHECK-LABEL: name: load_then_store
  ; CHECK: bb.0.entry:
  ; CHECK:   liveins: $r0, $r1, $r2, $r3, $r4, $r5
  ; CHECK:   BUNDLE implicit-def $r0, implicit killed $r0 {
  ; CHECK:     $r0 = LWZri10 0, killed $r0, 0 :: (load 4 from %ir.addr0)
  ; CHECK:   }
  ; CHECK:   BUNDLE implicit-def $r1, implicit killed $r1 {
  ; CHECK:     $r1 = LWZri10 0, killed $r1, 0 :: (load 4 from %ir.addr1)
  ; CHECK:   }
  ; CHECK:   BUNDLE implicit-def $r2, implicit killed $r2 {
  ; CHECK:     $r2 = LWZri10 0, killed $r2, 0 :: (load 4 from %ir.addr2)
  ; CHECK:   }
  ; CHECK:   BUNDLE implicit killed $r3, implicit killed $r0 {
  ; CHECK:     SWri10 0, killed $r3, killed $r0 :: (store 4 into %ir.to0)
  ; CHECK:   }
  ; CHECK:   BUNDLE implicit killed $r4, implicit killed $r1 {
  ; CHECK:     SWri10 0, killed $r4, killed $r1 :: (store 4 into %ir.to1)
  ; CHECK:   }
  ; CHECK:   BUNDLE implicit killed $r5, implicit killed $r2, implicit $ra {
  ; CHECK:     SWri10 0, killed $r5, killed $r2 :: (store 4 into %ir.to2)
  ; CHECK:     RET implicit $ra
  ; CHECK:   }
entry:
  %0 = load i32, i32* %addr0
  %1 = load i32, i32* %addr1
  %2 = load i32, i32* %addr2
  store i32 %0, i32* %to0
  store i32 %1, i32* %to1
  store i32 %2, i32* %to2
  ret void
}

