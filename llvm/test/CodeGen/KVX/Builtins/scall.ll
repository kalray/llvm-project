; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -o - %s -O2 | FileCheck %s --check-prefixes=CHECK,CV1
; RUN: llc -mcpu=kv3-2 -o - %s -O2 | FileCheck %s --check-prefixes=CHECK,CV2
; RUN: clang -O2 -c -o /dev/null %s
; RUN: clang -march=kv3-2 -O2 -c -o /dev/null %s

target triple = "kvx-kalray-cos"

define i64 @scall0(i32 noundef %id) {
; CHECK-LABEL: scall0:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    zxwd $r0 = $r0
; CHECK-NEXT:    addd $r12 = $r12, -32
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 24[$r12] = $r16
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    scall $r0
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ld $r16 = 24[$r12]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 32
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = zext i32 %id to i64
  %1 = inttoptr i64 %0 to ptr addrspace(259)
  %2 = notail call addrspace(259) i64 %1()
  ret i64 %2
}

define i64 @scall1(i32 noundef %id, i64 noundef %arg1) {
; CHECK-LABEL: scall1:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    zxwd $r2 = $r0
; CHECK-NEXT:    addd $r12 = $r12, -32
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 24[$r12] = $r16
; CHECK-NEXT:    copyd $r0 = $r1
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    scall $r2
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ld $r16 = 24[$r12]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 32
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = zext i32 %id to i64
  %1 = inttoptr i64 %0 to ptr addrspace(259)
  %2 = notail call addrspace(259) i64 %1(i64 %arg1)
  ret i64 %2
}

define i64 @scall2(i32 noundef %id, i8 noundef %arg1, ptr noundef %arg2) {
; CHECK-LABEL: scall2:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    zxwd $r3 = $r0
; CHECK-NEXT:    addd $r12 = $r12, -32
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 24[$r12] = $r16
; CHECK-NEXT:    sxbd $r0 = $r1
; CHECK-NEXT:    copyd $r1 = $r2
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    scall $r3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ld $r16 = 24[$r12]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 32
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = zext i32 %id to i64
  %1 = inttoptr i64 %0 to ptr addrspace(259)
  %conv = sext i8 %arg1 to i32
  %2 = notail call addrspace(259) i64 %1(i32 %conv, ptr %arg2)
  ret i64 %2
}

define i64 @scall_tiny_make(i32 noundef %id) {
; CHECK-LABEL: scall_tiny_make:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    make $r0 = 0
; CHECK-NEXT:    make $r1 = 1
; CHECK-NEXT:    addd $r12 = $r12, -32
; CHECK-NEXT:    zxwd $r15 = $r0
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    make $r2 = 2
; CHECK-NEXT:    make $r3 = 3
; CHECK-NEXT:    make $r4 = 4
; CHECK-NEXT:    make $r5 = 5
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    make $r6 = 6
; CHECK-NEXT:    make $r7 = 7
; CHECK-NEXT:    make $r8 = 8
; CHECK-NEXT:    make $r9 = 9
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    make $r10 = 10
; CHECK-NEXT:    make $r11 = 11
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    sd 24[$r12] = $r16
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    scall $r15
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ld $r16 = 24[$r12]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 32
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = zext i32 %id to i64
  %1 = inttoptr i64 %0 to ptr addrspace(259)
  %2 = notail call addrspace(259) i64 %1(i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11)
  ret i64 %2
}

define i64 @scall_small_make(i32 noundef %id) {
; CHECK-LABEL: scall_small_make:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    make $r0 = 0x20000
; CHECK-NEXT:    make $r1 = 0x20001
; CHECK-NEXT:    addd $r12 = $r12, -32
; CHECK-NEXT:    zxwd $r15 = $r0
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    make $r2 = 0x20002
; CHECK-NEXT:    make $r3 = 0x20003
; CHECK-NEXT:    make $r4 = 0x20004
; CHECK-NEXT:    make $r5 = 0x20005
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    make $r6 = 0x20006
; CHECK-NEXT:    make $r7 = 0x20007
; CHECK-NEXT:    make $r8 = 0x20008
; CHECK-NEXT:    make $r9 = 0x20009
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    make $r10 = 0x2000a
; CHECK-NEXT:    make $r11 = 0x2000b
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    sd 24[$r12] = $r16
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    scall $r15
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ld $r16 = 24[$r12]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 32
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = zext i32 %id to i64
  %1 = inttoptr i64 %0 to ptr addrspace(259)
  %2 = notail call addrspace(259) i64 %1(i32 131072, i32 131073, i32 131074, i32 131075, i32 131076, i32 131077, i32 131078, i32 131079, i32 131080, i32 131081, i32 131082, i32 131083)
  ret i64 %2
}

define i64 @scall_big_make(i32 noundef %id) {
; CHECK-LABEL: scall_big_make:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    make $r0 = 0x100000000000
; CHECK-NEXT:    make $r1 = 0x100000000001
; CHECK-NEXT:    addd $r12 = $r12, -32
; CHECK-NEXT:    zxwd $r15 = $r0
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    make $r2 = 0x100000000002
; CHECK-NEXT:    make $r3 = 0x100000000003
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    sd 24[$r12] = $r16
; CHECK-NEXT:    make $r4 = 0x100000000004
; CHECK-NEXT:    make $r5 = 0x100000000005
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    make $r6 = 0x100000000006
; CHECK-NEXT:    make $r7 = 0x100000000007
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    make $r8 = 0x100000000008
; CHECK-NEXT:    make $r9 = 0x100000000009
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    make $r10 = 0x10000000000a
; CHECK-NEXT:    make $r11 = 0x10000000000b
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    scall $r15
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ld $r16 = 24[$r12]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 32
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = zext i32 %id to i64
  %1 = inttoptr i64 %0 to ptr addrspace(259)
  %2 = notail call addrspace(259) i64 %1(i64 17592186044416, i64 17592186044417, i64 17592186044418, i64 17592186044419, i64 17592186044420, i64 17592186044421, i64 17592186044422, i64 17592186044423, i64 17592186044424, i64 17592186044425, i64 17592186044426, i64 17592186044427)
  ret i64 %2
}

define i64 @scall_then_add(i32 noundef %id) {
; CHECK-LABEL: scall_then_add:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    make $r0 = 0
; CHECK-NEXT:    make $r1 = 1
; CHECK-NEXT:    addd $r12 = $r12, -32
; CHECK-NEXT:    zxwd $r15 = $r0
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    make $r2 = 2
; CHECK-NEXT:    make $r3 = 3
; CHECK-NEXT:    make $r4 = 4
; CHECK-NEXT:    make $r5 = 5
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    make $r6 = 6
; CHECK-NEXT:    make $r7 = 7
; CHECK-NEXT:    make $r8 = 8
; CHECK-NEXT:    make $r9 = 9
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    make $r10 = 10
; CHECK-NEXT:    make $r11 = 11
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    sd 24[$r12] = $r16
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    scall $r15
; CHECK-NEXT:    ;;
; CHECK-NEXT:    addd $r0 = $r0, 42
; CHECK-NEXT:    ld $r16 = 24[$r12]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 32
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = zext i32 %id to i64
  %1 = inttoptr i64 %0 to ptr addrspace(259)
  %2 = notail call addrspace(259) i64 %1(i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11)
  %add = add nsw i64 %2, 42
  ret i64 %add
}

define i64 @scall_imm() {
; CHECK-LABEL: scall_imm:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    addd $r12 = $r12, -32
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 24[$r12] = $r16
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    scall 42
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ld $r16 = 24[$r12]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 32
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = notail call addrspace(259) i64 inttoptr (i32 42 to ptr addrspace(259))()
  ret i64 %0
}

define i64 @scall_many_args(i32 noundef %id) {
; CHECK-LABEL: scall_many_args:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    addd $r12 = $r12, -64
; CHECK-NEXT:    zxwd $r15 = $r0
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 56[$r12] = $r16
; CHECK-NEXT:    make $r0 = 15
; CHECK-NEXT:    make $r1 = 14
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    sw 24[$r12] = $r0
; CHECK-NEXT:    make $r0 = 0
; CHECK-NEXT:    make $r2 = 2
; CHECK-NEXT:    make $r16 = 13
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    sw 16[$r12] = $r1
; CHECK-NEXT:    make $r1 = 1
; CHECK-NEXT:    make $r3 = 3
; CHECK-NEXT:    make $r4 = 4
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    make $r5 = 5
; CHECK-NEXT:    make $r6 = 6
; CHECK-NEXT:    make $r7 = 7
; CHECK-NEXT:    make $r8 = 8
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    sw 8[$r12] = $r16
; CHECK-NEXT:    make $r9 = 9
; CHECK-NEXT:    make $r10 = 10
; CHECK-NEXT:    make $r11 = 11
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    make $r16 = 12
; CHECK-NEXT:    ;; # (end cycle 6)
; CHECK-NEXT:    sw 0[$r12] = $r16
; CHECK-NEXT:    ;; # (end cycle 7)
; CHECK-NEXT:    scall $r15
; CHECK-NEXT:    ;;
; CHECK-NEXT:    addd $r0 = $r0, 42
; CHECK-NEXT:    ld $r16 = 56[$r12]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 64
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = zext i32 %id to i64
  %1 = inttoptr i64 %0 to ptr addrspace(259)
  %2 = notail call addrspace(259) i64 %1(i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15)
  %add = add nsw i64 %2, 42
  ret i64 %add
}

; The compiler should be saving $r1 in a callee-saved register, as scall may
; define any caller-saved register
define i64 @scall_check_abi(i32 %id, i64 %c) {
; CHECK-LABEL: scall_check_abi:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    addd $r12 = $r12, -32
; CHECK-NEXT:    zxwd $r15 = $r0
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 24[$r12] = $r16
; CHECK-NEXT:    make $r0 = 0
; CHECK-NEXT:    make $r2 = 2
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    sd 16[$r12] = $r18
; CHECK-NEXT:    make $r1 = 1
; CHECK-NEXT:    make $r3 = 3
; CHECK-NEXT:    copyd $r18 = $r1
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    make $r4 = 4
; CHECK-NEXT:    make $r5 = 5
; CHECK-NEXT:    make $r6 = 6
; CHECK-NEXT:    make $r7 = 7
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    make $r8 = 8
; CHECK-NEXT:    make $r9 = 9
; CHECK-NEXT:    make $r10 = 10
; CHECK-NEXT:    make $r11 = 11
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    scall $r15
; CHECK-NEXT:    ;;
; CHECK-NEXT:    addd $r0 = $r0, $r18
; CHECK-NEXT:    ld $r18 = 16[$r12]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    ld $r16 = 24[$r12]
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 32
; CHECK-NEXT:    ;; # (end cycle 6)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %callee = inttoptr i32 %id to ptr addrspace(259)
  %callres = call addrspace(259) i64 %callee(i32 0, i32 1, i32 2, i32 3, i32 4,
    i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11)
  %ret = add nsw i64 %callres, %c
  ret i64 %ret
}

; Check that all argument registers are spilled properly
define i64 @scall_spill_all_args(<12 x i64> %v, i32 %id) {
; CHECK-LABEL: scall_spill_all_args:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    addd $r12 = $r12, -128
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 120[$r12] = $r16
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    sq 104[$r12] = $r28r29
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    so 72[$r12] = $r24r25r26r27
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    so 40[$r12] = $r20r21r22r23
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    sq 24[$r12] = $r18r19
; CHECK-NEXT:    copyd $r18 = $r11
; CHECK-NEXT:    copyd $r19 = $r10
; CHECK-NEXT:    copyd $r20 = $r9
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    copyd $r21 = $r8
; CHECK-NEXT:    copyd $r22 = $r7
; CHECK-NEXT:    copyd $r23 = $r6
; CHECK-NEXT:    copyd $r24 = $r5
; CHECK-NEXT:    ;; # (end cycle 6)
; CHECK-NEXT:    copyd $r25 = $r4
; CHECK-NEXT:    copyd $r26 = $r3
; CHECK-NEXT:    copyd $r27 = $r2
; CHECK-NEXT:    copyd $r28 = $r1
; CHECK-NEXT:    ;; # (end cycle 7)
; CHECK-NEXT:    lwz $r15 = 128[$r12]
; CHECK-NEXT:    copyd $r29 = $r0
; CHECK-NEXT:    ;; # (end cycle 8)
; CHECK-NEXT:    scall $r15
; CHECK-NEXT:    ;;
; CHECK-NEXT:    addd $r0 = $r0, $r29
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    addd $r0 = $r0, $r28
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    addd $r0 = $r0, $r27
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    addd $r0 = $r0, $r26
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    addd $r0 = $r0, $r25
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    addd $r0 = $r0, $r24
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    addd $r0 = $r0, $r23
; CHECK-NEXT:    ;; # (end cycle 6)
; CHECK-NEXT:    addd $r0 = $r0, $r22
; CHECK-NEXT:    ;; # (end cycle 7)
; CHECK-NEXT:    addd $r0 = $r0, $r21
; CHECK-NEXT:    ;; # (end cycle 8)
; CHECK-NEXT:    addd $r0 = $r0, $r20
; CHECK-NEXT:    ;; # (end cycle 9)
; CHECK-NEXT:    addd $r0 = $r0, $r19
; CHECK-NEXT:    ;; # (end cycle 10)
; CHECK-NEXT:    lq $r18r19 = 24[$r12]
; CHECK-NEXT:    addd $r0 = $r0, $r18
; CHECK-NEXT:    ;; # (end cycle 11)
; CHECK-NEXT:    lo $r20r21r22r23 = 40[$r12]
; CHECK-NEXT:    ;; # (end cycle 12)
; CHECK-NEXT:    lo $r24r25r26r27 = 72[$r12]
; CHECK-NEXT:    ;; # (end cycle 13)
; CHECK-NEXT:    lq $r28r29 = 104[$r12]
; CHECK-NEXT:    ;; # (end cycle 14)
; CHECK-NEXT:    ld $r16 = 120[$r12]
; CHECK-NEXT:    ;; # (end cycle 15)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 128
; CHECK-NEXT:    ;; # (end cycle 20)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %v0 = extractelement <12 x i64> %v, i32 0
  %v1 = extractelement <12 x i64> %v, i32 1
  %v2 = extractelement <12 x i64> %v, i32 2
  %v3 = extractelement <12 x i64> %v, i32 3
  %v4 = extractelement <12 x i64> %v, i32 4
  %v5 = extractelement <12 x i64> %v, i32 5
  %v6 = extractelement <12 x i64> %v, i32 6
  %v7 = extractelement <12 x i64> %v, i32 7
  %v8 = extractelement <12 x i64> %v, i32 8
  %v9 = extractelement <12 x i64> %v, i32 9
  %v10 = extractelement <12 x i64> %v, i32 10
  %v11 = extractelement <12 x i64> %v, i32 11
  %callee = inttoptr i32 %id to ptr addrspace(259)
  %scall = notail call addrspace(259) i64 %callee(i64 %v0, i64 %v1, i64 %v2, i64 %v3, i64 %v4,
    i64 %v5, i64 %v6, i64 %v7, i64 %v8, i64 %v9, i64 %v10, i64 %v11)
  %add0 = add nsw i64 %scall, %v0
  %add1 = add nsw i64 %add0, %v1
  %add2 = add nsw i64 %add1, %v2
  %add3 = add nsw i64 %add2, %v3
  %add4 = add nsw i64 %add3, %v4
  %add5 = add nsw i64 %add4, %v5
  %add6 = add nsw i64 %add5, %v6
  %add7 = add nsw i64 %add6, %v7
  %add8 = add nsw i64 %add7, %v8
  %add9 = add nsw i64 %add8, %v9
  %add10 = add nsw i64 %add9, %v10
  %add11 = add nsw i64 %add10, %v11
  ret i64 %add11
}

;; NOTE: These prefixes are unused and the list is autogenerated. Do not add tests below this line:
; CV1: {{.*}}
; CV2: {{.*}}
