; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -o - %s -O2 | FileCheck %s --check-prefixes=CHECK
; RUN: clang -O2 -c -o /dev/null %s

target triple = "kvx-kalray-cos"

define i64 @addcd(i64 %v1, i64 %v2) {
; CHECK-LABEL: addcd:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    addcd $r0 = $r0, $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call i64 @llvm.kvx.addcd(i64 %v1, i64 %v2, i32 0)
  ret i64 %0
}

declare i64 @llvm.kvx.addcd(i64, i64, i32) #1

define i64 @addcdi(i64 %v1, i64 %v2) {
; CHECK-LABEL: addcdi:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    addcd.i $r0 = $r0, $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call i64 @llvm.kvx.addcd(i64 %v1, i64 %v2, i32 1)
  ret i64 %0
}

define i64 @sbfcd(i64 %v1, i64 %v2) {
; CHECK-LABEL: sbfcd:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sbfcd $r0 = $r1, $r0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call i64 @llvm.kvx.sbfcd(i64 %v2, i64 %v1, i32 0)
  ret i64 %0
}

declare i64 @llvm.kvx.sbfcd(i64, i64, i32) #1

define i64 @sbfcdi(i64 %v1, i64 %v2) {
; CHECK-LABEL: sbfcdi:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sbfcd.i $r0 = $r1, $r0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call i64 @llvm.kvx.sbfcd(i64 %v2, i64 %v1, i32 1)
  ret i64 %0
}

define i32 @addsw(i32 %v1, i32 %v2){
; CHECK-LABEL: addsw:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    addsw $r0 = $r0, $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call i32 @llvm.kvx.addsw(i32 %v1, i32 %v2)
  ret i32 %0
}

declare i32 @llvm.kvx.addsw(i32, i32) #1

define i64 @addsd(i64 %v1, i64 %v2){
; CHECK-LABEL: addsd:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    addsd $r0 = $r0, $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call i64 @llvm.kvx.addsd(i64 %v1, i64 %v2)
  ret i64 %0
}

declare i64 @llvm.kvx.addsd(i64, i64) #1

define i32 @sbfsw(i32 %v1, i32 %v2){
; CHECK-LABEL: sbfsw:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sbfsw $r0 = $r0, $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call i32 @llvm.kvx.sbfsw(i32 %v1, i32 %v2)
  ret i32 %0
}

declare i32 @llvm.kvx.sbfsw(i32, i32) #1

define i64 @sbfsd(i64 %v1, i64 %v2){
; CHECK-LABEL: sbfsd:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sbfsd $r0 = $r0, $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call i64 @llvm.kvx.sbfsd(i64 %v1, i64 %v2)
  ret i64 %0
}

declare i64 @llvm.kvx.sbfsd(i64, i64) #1

define i64 @cbsd(i64 %l){
; CHECK-LABEL: cbsd:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cbsd $r0 = $r0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call i64 @llvm.kvx.cbsd(i64 %l)
  ret i64 %0
}

declare i64 @llvm.kvx.cbsd(i64) #1

define i32 @cbsw(i32 %i){
; CHECK-LABEL: cbsw:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cbsw $r0 = $r0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call i32 @llvm.kvx.cbsw(i32 %i)
  ret i32 %0
}

declare i32 @llvm.kvx.cbsw(i32) #1

define i64 @clzd(i64 %l){
; CHECK-LABEL: clzd:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    clzd $r0 = $r0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call i64 @llvm.kvx.clzd(i64 %l)
  ret i64 %0
}

declare i64 @llvm.kvx.clzd(i64) #1

define i32 @clzw(i32 %i){
; CHECK-LABEL: clzw:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    clzw $r0 = $r0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call i32 @llvm.kvx.clzw(i32 %i)
  ret i32 %0
}

declare i32 @llvm.kvx.clzw(i32) #1

define i64 @ctzd(i64 %l){
; CHECK-LABEL: ctzd:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ctzd $r0 = $r0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call i64 @llvm.kvx.ctzd(i64 %l)
  ret i64 %0
}

declare i64 @llvm.kvx.ctzd(i64) #1

define i32 @ctzw(i32 %i){
; CHECK-LABEL: ctzw:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ctzw $r0 = $r0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call i32 @llvm.kvx.ctzw(i32 %i)
  ret i32 %0
}

declare i32 @llvm.kvx.ctzw(i32) #1


declare double @llvm.kvx.fmind(double, double) #1

define half @fmulh_s(half %0, half %1) {
; CHECK-LABEL: fmulh_s:
; CHECK:       # %bb.0:
; CHECK-NEXT:    fmulhq.ru.s $r0 = $r0, $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %3 = insertelement <4 x half> undef, half %0, i64 0
  %4 = insertelement <4 x half> undef, half %1, i64 0
  %5 = tail call <4 x half> @llvm.kvx.fmulhq(<4 x half> %3, <4 x half> %4, i32 1, i32 1)
  %6 = extractelement <4 x half> %5, i64 0
  ret half %6
}

define half @fmulh(half %0, half %1) {
; CHECK-LABEL: fmulh:
; CHECK:       # %bb.0:
; CHECK-NEXT:    zxhd $r0 = $r0
; CHECK-NEXT:    zxhd $r1 = $r1
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fmulhq.ru $r0 = $r0, $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %3 = insertelement <4 x half> undef, half %0, i64 0
  %4 = insertelement <4 x half> undef, half %1, i64 0
  %5 = tail call <4 x half> @llvm.kvx.fmulhq(<4 x half> %3, <4 x half> %4, i32 1, i32 0)
  %6 = extractelement <4 x half> %5, i64 0
  ret half %6
}

declare <4 x half> @llvm.kvx.fmulhq(<4 x half>, <4 x half>, i32, i32) #1

define float @fmulw(float %v1, float %v2){
; CHECK-LABEL: fmulw:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fmulw.rz $r0 = $r0, $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call float @llvm.kvx.fmulw(float %v1, float %v2, i32 3, i32 0)
  ret float %0
}

declare float @llvm.kvx.fmulw(float, float, i32, i32) #1

define double @fmuld(double %v1, double %v2){
; CHECK-LABEL: fmuld:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fmuld.rz $r0 = $r0, $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call double @llvm.kvx.fmuld(double %v1, double %v2, i32 3, i32 0)
  ret double %0
}

declare double @llvm.kvx.fmuld(double, double, i32, i32) #1

define half @ffmah_s(half %0, half %1, half %2) {
; CHECK-LABEL: ffmah_s:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ffmahq.ru.s $r0 = $r1, $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = insertelement <4 x half> undef, half %0, i64 0
  %5 = insertelement <4 x half> undef, half %1, i64 0
  %6 = insertelement <4 x half> undef, half %2, i64 0
  %7 = tail call <4 x half> @llvm.kvx.ffmahq(<4 x half> %4, <4 x half> %5, <4 x half> %6, i32 1, i32 1)
  %8 = extractelement <4 x half> %7, i64 0
  ret half %8
}

define half @ffmah(half %0, half %1, half %2) {
; CHECK-LABEL: ffmah:
; CHECK:       # %bb.0:
; CHECK-NEXT:    zxhd $r1 = $r1
; CHECK-NEXT:    zxhd $r2 = $r2
; CHECK-NEXT:    ;;
; CHECK-NEXT:    zxhd $r0 = $r0
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ffmahq.ru $r0 = $r1, $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = insertelement <4 x half> undef, half %0, i64 0
  %5 = insertelement <4 x half> undef, half %1, i64 0
  %6 = insertelement <4 x half> undef, half %2, i64 0
  %7 = tail call <4 x half> @llvm.kvx.ffmahq(<4 x half> %4, <4 x half> %5, <4 x half> %6, i32 1, i32 0)
  %8 = extractelement <4 x half> %7, i64 0
  ret half %8
}

declare <4 x half> @llvm.kvx.ffmahq(<4 x half>, <4 x half>, <4 x half>, i32, i32) #1

define double @fmulwd(float %v1, float %v2){
; CHECK-LABEL: fmulwd:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fmulwd.rz $r0 = $r0, $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call double @llvm.kvx.fmulwd(float %v1, float %v2, i32 3, i32 0)
  ret double %0
}

declare double @llvm.kvx.fmulwd(float, float, i32, i32) #1

define float @ffmaw(float %a, float %b, float %c){
; CHECK-LABEL: ffmaw:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ffmaw.rz $r2 = $r0, $r1
; CHECK-NEXT:    ;;
; CHECK-NEXT:    copyd $r0 = $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call float @llvm.kvx.ffmaw(float %a, float %b, float %c, i32 3, i32 0)
  ret float %0
}

declare float @llvm.kvx.ffmaw(float, float, float, i32, i32) #1

define double @ffmad(double %a, double %b, double %c){
; CHECK-LABEL: ffmad:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ffmad.rz $r2 = $r0, $r1
; CHECK-NEXT:    ;;
; CHECK-NEXT:    copyd $r0 = $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call double @llvm.kvx.ffmad(double %a, double %b, double %c, i32 3, i32 0)
  ret double %0
}

declare double @llvm.kvx.ffmad(double, double, double, i32, i32) #1

define double @ffmawd(float %a, float %b, double %c){
; CHECK-LABEL: ffmawd:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ffmawd.rz $r2 = $r0, $r1
; CHECK-NEXT:    ;;
; CHECK-NEXT:    copyd $r0 = $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call double @llvm.kvx.ffmawd(float %a, float %b, double %c, i32 3, i32 0)
  ret double %0
}

declare double @llvm.kvx.ffmawd(float, float, double, i32, i32) #1

define float @ffmsw(float %a, float %b, float %c){
; CHECK-LABEL: ffmsw:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ffmsw.rz $r2 = $r0, $r1
; CHECK-NEXT:    ;;
; CHECK-NEXT:    copyd $r0 = $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call float @llvm.kvx.ffmsw(float %a, float %b, float %c, i32 3, i32 0)
  ret float %0
}

declare float @llvm.kvx.ffmsw(float, float, float, i32, i32) #1

define float @ffmsw_(float %a, float %b, float %c){
; CHECK-LABEL: ffmsw_:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ffmsw $r2 = $r0, $r1
; CHECK-NEXT:    ;;
; CHECK-NEXT:    copyd $r0 = $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call float @llvm.kvx.ffmsw(float %a, float %b, float %c, i32 7, i32 0)
  ret float %0
}

define double @ffmsd(double %a, double %b, double %c){
; CHECK-LABEL: ffmsd:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ffmsd.rz $r2 = $r0, $r1
; CHECK-NEXT:    ;;
; CHECK-NEXT:    copyd $r0 = $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call double @llvm.kvx.ffmsd(double %a, double %b, double %c, i32 3, i32 0)
  ret double %0
}

declare double @llvm.kvx.ffmsd(double, double, double, i32, i32) #1

define double @ffmswd(float %a, float %b, double %c){
; CHECK-LABEL: ffmswd:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ffmswd.rz $r2 = $r0, $r1
; CHECK-NEXT:    ;;
; CHECK-NEXT:    copyd $r0 = $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call double @llvm.kvx.ffmswd(float %a, float %b, double %c, i32 3, i32 0)
  ret double %0
}

declare double @llvm.kvx.ffmswd(float, float, double, i32, i32) #1

define float @floatw(i32 %x){
; CHECK-LABEL: floatw:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    floatw.rn $r0 = $r0, 3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call float @llvm.kvx.floatw(i32 %x, i64 3, i32 0, i32 0)
  ret float %0
}

define float @floatw_s(i32 %x){
; CHECK-LABEL: floatw_s:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    floatw.rn.s $r0 = $r0, 3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call float @llvm.kvx.floatw(i32 %x, i64 3, i32 0, i32 1)
  ret float %0
}

declare float @llvm.kvx.floatw(i32, i64, i32, i32) #1

define double @floatd(i64 %x){
; CHECK-LABEL: floatd:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    floatd.rn $r0 = $r0, 3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call double @llvm.kvx.floatd(i64 %x, i64 3, i32 0, i32 0)
  ret double %0
}

declare double @llvm.kvx.floatd(i64, i64, i32, i32) #1

define float @floatuw(i32 %x){
; CHECK-LABEL: floatuw:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    floatuw.rz $r0 = $r0, 3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call float @llvm.kvx.floatuw(i32 %x, i64 3, i32 3, i32 0)
  ret float %0
}

declare float @llvm.kvx.floatuw(i32, i64, i32, i32) #1

define double @floatud(i64 %x){
; CHECK-LABEL: floatud:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    floatud.rz $r0 = $r0, 3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call double @llvm.kvx.floatud(i64 %x, i64 3, i32 3, i32 0)
  ret double %0
}

declare double @llvm.kvx.floatud(i64, i64, i32, i32) #1

define i32 @fixedw(float %x){
; CHECK-LABEL: fixedw:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fixedw.rn $r0 = $r0, 3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call i32 @llvm.kvx.fixedw(float %x, i64 3, i32 0, i32 0)
  ret i32 %0
}

define i32 @fixedw_s(float %x){
; CHECK-LABEL: fixedw_s:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fixedw.rn.s $r0 = $r0, 3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call i32 @llvm.kvx.fixedw(float %x, i64 3, i32 0, i32 1)
  ret i32 %0
}

declare i32 @llvm.kvx.fixedw(float, i64, i32, i32) #1

define i64 @fixedd(double %x){
; CHECK-LABEL: fixedd:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fixedd.rn $r0 = $r0, 3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call i64 @llvm.kvx.fixedd(double %x, i64 3, i32 0, i32 0)
  ret i64 %0
}

declare i64 @llvm.kvx.fixedd(double, i64, i32, i32) #1

define i32 @fixeduw(float %x){
; CHECK-LABEL: fixeduw:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fixeduw.rz $r0 = $r0, 3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call i32 @llvm.kvx.fixeduw(float %x, i64 3, i32 3, i32 0)
  ret i32 %0
}

declare i32 @llvm.kvx.fixeduw(float, i64, i32, i32) #1

define i64 @fixedud(double %x){
; CHECK-LABEL: fixedud:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fixedud.rz $r0 = $r0, 3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call i64 @llvm.kvx.fixedud(double %x, i64 3, i32 3, i32 0)
  ret i64 %0
}

declare i64 @llvm.kvx.fixedud(double, i64, i32, i32) #1

define i64 @sbmm8(i64 %a, i64 %b){
; CHECK-LABEL: sbmm8:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sbmm8 $r0 = $r0, $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call i64 @llvm.kvx.sbmm8(i64 %a, i64 %b)
  ret i64 %0
}

declare i64 @llvm.kvx.sbmm8(i64, i64) #1

define i64 @sbmmt8(i64 %a, i64 %b){
; CHECK-LABEL: sbmmt8:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sbmmt8 $r0 = $r0, $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call i64 @llvm.kvx.sbmmt8(i64 %a, i64 %b)
  ret i64 %0
}

declare i64 @llvm.kvx.sbmmt8(i64, i64) #1

define i64 @satd(i64 %v, i8 %b){
; CHECK-LABEL: satd:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    zxbd $r1 = $r1
; CHECK-NEXT:    ;;
; CHECK-NEXT:    satd $r0 = $r0, $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %conv = zext i8 %b to i32
  %0 = tail call i64 @llvm.kvx.satd(i64 %v, i32 %conv)
  ret i64 %0
}

declare i64 @llvm.kvx.satd(i64, i32) #1

define half @fnarrowwh(float %0) {
; CHECK-LABEL: fnarrowwh:
; CHECK:       # %bb.0:
; CHECK-NEXT:    fnarrowwh.ru.s $r0 = $r0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %2 = tail call half @llvm.kvx.fnarrowwh(float %0, i32 1, i32 1)
  ret half %2
}

declare half @llvm.kvx.fnarrowwh(float, i32, i32) #1

define float @fnarrowdw(double %0) {
; CHECK-LABEL: fnarrowdw:
; CHECK:       # %bb.0:
; CHECK-NEXT:    fnarrowdw.ru.s $r0 = $r0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %2 = tail call float @llvm.kvx.fnarrowdw(double %0, i32 1, i32 1)
  ret float %2
}

declare float @llvm.kvx.fnarrowdw(double, i32, i32) #1
