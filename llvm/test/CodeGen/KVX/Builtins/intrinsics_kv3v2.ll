; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -O2 -mcpu=kv3-2 -o - %s | FileCheck %s
; RUN: clang -O2 -march=kv3-2 -c -o /dev/null %s

target triple = "kvx-kalray-cos"

define void @dflushsw(i64 %0, i64 %1) {
; CHECK-LABEL: dflushsw:
; CHECK:       # %bb.0:
; CHECK-NEXT:    dflushsw.l1 $r1, $r0
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    dflushsw.l2 $r1, $r0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
  tail call void @llvm.kvx.dflushsw(i64 %0, i64 %1, i32 0)
  tail call void @llvm.kvx.dflushsw(i64 %0, i64 %1, i32 1)
  ret void
}

declare void @llvm.kvx.dflushsw(i64, i64, i32)

define void @dinvalsw(i64 %0, i64 %1) {
; CHECK-LABEL: dinvalsw:
; CHECK:       # %bb.0:
; CHECK-NEXT:    dinvalsw.l1 $r1, $r0
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    dinvalsw.l2 $r1, $r0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
  tail call void @llvm.kvx.dinvalsw(i64 %0, i64 %1, i32 0)
  tail call void @llvm.kvx.dinvalsw(i64 %0, i64 %1, i32 1)
  ret void
}

declare void @llvm.kvx.dinvalsw(i64, i64, i32)

define void @dpurgesw(i64 %0, i64 %1) {
; CHECK-LABEL: dpurgesw:
; CHECK:       # %bb.0:
; CHECK-NEXT:    dpurgesw.l1 $r1, $r0
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    dpurgesw.l2 $r1, $r0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
  tail call void @llvm.kvx.dpurgesw(i64 %0, i64 %1, i32 0)
  tail call void @llvm.kvx.dpurgesw(i64 %0, i64 %1, i32 1)
  ret void
}

declare void @llvm.kvx.dpurgesw(i64, i64, i32)

define i32 @acswapw(ptr %0, i32 %1, i32 %2) {
; CHECK-LABEL: acswapw:
; CHECK:       # %bb.0:
; CHECK-NEXT:    copyd $r2 = $r1
; CHECK-NEXT:    copyd $r3 = $r2
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    acswapw $r0, [$r0] = $r2r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
  %4 = tail call i32 @llvm.kvx.acswapw(ptr %0, i32 %1, i32 %2, i32 1, i32 0)
  ret i32 %4
}

declare i32 @llvm.kvx.acswapw(ptr, i32, i32, i32, i32)

define i32 @acswapwv(ptr %0, i32 %1, i32 %2) {
; CHECK-LABEL: acswapwv:
; CHECK:       # %bb.0:
; CHECK-NEXT:    copyd $r2 = $r1
; CHECK-NEXT:    copyd $r3 = $r2
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    acswapw.v $r0, [$r0] = $r2r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
  %4 = tail call i32 @llvm.kvx.acswapw(ptr %0, i32 %1, i32 %2, i32 0, i32 0)
  ret i32 %4
}

define i32 @acswapwg(ptr %0, i32 %1, i32 %2) {
; CHECK-LABEL: acswapwg:
; CHECK:       # %bb.0:
; CHECK-NEXT:    copyd $r2 = $r1
; CHECK-NEXT:    copyd $r3 = $r2
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    acswapw.g $r0, [$r0] = $r2r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
  %4 = tail call i32 @llvm.kvx.acswapw(ptr %0, i32 %1, i32 %2, i32 1, i32 1)
  ret i32 %4
}

define i32 @acswapwvg(ptr %0, i32 %1, i32 %2) {
; CHECK-LABEL: acswapwvg:
; CHECK:       # %bb.0:
; CHECK-NEXT:    copyd $r2 = $r1
; CHECK-NEXT:    copyd $r3 = $r2
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    acswapw.v.g $r0, [$r0] = $r2r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
  %4 = tail call i32 @llvm.kvx.acswapw(ptr %0, i32 %1, i32 %2, i32 0, i32 1)
  ret i32 %4
}

define i64 @acswapd(ptr %0, i64 %1, i64 %2) {
; CHECK-LABEL: acswapd:
; CHECK:       # %bb.0:
; CHECK-NEXT:    copyd $r2 = $r1
; CHECK-NEXT:    copyd $r3 = $r2
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    acswapd $r0, [$r0] = $r2r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
  %4 = tail call i64 @llvm.kvx.acswapd(ptr %0, i64 %1, i64 %2, i32 1, i32 0)
  ret i64 %4
}

declare i64 @llvm.kvx.acswapd(ptr, i64, i64, i32, i32)

define i64 @acswapdv(ptr %0, i64 %1, i64 %2) {
; CHECK-LABEL: acswapdv:
; CHECK:       # %bb.0:
; CHECK-NEXT:    copyd $r2 = $r1
; CHECK-NEXT:    copyd $r3 = $r2
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    acswapd.v $r0, [$r0] = $r2r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
  %4 = tail call i64 @llvm.kvx.acswapd(ptr %0, i64 %1, i64 %2, i32 0, i32 0)
  ret i64 %4
}

define i64 @acswapdg(ptr %0, i64 %1, i64 %2) {
; CHECK-LABEL: acswapdg:
; CHECK:       # %bb.0:
; CHECK-NEXT:    copyd $r2 = $r1
; CHECK-NEXT:    copyd $r3 = $r2
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    acswapd.g $r0, [$r0] = $r2r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
  %4 = tail call i64 @llvm.kvx.acswapd(ptr %0, i64 %1, i64 %2, i32 1, i32 1)
  ret i64 %4
}

define i64 @acswapdvg(ptr %0, i64 %1, i64 %2) {
; CHECK-LABEL: acswapdvg:
; CHECK:       # %bb.0:
; CHECK-NEXT:    copyd $r2 = $r1
; CHECK-NEXT:    copyd $r3 = $r2
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    acswapd.v.g $r0, [$r0] = $r2r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
  %4 = tail call i64 @llvm.kvx.acswapd(ptr %0, i64 %1, i64 %2, i32 0, i32 1)
  ret i64 %4
}

define <2 x i64> @acswapq(ptr %0, <2 x i64> %1, <2 x i64> %2) {
; CHECK-LABEL: acswapq:
; CHECK:       # %bb.0:
; CHECK-NEXT:    copyd $r4 = $r1
; CHECK-NEXT:    copyd $r5 = $r2
; CHECK-NEXT:    copyd $r6 = $r3
; CHECK-NEXT:    copyd $r7 = $r4
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    acswapq $r0r1, [$r0] = $r4r5r6r7
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
  %4 = tail call <2 x i64> @llvm.kvx.acswapq(ptr %0, <2 x i64> %1, <2 x i64> %2, i32 1, i32 0)
  ret <2 x i64> %4
}

declare <2 x i64> @llvm.kvx.acswapq(ptr, <2 x i64>, <2 x i64>, i32, i32)

define <2 x i64> @acswapqv(ptr %0, <2 x i64> %1, <2 x i64> %2) {
; CHECK-LABEL: acswapqv:
; CHECK:       # %bb.0:
; CHECK-NEXT:    copyd $r4 = $r1
; CHECK-NEXT:    copyd $r5 = $r2
; CHECK-NEXT:    copyd $r6 = $r3
; CHECK-NEXT:    copyd $r7 = $r4
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    acswapq.v $r0r1, [$r0] = $r4r5r6r7
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
  %4 = tail call <2 x i64> @llvm.kvx.acswapq(ptr %0, <2 x i64> %1, <2 x i64> %2, i32 0, i32 0)
  ret <2 x i64> %4
}

define <2 x i64> @acswapqg(ptr %0, <2 x i64> %1, <2 x i64> %2) {
; CHECK-LABEL: acswapqg:
; CHECK:       # %bb.0:
; CHECK-NEXT:    copyd $r4 = $r1
; CHECK-NEXT:    copyd $r5 = $r2
; CHECK-NEXT:    copyd $r6 = $r3
; CHECK-NEXT:    copyd $r7 = $r4
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    acswapq.g $r0r1, [$r0] = $r4r5r6r7
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
  %4 = tail call <2 x i64> @llvm.kvx.acswapq(ptr %0, <2 x i64> %1, <2 x i64> %2, i32 1, i32 1)
  ret <2 x i64> %4
}

define <2 x i64> @acswapqvg(ptr %0, <2 x i64> %1, <2 x i64> %2) {
; CHECK-LABEL: acswapqvg:
; CHECK:       # %bb.0:
; CHECK-NEXT:    copyd $r4 = $r1
; CHECK-NEXT:    copyd $r5 = $r2
; CHECK-NEXT:    copyd $r6 = $r3
; CHECK-NEXT:    copyd $r7 = $r4
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    acswapq.v.g $r0r1, [$r0] = $r4r5r6r7
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
  %4 = tail call <2 x i64> @llvm.kvx.acswapq(ptr %0, <2 x i64> %1, <2 x i64> %2, i32 0, i32 1)
  ret <2 x i64> %4
}

define <2 x i64> @acswapqvgr(ptr %0, <2 x i64> %1, <2 x i64> %2, i32 %3) {
; CHECK-LABEL: acswapqvgr:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addx16wd $r0 = $r5, $r0
; CHECK-NEXT:    copyd $r5 = $r2
; CHECK-NEXT:    copyd $r6 = $r3
; CHECK-NEXT:    copyd $r7 = $r4
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    copyd $r4 = $r1
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    acswapq.v.g $r0r1, [$r0] = $r4r5r6r7
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 2)
  %5 = sext i32 %3 to i64
  %6 = getelementptr inbounds <2 x i64>, ptr %0, i64 %5
  %7 = tail call <2 x i64> @llvm.kvx.acswapq(ptr %6, <2 x i64> %1, <2 x i64> %2, i32 0, i32 1)
  ret <2 x i64> %7
}

define <2 x i64> @acswapqvgri27(ptr %0, <2 x i64> %1, <2 x i64> %2) {
; CHECK-LABEL: acswapqvgri27:
; CHECK:       # %bb.0:
; CHECK-NEXT:    copyd $r4 = $r1
; CHECK-NEXT:    copyd $r5 = $r2
; CHECK-NEXT:    copyd $r6 = $r3
; CHECK-NEXT:    copyd $r7 = $r4
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    acswapq.v.g $r0r1, 240[$r0] = $r4r5r6r7
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
  %4 = getelementptr inbounds i8, ptr %0, i64 240
  %5 = tail call <2 x i64> @llvm.kvx.acswapq(ptr nonnull %4, <2 x i64> %1, <2 x i64> %2, i32 0, i32 1)
  ret <2 x i64> %5
}

define <2 x i64> @acswapqvgri54(ptr %0, <2 x i64> %1, <2 x i64> %2) {
; CHECK-LABEL: acswapqvgri54:
; CHECK:       # %bb.0:
; CHECK-NEXT:    copyd $r4 = $r1
; CHECK-NEXT:    copyd $r5 = $r2
; CHECK-NEXT:    copyd $r6 = $r3
; CHECK-NEXT:    copyd $r7 = $r4
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    acswapq.v.g $r0r1, 0x1000000030[$r0] = $r4r5r6r7
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
  %4 = getelementptr inbounds i8, ptr %0, i64 68719476784
  %5 = tail call <2 x i64> @llvm.kvx.acswapq(ptr nonnull %4, <2 x i64> %1, <2 x i64> %2, i32 0, i32 1)
  ret <2 x i64> %5
}

define i32 @alw(ptr %0) {
; CHECK-LABEL: alw:
; CHECK:       # %bb.0:
; CHECK-NEXT:    alw $r0 = [$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %2 = tail call i32 @llvm.kvx.alw(ptr %0, i32 0)
  ret i32 %2
}

declare i32 @llvm.kvx.alw(ptr, i32)

define i32 @alw_ri10(ptr %0) {
; CHECK-LABEL: alw_ri10:
; CHECK:       # %bb.0:
; CHECK-NEXT:    alw $r0 = 4[$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %2 = getelementptr inbounds i8, ptr %0, i64 4
  %3 = tail call i32 @llvm.kvx.alw(ptr nonnull %2, i32 0)
  ret i32 %3
}

define i32 @alw_ri27(ptr %0) {
; CHECK-LABEL: alw_ri27:
; CHECK:       # %bb.0:
; CHECK-NEXT:    alw $r0 = 0xfa0[$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %2 = getelementptr inbounds i8, ptr %0, i64 4000
  %3 = tail call i32 @llvm.kvx.alw(ptr nonnull %2, i32 0)
  ret i32 %3
}

define i32 @alw_ri64(ptr %0) {
; CHECK-LABEL: alw_ri64:
; CHECK:       # %bb.0:
; CHECK-NEXT:    alw $r0 = 0x861c46800[$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %2 = getelementptr inbounds i8, ptr %0, i64 36000000000
  %3 = tail call i32 @llvm.kvx.alw(ptr nonnull %2, i32 0)
  ret i32 %3
}

define i32 @alw_g(ptr %0) {
; CHECK-LABEL: alw_g:
; CHECK:       # %bb.0:
; CHECK-NEXT:    alw.g $r0 = [$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %2 = tail call i32 @llvm.kvx.alw(ptr %0, i32 1)
  ret i32 %2
}

define i64 @ald(ptr %0) {
; CHECK-LABEL: ald:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ald $r0 = [$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %2 = tail call i64 @llvm.kvx.ald(ptr %0, i32 0)
  ret i64 %2
}

declare i64 @llvm.kvx.ald(ptr, i32)

define i64 @ald_ri10(ptr %0) {
; CHECK-LABEL: ald_ri10:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ald $r0 = 8[$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %2 = getelementptr inbounds i8, ptr %0, i64 8
  %3 = tail call i64 @llvm.kvx.ald(ptr nonnull %2, i32 0)
  ret i64 %3
}

define i64 @ald_ri27(ptr %0) {
; CHECK-LABEL: ald_ri27:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ald $r0 = 0x1f40[$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %2 = getelementptr inbounds i8, ptr %0, i64 8000
  %3 = tail call i64 @llvm.kvx.ald(ptr nonnull %2, i32 0)
  ret i64 %3
}

define i64 @ald_ri64(ptr %0) {
; CHECK-LABEL: ald_ri64:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ald $r0 = 0x10c388d000[$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %2 = getelementptr inbounds i8, ptr %0, i64 72000000000
  %3 = tail call i64 @llvm.kvx.ald(ptr nonnull %2, i32 0)
  ret i64 %3
}

define i64 @ald_g(ptr %0) {
; CHECK-LABEL: ald_g:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ald.g $r0 = [$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %2 = tail call i64 @llvm.kvx.ald(ptr %0, i32 1)
  ret i64 %2
}

define void @asw(ptr %0, i32 %1) {
; CHECK-LABEL: asw:
; CHECK:       # %bb.0:
; CHECK-NEXT:    asw [$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  tail call void @llvm.kvx.asw(ptr %0, i32 %1, i32 0)
  ret void
}

declare void @llvm.kvx.asw(ptr, i32, i32)

define void @asw_ri10(ptr %0, i32 %1) {
; CHECK-LABEL: asw_ri10:
; CHECK:       # %bb.0:
; CHECK-NEXT:    asw 4[$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %3 = getelementptr inbounds i8, ptr %0, i64 4
  tail call void @llvm.kvx.asw(ptr nonnull %3, i32 %1, i32 0)
  ret void
}

define void @asw_ri27(ptr %0, i32 %1) {
; CHECK-LABEL: asw_ri27:
; CHECK:       # %bb.0:
; CHECK-NEXT:    asw 0xfa0[$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %3 = getelementptr inbounds i8, ptr %0, i64 4000
  tail call void @llvm.kvx.asw(ptr nonnull %3, i32 %1, i32 0)
  ret void
}

define void @asw_ri54(ptr %0, i32 %1) {
; CHECK-LABEL: asw_ri54:
; CHECK:       # %bb.0:
; CHECK-NEXT:    asw 0x861c46800[$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %3 = getelementptr inbounds i8, ptr %0, i64 36000000000
  tail call void @llvm.kvx.asw(ptr nonnull %3, i32 %1, i32 0)
  ret void
}

define void @asw_g(ptr %0, i32 %1) {
; CHECK-LABEL: asw_g:
; CHECK:       # %bb.0:
; CHECK-NEXT:    asw.g [$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  tail call void @llvm.kvx.asw(ptr %0, i32 %1, i32 1)
  ret void
}

define void @asd(ptr %0, i64 %1) {
; CHECK-LABEL: asd:
; CHECK:       # %bb.0:
; CHECK-NEXT:    asd [$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  tail call void @llvm.kvx.asd(ptr %0, i64 %1, i32 0)
  ret void
}

declare void @llvm.kvx.asd(ptr, i64, i32)

define void @asd_ri10(ptr %0, i64 %1) {
; CHECK-LABEL: asd_ri10:
; CHECK:       # %bb.0:
; CHECK-NEXT:    asd 8[$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %3 = getelementptr inbounds i8, ptr %0, i64 8
  tail call void @llvm.kvx.asd(ptr nonnull %3, i64 %1, i32 0)
  ret void
}

define void @asd_ri27(ptr %0, i64 %1) {
; CHECK-LABEL: asd_ri27:
; CHECK:       # %bb.0:
; CHECK-NEXT:    asd 0x1f40[$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %3 = getelementptr inbounds i8, ptr %0, i64 8000
  tail call void @llvm.kvx.asd(ptr nonnull %3, i64 %1, i32 0)
  ret void
}

define void @asd_ri54(ptr %0, i64 %1) {
; CHECK-LABEL: asd_ri54:
; CHECK:       # %bb.0:
; CHECK-NEXT:    asd 0x10c388d000[$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %3 = getelementptr inbounds i8, ptr %0, i64 72000000000
  tail call void @llvm.kvx.asd(ptr nonnull %3, i64 %1, i32 0)
  ret void
}

define void @asd_g(ptr %0, i64 %1) {
; CHECK-LABEL: asd_g:
; CHECK:       # %bb.0:
; CHECK-NEXT:    asd.g [$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  tail call void @llvm.kvx.asd(ptr %0, i64 %1, i32 1)
  ret void
}

define void @dpurgel(ptr %0, i64 %1) {
; CHECK-LABEL: dpurgel:
; CHECK:       # %bb.0:
; CHECK-NEXT:    dpurgel 0[$r0]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    dpurgel.xs $r1[$r0]
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    dpurgel 320[$r0]
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    dpurgel 0x10000[$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 3)
  tail call void @llvm.kvx.dpurgel(ptr %0)
  %3 = getelementptr inbounds <8 x i64>, ptr %0, i64 %1
  tail call void @llvm.kvx.dpurgel(ptr %3)
  %4 = getelementptr inbounds i8, ptr %0, i64 320
  tail call void @llvm.kvx.dpurgel(ptr nonnull %4)
  %5 = getelementptr inbounds i8, ptr %0, i64 65536
  tail call void @llvm.kvx.dpurgel(ptr nonnull %5)
  ret void
}

declare void @llvm.kvx.dpurgel(ptr)

define void @dflushl(ptr %0, i64 %1) {
; CHECK-LABEL: dflushl:
; CHECK:       # %bb.0:
; CHECK-NEXT:    dflushl 0[$r0]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    dflushl.xs $r1[$r0]
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    dflushl 320[$r0]
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    dflushl 0x10000[$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 3)
  tail call void @llvm.kvx.dflushl(ptr %0)
  %3 = getelementptr inbounds <8 x i64>, ptr %0, i64 %1
  tail call void @llvm.kvx.dflushl(ptr %3)
  %4 = getelementptr inbounds i8, ptr %0, i64 320
  tail call void @llvm.kvx.dflushl(ptr nonnull %4)
  %5 = getelementptr inbounds i8, ptr %0, i64 65536
  tail call void @llvm.kvx.dflushl(ptr nonnull %5)
  ret void
}

declare void @llvm.kvx.dflushl(ptr)

define <4 x i16> @zxlbhq(<8 x i8> %0) {
; CHECK-LABEL: zxlbhq:
; CHECK:       # %bb.0:
; CHECK-NEXT:    zxlbhq $r0 = $r0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %2 = tail call <4 x i16> @llvm.kvx.zxlbhq(<8 x i8> %0)
  ret <4 x i16> %2
}

declare <4 x i16> @llvm.kvx.zxlbhq(<8 x i8>)

define <4 x i16> @zxmbhq(<8 x i8> %0) {
; CHECK-LABEL: zxmbhq:
; CHECK:       # %bb.0:
; CHECK-NEXT:    zxmbhq $r0 = $r0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %2 = tail call <4 x i16> @llvm.kvx.zxmbhq(<8 x i8> %0)
  ret <4 x i16> %2
}

declare <4 x i16> @llvm.kvx.zxmbhq(<8 x i8>)

define <2 x i32> @zxlhwp(<4 x i16> %0) {
; CHECK-LABEL: zxlhwp:
; CHECK:       # %bb.0:
; CHECK-NEXT:    zxlhwp $r0 = $r0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %2 = tail call <2 x i32> @llvm.kvx.zxlhwp(<4 x i16> %0)
  ret <2 x i32> %2
}

declare <2 x i32> @llvm.kvx.zxlhwp(<4 x i16>)

define <2 x i32> @zxmhwp(<4 x i16> %0) {
; CHECK-LABEL: zxmhwp:
; CHECK:       # %bb.0:
; CHECK-NEXT:    zxmhwp $r0 = $r0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
  %2 = tail call <2 x i32> @llvm.kvx.zxmhwp(<4 x i16> %0)
  ret <2 x i32> %2
}

declare <2 x i32> @llvm.kvx.zxmhwp(<4 x i16>)

