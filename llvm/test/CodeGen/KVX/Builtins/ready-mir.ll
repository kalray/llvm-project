; NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
; RUN: llc -mcpu=kv3-2 --stop-before=kvx-preemit-expand-pseudo,3 -o - %s -O2 | FileCheck %s --check-prefixes=CHECK

target triple = "kvx-kalray-cos"

define i64 @ready_int(ptr nocapture readonly %0) {
  ; CHECK-LABEL: name: ready_int
  ; CHECK: bb.0 (%ir-block.1):
  ; CHECK-NEXT:   liveins: $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r0 {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     $r0 = LWZri10 0, killed $r0, 0 :: (load (s32) from %ir.0)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r0, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 3
  ; CHECK-NEXT:     $r0 = READYp1r killed $r0
  ; CHECK-NEXT:     RET implicit $ra, implicit internal $r0
  ; CHECK-NEXT:   }
  %2 = load i32, ptr %0
  %3 = tail call i64 (...) @llvm.kvx.ready(i32 %2)
  ret i64 %3
}

declare i64 @llvm.kvx.ready(...)

define i64 @ready_long(ptr nocapture readonly %0) {
  ; CHECK-LABEL: name: ready_long
  ; CHECK: bb.0 (%ir-block.1):
  ; CHECK-NEXT:   liveins: $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r0 {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     $r0 = LDri10 0, killed $r0, 0 :: (load (s64) from %ir.0)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r0, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 3
  ; CHECK-NEXT:     $r0 = READYp1r killed $r0
  ; CHECK-NEXT:     RET implicit $ra, implicit internal $r0
  ; CHECK-NEXT:   }
  %2 = load i64, ptr %0
  %3 = tail call i64 (...) @llvm.kvx.ready(i64 %2)
  ret i64 %3
}

define i64 @ready_v2i8(ptr nocapture readonly %0) {
  ; CHECK-LABEL: name: ready_v2i8
  ; CHECK: bb.0 (%ir-block.1):
  ; CHECK-NEXT:   liveins: $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r0 {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     $r0 = LHZri10 0, killed $r0, 0 :: (load (s16) from %ir.2)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r0, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 3
  ; CHECK-NEXT:     $r0 = READYp1r killed $r0
  ; CHECK-NEXT:     RET implicit $ra, implicit internal $r0
  ; CHECK-NEXT:   }
  %2 = bitcast ptr %0 to ptr 
  %3 = load half, ptr %2
  %4 = tail call i64 (...) @llvm.kvx.ready(half %3)
  ret i64 %4
}

define i64 @ready_v2i16(ptr nocapture readonly %0) {
  ; CHECK-LABEL: name: ready_v2i16
  ; CHECK: bb.0 (%ir-block.1):
  ; CHECK-NEXT:   liveins: $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r0 {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     $r0 = LWZri10 0, killed $r0, 0 :: (load (s32) from %ir.2)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r0, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 3
  ; CHECK-NEXT:     $r0 = READYp1r killed $r0
  ; CHECK-NEXT:     RET implicit $ra, implicit internal $r0
  ; CHECK-NEXT:   }
  %2 = bitcast ptr %0 to ptr 
  %3 = load i32, ptr %2
  %4 = tail call i64 (...) @llvm.kvx.ready(i32 %3)
  ret i64 %4
}

define i64 @ready_v2i32(ptr nocapture readonly %0) {
  ; CHECK-LABEL: name: ready_v2i32
  ; CHECK: bb.0 (%ir-block.1):
  ; CHECK-NEXT:   liveins: $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r0 {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     $r0 = LDri10 0, killed $r0, 0 :: (load (s64) from %ir.2)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r0, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 3
  ; CHECK-NEXT:     $r0 = READYp1r killed $r0
  ; CHECK-NEXT:     RET implicit $ra, implicit internal $r0
  ; CHECK-NEXT:   }
  %2 = bitcast ptr %0 to ptr 
  %3 = load i64, ptr %2
  %4 = tail call i64 (...) @llvm.kvx.ready(i64 %3)
  ret i64 %4
}

define i64 @ready_v2i64(ptr nocapture readonly %0) {
  ; CHECK-LABEL: name: ready_v2i64
  ; CHECK: bb.0 (%ir-block.1):
  ; CHECK-NEXT:   liveins: $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit-def $p0, implicit-def $r0, implicit-def $r1, implicit killed $r0 {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     $p0 = LQri10 0, killed $r0, 0 :: (load (s128) from %ir.0)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $p0, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 3
  ; CHECK-NEXT:     $r0 = READYp1r killed $p0
  ; CHECK-NEXT:     RET implicit $ra, implicit internal $r0
  ; CHECK-NEXT:   }
  %2 = load <2 x i64>, ptr %0
  %3 = tail call i64 (...) @llvm.kvx.ready(<2 x i64> %2)
  ret i64 %3
}

define i64 @ready_v4i8(ptr nocapture readonly %0) {
  ; CHECK-LABEL: name: ready_v4i8
  ; CHECK: bb.0 (%ir-block.1):
  ; CHECK-NEXT:   liveins: $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r0 {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     $r0 = LWZri10 0, killed $r0, 0 :: (load (s32) from %ir.2)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r0, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 3
  ; CHECK-NEXT:     $r0 = READYp1r killed $r0
  ; CHECK-NEXT:     RET implicit $ra, implicit internal $r0
  ; CHECK-NEXT:   }
  %2 = bitcast ptr %0 to ptr 
  %3 = load i32, ptr %2
  %4 = tail call i64 (...) @llvm.kvx.ready(i32 %3)
  ret i64 %4
}

define i64 @ready_v4i16(ptr nocapture readonly %0) {
  ; CHECK-LABEL: name: ready_v4i16
  ; CHECK: bb.0 (%ir-block.1):
  ; CHECK-NEXT:   liveins: $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r0 {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     $r0 = LDri10 0, killed $r0, 0 :: (load (s64) from %ir.2)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r0, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 3
  ; CHECK-NEXT:     $r0 = READYp1r killed $r0
  ; CHECK-NEXT:     RET implicit $ra, implicit internal $r0
  ; CHECK-NEXT:   }
  %2 = bitcast ptr %0 to ptr 
  %3 = load i64, ptr %2
  %4 = tail call i64 (...) @llvm.kvx.ready(i64 %3)
  ret i64 %4
}

define i64 @ready_v4i32(ptr nocapture readonly %0) {
  ; CHECK-LABEL: name: ready_v4i32
  ; CHECK: bb.0 (%ir-block.1):
  ; CHECK-NEXT:   liveins: $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit-def $p0, implicit-def $r0, implicit-def $r1, implicit killed $r0 {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     $p0 = LQri10 0, killed $r0, 0 :: (load (s128) from %ir.2)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $p0, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 3
  ; CHECK-NEXT:     $r0 = READYp1r killed $p0
  ; CHECK-NEXT:     RET implicit $ra, implicit internal $r0
  ; CHECK-NEXT:   }
  %2 = bitcast ptr %0 to ptr 
  %3 = load <2 x i64>, ptr %2
  %4 = tail call i64 (...) @llvm.kvx.ready(<2 x i64> %3)
  ret i64 %4
}

define i64 @ready_v4i64(ptr nocapture readonly %0) {
  ; CHECK-LABEL: name: ready_v4i64
  ; CHECK: bb.0 (%ir-block.1):
  ; CHECK-NEXT:   liveins: $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit-def $q0, implicit-def $p0, implicit-def $r0, implicit-def $r1, implicit-def $p2, implicit-def $r2, implicit-def $r3, implicit killed $r0 {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     $q0 = LOri10 0, killed $r0, 0 :: (load (s256) from %ir.0)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $q0, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 3
  ; CHECK-NEXT:     $r0 = READYp1r killed $q0
  ; CHECK-NEXT:     RET implicit $ra, implicit internal $r0
  ; CHECK-NEXT:   }
  %2 = load <4 x i64>, ptr %0
  %3 = tail call i64 (...) @llvm.kvx.ready(<4 x i64> %2)
  ret i64 %3
}

define i64 @ready_v8i8(ptr nocapture readonly %0) {
  ; CHECK-LABEL: name: ready_v8i8
  ; CHECK: bb.0 (%ir-block.1):
  ; CHECK-NEXT:   liveins: $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r0 {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     $r0 = LDri10 0, killed $r0, 0 :: (load (s64) from %ir.2)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r0, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 3
  ; CHECK-NEXT:     $r0 = READYp1r killed $r0
  ; CHECK-NEXT:     RET implicit $ra, implicit internal $r0
  ; CHECK-NEXT:   }
  %2 = bitcast ptr %0 to ptr 
  %3 = load i64, ptr %2
  %4 = tail call i64 (...) @llvm.kvx.ready(i64 %3)
  ret i64 %4
}

define i64 @ready__Float16(ptr nocapture readonly %0) {
  ; CHECK-LABEL: name: ready__Float16
  ; CHECK: bb.0 (%ir-block.1):
  ; CHECK-NEXT:   liveins: $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r0 {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     $r0 = LHZri10 0, killed $r0, 0 :: (load (s16) from %ir.0)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r0, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 3
  ; CHECK-NEXT:     $r0 = READYp1r killed $r0
  ; CHECK-NEXT:     RET implicit $ra, implicit internal $r0
  ; CHECK-NEXT:   }
  %2 = load half, ptr %0
  %3 = tail call i64 (...) @llvm.kvx.ready(half %2)
  ret i64 %3
}

define i64 @ready_float(ptr nocapture readonly %0) {
  ; CHECK-LABEL: name: ready_float
  ; CHECK: bb.0 (%ir-block.1):
  ; CHECK-NEXT:   liveins: $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r0 {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     $r0 = LWZri10 0, killed $r0, 0 :: (load (s32) from %ir.0)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r0, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 3
  ; CHECK-NEXT:     $r0 = READYp1r killed $r0
  ; CHECK-NEXT:     RET implicit $ra, implicit internal $r0
  ; CHECK-NEXT:   }
  %2 = load float, ptr %0
  %3 = fpext float %2 to double
  %4 = bitcast double %3 to i64
  %5 = tail call i64 (...) @llvm.kvx.ready(i64 %4)
  ret i64 %5
}

define i64 @ready_double(ptr nocapture readonly %0) {
  ; CHECK-LABEL: name: ready_double
  ; CHECK: bb.0 (%ir-block.1):
  ; CHECK-NEXT:   liveins: $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r0 {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     $r0 = LDri10 0, killed $r0, 0 :: (load (s64) from %ir.2)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r0, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 3
  ; CHECK-NEXT:     $r0 = READYp1r killed $r0
  ; CHECK-NEXT:     RET implicit $ra, implicit internal $r0
  ; CHECK-NEXT:   }
  %2 = bitcast ptr %0 to ptr 
  %3 = load i64, ptr %2
  %4 = tail call i64 (...) @llvm.kvx.ready(i64 %3)
  ret i64 %4
}

define i64 @ready_v2f16(ptr nocapture readonly %0) {
  ; CHECK-LABEL: name: ready_v2f16
  ; CHECK: bb.0 (%ir-block.1):
  ; CHECK-NEXT:   liveins: $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r0 {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     $r0 = LWZri10 0, killed $r0, 0 :: (load (s32) from %ir.2)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r0, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 3
  ; CHECK-NEXT:     $r0 = READYp1r killed $r0
  ; CHECK-NEXT:     RET implicit $ra, implicit internal $r0
  ; CHECK-NEXT:   }
  %2 = bitcast ptr %0 to ptr 
  %3 = load i32, ptr %2
  %4 = tail call i64 (...) @llvm.kvx.ready(i32 %3)
  ret i64 %4
}

define i64 @ready_v2f32(ptr nocapture readonly %0) {
  ; CHECK-LABEL: name: ready_v2f32
  ; CHECK: bb.0 (%ir-block.1):
  ; CHECK-NEXT:   liveins: $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r0 {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     $r0 = LDri10 0, killed $r0, 0 :: (load (s64) from %ir.2)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r0, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 3
  ; CHECK-NEXT:     $r0 = READYp1r killed $r0
  ; CHECK-NEXT:     RET implicit $ra, implicit internal $r0
  ; CHECK-NEXT:   }
  %2 = bitcast ptr %0 to ptr 
  %3 = load i64, ptr %2
  %4 = tail call i64 (...) @llvm.kvx.ready(i64 %3)
  ret i64 %4
}

define i64 @ready_v2f64(ptr nocapture readonly %0) {
  ; CHECK-LABEL: name: ready_v2f64
  ; CHECK: bb.0 (%ir-block.1):
  ; CHECK-NEXT:   liveins: $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit-def $p0, implicit-def $r0, implicit-def $r1, implicit killed $r0 {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     $p0 = LQri10 0, killed $r0, 0 :: (load (s128) from %ir.2)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $p0, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 3
  ; CHECK-NEXT:     $r0 = READYp1r killed $p0
  ; CHECK-NEXT:     RET implicit $ra, implicit internal $r0
  ; CHECK-NEXT:   }
  %2 = bitcast ptr %0 to ptr 
  %3 = load <2 x i64>, ptr %2
  %4 = tail call i64 (...) @llvm.kvx.ready(<2 x i64> %3)
  ret i64 %4
}

define i64 @ready_v4f16(ptr nocapture readonly %0) {
  ; CHECK-LABEL: name: ready_v4f16
  ; CHECK: bb.0 (%ir-block.1):
  ; CHECK-NEXT:   liveins: $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r0 {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     $r0 = LDri10 0, killed $r0, 0 :: (load (s64) from %ir.2)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r0, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 3
  ; CHECK-NEXT:     $r0 = READYp1r killed $r0
  ; CHECK-NEXT:     RET implicit $ra, implicit internal $r0
  ; CHECK-NEXT:   }
  %2 = bitcast ptr %0 to ptr 
  %3 = load i64, ptr %2
  %4 = tail call i64 (...) @llvm.kvx.ready(i64 %3)
  ret i64 %4
}

define i64 @ready_v4f32(ptr nocapture readonly %0) {
  ; CHECK-LABEL: name: ready_v4f32
  ; CHECK: bb.0 (%ir-block.1):
  ; CHECK-NEXT:   liveins: $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit-def $p0, implicit-def $r0, implicit-def $r1, implicit killed $r0 {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     $p0 = LQri10 0, killed $r0, 0 :: (load (s128) from %ir.2)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $p0, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 3
  ; CHECK-NEXT:     $r0 = READYp1r killed $p0
  ; CHECK-NEXT:     RET implicit $ra, implicit internal $r0
  ; CHECK-NEXT:   }
  %2 = bitcast ptr %0 to ptr 
  %3 = load <2 x i64>, ptr %2
  %4 = tail call i64 (...) @llvm.kvx.ready(<2 x i64> %3)
  ret i64 %4
}

define i64 @ready_v4f64(ptr nocapture readonly %0) {
  ; CHECK-LABEL: name: ready_v4f64
  ; CHECK: bb.0 (%ir-block.1):
  ; CHECK-NEXT:   liveins: $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit-def $q0, implicit-def $p0, implicit-def $r0, implicit-def $r1, implicit-def $p2, implicit-def $r2, implicit-def $r3, implicit killed $r0 {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     $q0 = LOri10 0, killed $r0, 0 :: (load (s256) from %ir.2)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $q0, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 3
  ; CHECK-NEXT:     $r0 = READYp1r killed $q0
  ; CHECK-NEXT:     RET implicit $ra, implicit internal $r0
  ; CHECK-NEXT:   }
  %2 = bitcast ptr %0 to ptr 
  %3 = load <4 x i64>, ptr %2
  %4 = tail call i64 (...) @llvm.kvx.ready(<4 x i64> %3)
  ret i64 %4
}

define i64 @ready___int128(ptr nocapture readonly %0) {
  ; CHECK-LABEL: name: ready___int128
  ; CHECK: bb.0 (%ir-block.1):
  ; CHECK-NEXT:   liveins: $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit-def $p0, implicit-def $r0, implicit-def $r1, implicit killed $r0 {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     $p0 = LQri10 0, killed $r0, 0 :: (load (s128) from %ir.2)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $p0, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 3
  ; CHECK-NEXT:     $r0 = READYp1r killed $p0
  ; CHECK-NEXT:     RET implicit $ra, implicit internal $r0
  ; CHECK-NEXT:   }
  %2 = bitcast ptr %0 to ptr 
  %3 = load <2 x i64>, ptr %2
  %4 = tail call i64 (...) @llvm.kvx.ready(<2 x i64> %3)
  ret i64 %4
}

define i64 @ready_v8i16(ptr nocapture readonly %0) {
  ; CHECK-LABEL: name: ready_v8i16
  ; CHECK: bb.0 (%ir-block.1):
  ; CHECK-NEXT:   liveins: $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit-def $p0, implicit-def $r0, implicit-def $r1, implicit killed $r0 {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     $p0 = LQri10 0, killed $r0, 0 :: (load (s128) from %ir.2)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $p0, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 3
  ; CHECK-NEXT:     $r0 = READYp1r killed $p0
  ; CHECK-NEXT:     RET implicit $ra, implicit internal $r0
  ; CHECK-NEXT:   }
  %2 = bitcast ptr %0 to ptr 
  %3 = load <2 x i64>, ptr %2
  %4 = tail call i64 (...) @llvm.kvx.ready(<2 x i64> %3)
  ret i64 %4
}

define i64 @ready_v8i32(ptr nocapture readonly %0) {
  ; CHECK-LABEL: name: ready_v8i32
  ; CHECK: bb.0 (%ir-block.1):
  ; CHECK-NEXT:   liveins: $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit-def $q0, implicit-def $p0, implicit-def $r0, implicit-def $r1, implicit-def $p2, implicit-def $r2, implicit-def $r3, implicit killed $r0 {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     $q0 = LOri10 0, killed $r0, 0 :: (load (s256) from %ir.2)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $q0, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 3
  ; CHECK-NEXT:     $r0 = READYp1r killed $q0
  ; CHECK-NEXT:     RET implicit $ra, implicit internal $r0
  ; CHECK-NEXT:   }
  %2 = bitcast ptr %0 to ptr 
  %3 = load <4 x i64>, ptr %2
  %4 = tail call i64 (...) @llvm.kvx.ready(<4 x i64> %3)
  ret i64 %4
}

define i64 @ready_char(ptr nocapture readonly %0) {
  ; CHECK-LABEL: name: ready_char
  ; CHECK: bb.0 (%ir-block.1):
  ; CHECK-NEXT:   liveins: $r0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r0 {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     $r0 = LBSri10 0, killed $r0, 0 :: (load (s8) from %ir.0)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r0, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 3
  ; CHECK-NEXT:     $r0 = READYp1r killed $r0
  ; CHECK-NEXT:     RET implicit $ra, implicit internal $r0
  ; CHECK-NEXT:   }
  %2 = load i8, ptr %0
  %3 = sext i8 %2 to i32
  %4 = tail call i64 (...) @llvm.kvx.ready(i32 %3)
  ret i64 %4
}

define i64 @ready_int_v4f32(ptr nocapture readonly %0, ptr nocapture readonly %1) {
  ; CHECK-LABEL: name: ready_int_v4f32
  ; CHECK: bb.0 (%ir-block.2):
  ; CHECK-NEXT:   liveins: $r0, $r1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r0 {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     $r0 = LWZri10 0, killed $r0, 0 :: (load (s32) from %ir.0)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $p2, implicit-def $r2, implicit-def $r3, implicit killed $r1 {
  ; CHECK-NEXT:     MCYCLESp 1
  ; CHECK-NEXT:     $p2 = LQri10 0, killed $r1, 0 :: (load (s128) from %ir.4)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r0, implicit killed $p2, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 4
  ; CHECK-NEXT:     $r0 = READYp2r killed $r0, killed $p2
  ; CHECK-NEXT:     RET implicit $ra, implicit internal $r0
  ; CHECK-NEXT:   }
  %3 = load i32, ptr %0
  %4 = bitcast ptr %1 to ptr 
  %5 = load <2 x i64>, ptr %4
  %6 = tail call i64 (...) @llvm.kvx.ready(i32 %3, <2 x i64> %5)
  ret i64 %6
}

define i64 @ready_long_int(ptr nocapture readonly %0, ptr nocapture readonly %1) {
  ; CHECK-LABEL: name: ready_long_int
  ; CHECK: bb.0 (%ir-block.2):
  ; CHECK-NEXT:   liveins: $r0, $r1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r0 {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     $r0 = LDri10 0, killed $r0, 0 :: (load (s64) from %ir.0)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r1, implicit killed $r1 {
  ; CHECK-NEXT:     MCYCLESp 1
  ; CHECK-NEXT:     $r1 = LWZri10 0, killed $r1, 0 :: (load (s32) from %ir.1)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r0, implicit killed $r1, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 4
  ; CHECK-NEXT:     $r0 = READYp2r killed $r0, killed $r1
  ; CHECK-NEXT:     RET implicit $ra, implicit internal $r0
  ; CHECK-NEXT:   }
  %3 = load i64, ptr %0
  %4 = load i32, ptr %1
  %5 = tail call i64 (...) @llvm.kvx.ready(i64 %3, i32 %4)
  ret i64 %5
}

define i64 @ready_float_v8i8(ptr nocapture readonly %0, ptr nocapture readonly %1) {
  ; CHECK-LABEL: name: ready_float_v8i8
  ; CHECK: bb.0 (%ir-block.2):
  ; CHECK-NEXT:   liveins: $r0, $r1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r0 {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     $r0 = LWZri10 0, killed $r0, 0 :: (load (s32) from %ir.0)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r1, implicit killed $r1 {
  ; CHECK-NEXT:     MCYCLESp 1
  ; CHECK-NEXT:     $r1 = LDri10 0, killed $r1, 0 :: (load (s64) from %ir.6)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r0, implicit killed $r1, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 4
  ; CHECK-NEXT:     $r0 = READYp2r killed $r0, killed $r1
  ; CHECK-NEXT:     RET implicit $ra, implicit internal $r0
  ; CHECK-NEXT:   }
  %3 = load float, ptr %0
  %4 = fpext float %3 to double
  %5 = bitcast double %4 to i64
  %6 = bitcast ptr %1 to ptr 
  %7 = load i64, ptr %6
  %8 = tail call i64 (...) @llvm.kvx.ready(i64 %5, i64 %7)
  ret i64 %8
}

define i64 @ready_int_long_float(ptr nocapture readonly %0, ptr nocapture readonly %1, ptr nocapture readonly %2) {
  ; CHECK-LABEL: name: ready_int_long_float
  ; CHECK: bb.0 (%ir-block.3):
  ; CHECK-NEXT:   liveins: $r0, $r1, $r2
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r0 {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     $r0 = LWZri10 0, killed $r0, 0 :: (load (s32) from %ir.0)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r1, implicit killed $r1 {
  ; CHECK-NEXT:     MCYCLESp 1
  ; CHECK-NEXT:     $r1 = LDri10 0, killed $r1, 0 :: (load (s64) from %ir.1)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r2, implicit killed $r2 {
  ; CHECK-NEXT:     MCYCLESp 2
  ; CHECK-NEXT:     $r2 = LWZri10 0, killed $r2, 0 :: (load (s32) from %ir.2)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r0, implicit killed $r1, implicit killed $r2, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 5
  ; CHECK-NEXT:     $r0 = READYp3r killed $r0, killed $r1, killed $r2
  ; CHECK-NEXT:     RET implicit $ra, implicit internal $r0
  ; CHECK-NEXT:   }
  %4 = load i32, ptr %0
  %5 = load i64, ptr %1
  %6 = load float, ptr %2
  %7 = fpext float %6 to double
  %8 = bitcast double %7 to i64
  %9 = tail call i64 (...) @llvm.kvx.ready(i32 %4, i64 %5, i64 %8)
  ret i64 %9
}

define i64 @ready___int128_v8i8_v2i64(ptr nocapture readonly %0, ptr nocapture readonly %1, ptr nocapture readonly %2) {
  ; CHECK-LABEL: name: ready___int128_v8i8_v2i64
  ; CHECK: bb.0 (%ir-block.3):
  ; CHECK-NEXT:   liveins: $r0, $r1, $r2
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit-def $p4, implicit-def $r4, implicit-def $r5, implicit killed $r0 {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     $p4 = LQri10 0, killed $r0, 0 :: (load (s128) from %ir.4)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r1 {
  ; CHECK-NEXT:     MCYCLESp 1
  ; CHECK-NEXT:     $r0 = LDri10 0, killed $r1, 0 :: (load (s64) from %ir.6)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $p2, implicit-def $r2, implicit-def $r3, implicit killed $r2 {
  ; CHECK-NEXT:     MCYCLESp 2
  ; CHECK-NEXT:     $p2 = LQri10 0, killed $r2, 0 :: (load (s128) from %ir.2)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $p4, implicit killed $r0, implicit killed $p2, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 5
  ; CHECK-NEXT:     $r0 = READYp3r killed $p4, killed $r0, killed $p2
  ; CHECK-NEXT:     RET implicit $ra, implicit internal $r0
  ; CHECK-NEXT:   }
  %4 = bitcast ptr %0 to ptr 
  %5 = load <2 x i64>, ptr %4
  %6 = bitcast ptr %1 to ptr 
  %7 = load i64, ptr %6
  %8 = load <2 x i64>, ptr %2
  %9 = tail call i64 (...) @llvm.kvx.ready(<2 x i64> %5, i64 %7, <2 x i64> %8)
  ret i64 %9
}

define i64 @ready_char_short_double(ptr nocapture readonly %0, ptr nocapture readonly %1, ptr nocapture readonly %2) {
  ; CHECK-LABEL: name: ready_char_short_double
  ; CHECK: bb.0 (%ir-block.3):
  ; CHECK-NEXT:   liveins: $r0, $r1, $r2
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r0 {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     $r0 = LBSri10 0, killed $r0, 0 :: (load (s8) from %ir.0)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r1, implicit killed $r1 {
  ; CHECK-NEXT:     MCYCLESp 1
  ; CHECK-NEXT:     $r1 = LHSri10 0, killed $r1, 0 :: (load (s16) from %ir.1)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r2, implicit killed $r2 {
  ; CHECK-NEXT:     MCYCLESp 2
  ; CHECK-NEXT:     $r2 = LDri10 0, killed $r2, 0 :: (load (s64) from %ir.8)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r0, implicit killed $r1, implicit killed $r2, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 5
  ; CHECK-NEXT:     $r0 = READYp3r killed $r0, killed $r1, killed $r2
  ; CHECK-NEXT:     RET implicit $ra, implicit internal $r0
  ; CHECK-NEXT:   }
  %4 = load i8, ptr %0
  %5 = sext i8 %4 to i32
  %6 = load i16, ptr %1
  %7 = sext i16 %6 to i32
  %8 = bitcast ptr %2 to ptr 
  %9 = load i64, ptr %8
  %10 = tail call i64 (...) @llvm.kvx.ready(i32 %5, i32 %7, i64 %9)
  ret i64 %10
}

define i64 @ready_char_short_int_long(ptr nocapture readonly %0, ptr nocapture readonly %1, ptr nocapture readonly %2, ptr nocapture readonly %3) {
  ; CHECK-LABEL: name: ready_char_short_int_long
  ; CHECK: bb.0 (%ir-block.4):
  ; CHECK-NEXT:   liveins: $r0, $r1, $r2, $r3
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r0 {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     $r0 = LBSri10 0, killed $r0, 0 :: (load (s8) from %ir.0)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r1, implicit killed $r1 {
  ; CHECK-NEXT:     MCYCLESp 1
  ; CHECK-NEXT:     $r1 = LHSri10 0, killed $r1, 0 :: (load (s16) from %ir.1)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r2, implicit killed $r2 {
  ; CHECK-NEXT:     MCYCLESp 2
  ; CHECK-NEXT:     $r2 = LWZri10 0, killed $r2, 0 :: (load (s32) from %ir.2)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r3, implicit killed $r3 {
  ; CHECK-NEXT:     MCYCLESp 3
  ; CHECK-NEXT:     $r3 = LDri10 0, killed $r3, 0 :: (load (s64) from %ir.3)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r0, implicit killed $r1, implicit killed $r2, implicit killed $r3, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 6
  ; CHECK-NEXT:     $r0 = READYp4r killed $r0, killed $r1, killed $r2, killed $r3
  ; CHECK-NEXT:     RET implicit $ra, implicit internal $r0
  ; CHECK-NEXT:   }
  %5 = load i8, ptr %0
  %6 = sext i8 %5 to i32
  %7 = load i16, ptr %1
  %8 = sext i16 %7 to i32
  %9 = load i32, ptr %2
  %10 = load i64, ptr %3
  %11 = tail call i64 (...) @llvm.kvx.ready(i32 %6, i32 %8, i32 %9, i64 %10)
  ret i64 %11
}

define i64 @ready__Float16_float_double_v4i64(ptr nocapture readonly %0, ptr nocapture readonly %1, ptr nocapture readonly %2, ptr nocapture readonly %3) {
  ; CHECK-LABEL: name: ready__Float16_float_double_v4i64
  ; CHECK: bb.0 (%ir-block.4):
  ; CHECK-NEXT:   liveins: $r0, $r1, $r2, $r3
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r0 {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     $r0 = LHZri10 0, killed $r0, 0 :: (load (s16) from %ir.0)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r1, implicit killed $r1 {
  ; CHECK-NEXT:     MCYCLESp 1
  ; CHECK-NEXT:     $r1 = LWZri10 0, killed $r1, 0 :: (load (s32) from %ir.1)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r2, implicit killed $r2 {
  ; CHECK-NEXT:     MCYCLESp 2
  ; CHECK-NEXT:     $r2 = LDri10 0, killed $r2, 0 :: (load (s64) from %ir.9)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $q4, implicit-def $p4, implicit-def $r4, implicit-def $r5, implicit-def $p6, implicit-def $r6, implicit-def $r7, implicit killed $r3 {
  ; CHECK-NEXT:     MCYCLESp 3
  ; CHECK-NEXT:     $q4 = LOri10 0, killed $r3, 0 :: (load (s256) from %ir.3)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $r0, implicit killed $r1, implicit killed $r2, implicit killed $q4, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 6
  ; CHECK-NEXT:     $r0 = READYp4r killed $r0, killed $r1, killed $r2, killed $q4
  ; CHECK-NEXT:     RET implicit $ra, implicit internal $r0
  ; CHECK-NEXT:   }
  %5 = load half, ptr %0
  %6 = load float, ptr %1
  %7 = fpext float %6 to double
  %8 = bitcast double %7 to i64
  %9 = bitcast ptr %2 to ptr 
  %10 = load i64, ptr %9
  %11 = load <4 x i64>, ptr %3
  %12 = tail call i64 (...) @llvm.kvx.ready(half %5, i64 %8, i64 %10, <4 x i64> %11)
  ret i64 %12
}

define i64 @ready_v8f32_v4i32___int128_char(ptr nocapture readonly %0, ptr nocapture readonly %1, ptr nocapture readonly %2, ptr nocapture readonly %3) {
  ; CHECK-LABEL: name: ready_v8f32_v4i32___int128_char
  ; CHECK: bb.0 (%ir-block.4):
  ; CHECK-NEXT:   liveins: $r0, $r1, $r2, $r3
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BUNDLE implicit-def $q4, implicit-def $p4, implicit-def $r4, implicit-def $r5, implicit-def $p6, implicit-def $r6, implicit-def $r7, implicit killed $r0 {
  ; CHECK-NEXT:     MCYCLESp 0
  ; CHECK-NEXT:     $q4 = LOri10 0, killed $r0, 0 :: (load (s256) from %ir.5)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $p0, implicit-def $r0, implicit-def $r1, implicit killed $r1 {
  ; CHECK-NEXT:     MCYCLESp 1
  ; CHECK-NEXT:     $p0 = LQri10 0, killed $r1, 0 :: (load (s128) from %ir.7)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $p8, implicit-def $r8, implicit-def $r9, implicit killed $r2 {
  ; CHECK-NEXT:     MCYCLESp 2
  ; CHECK-NEXT:     $p8 = LQri10 0, killed $r2, 0 :: (load (s128) from %ir.9)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r2, implicit killed $r3 {
  ; CHECK-NEXT:     MCYCLESp 3
  ; CHECK-NEXT:     $r2 = LBSri10 0, killed $r3, 0 :: (load (s8) from %ir.3)
  ; CHECK-NEXT:   }
  ; CHECK-NEXT:   BUNDLE implicit-def $r0, implicit killed $q4, implicit killed $p0, implicit killed $p8, implicit killed $r2, implicit $ra {
  ; CHECK-NEXT:     MCYCLESp 6
  ; CHECK-NEXT:     $r0 = READYp4r killed $q4, killed $p0, killed $p8, killed $r2
  ; CHECK-NEXT:     RET implicit $ra, implicit internal $r0
  ; CHECK-NEXT:   }
  %5 = bitcast ptr %0 to ptr 
  %6 = load <4 x i64>, ptr %5
  %7 = bitcast ptr %1 to ptr 
  %8 = load <2 x i64>, ptr %7
  %9 = bitcast ptr %2 to ptr 
  %10 = load <2 x i64>, ptr %9
  %11 = load i8, ptr %3
  %12 = sext i8 %11 to i32
  %13 = tail call i64 (...) @llvm.kvx.ready(<4 x i64> %6, <2 x i64> %8, <2 x i64> %10, i32 %12)
  ret i64 %13
}

