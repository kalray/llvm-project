; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -o - %s -O2 | FileCheck %s --check-prefixes=CHECK
; RUN: llc -mcpu=kv3-2 -o - %s -O2 | FileCheck %s --check-prefixes=CHECK
; RUN: clang -O2 -c -o /dev/null %s
; RUN: clang -march=kv3-2 -c -o /dev/null %s

target triple = "kvx-kalray-cos"

define i8 @lbz(ptr nocapture readonly %p){
; CHECK-LABEL: lbz:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lbz.u $r0 = 0[$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %0 = addrspacecast ptr %p to ptr addrspace(256)
  %1 = load i8, ptr addrspace(256) %0, align 1
  ret i8 %1
}

define i32 @lbs_volatile(ptr %p){
; CHECK-LABEL: lbs_volatile:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lbs.us $r0 = 0[$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %0 = addrspacecast ptr %p to ptr addrspace(257)
  %1 = load volatile i8, ptr addrspace(257) %0, align 1
  %conv = sext i8 %1 to i32
  ret i32 %conv
}

define i16 @lhz(ptr nocapture readonly %p){
; CHECK-LABEL: lhz:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lhz.u $r0 = 0[$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %0 = bitcast ptr %p to ptr 
  %1 = addrspacecast ptr %0 to ptr addrspace(256)
  %2 = load i16, ptr addrspace(256) %1, align 2
  ret i16 %2
}

define i32 @lhs_volatile(ptr %p){
; CHECK-LABEL: lhs_volatile:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lhs.us $r0 = 0[$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %0 = bitcast ptr %p to ptr 
  %1 = addrspacecast ptr %0 to ptr addrspace(257)
  %2 = load volatile i16, ptr addrspace(257) %1, align 2
  %conv = sext i16 %2 to i32
  ret i32 %conv
}

define i32 @lwz(ptr nocapture readonly %p){
; CHECK-LABEL: lwz:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lwz.u $r0 = 0[$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %0 = bitcast ptr %p to ptr 
  %1 = addrspacecast ptr %0 to ptr addrspace(256)
  %2 = load i32, ptr addrspace(256) %1, align 4
  ret i32 %2
}

define i32 @lws_volatile(ptr %p){
; CHECK-LABEL: lws_volatile:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lwz.us $r0 = 0[$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %0 = bitcast ptr %p to ptr 
  %1 = addrspacecast ptr %0 to ptr addrspace(257)
  %2 = load volatile i32, ptr addrspace(257) %1, align 4
  ret i32 %2
}

define float @lwf(ptr %p){
; CHECK-LABEL: lwf:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lwz.s $r0 = 0[$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %0 = bitcast ptr %p to ptr 
  %1 = addrspacecast ptr %0 to ptr addrspace(258)
  %2 = load volatile float, ptr addrspace(258) %1, align 4
  ret float %2
}

define i64 @ld(ptr %p){
; CHECK-LABEL: ld:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ld.s $r0 = 0[$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %0 = bitcast ptr %p to ptr 
  %1 = addrspacecast ptr %0 to ptr addrspace(258)
  %2 = load volatile i64, ptr addrspace(258) %1, align 8
  ret i64 %2
}

define double @ldf(ptr %p){
; CHECK-LABEL: ldf:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ld.s $r0 = 0[$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %0 = bitcast ptr %p to ptr 
  %1 = addrspacecast ptr %0 to ptr addrspace(258)
  %2 = load volatile double, ptr addrspace(258) %1, align 8
  ret double %2
}

define <8 x i8> @ldbo(ptr %p){
; CHECK-LABEL: ldbo:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ld.s $r0 = 0[$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %0 = bitcast ptr %p to ptr 
  %1 = addrspacecast ptr %0 to ptr addrspace(258)
  %2 = load volatile <8 x i8>, ptr addrspace(258) %1, align 8
  ret <8 x i8> %2
}

define <4 x i16> @ldhq(ptr %p){
; CHECK-LABEL: ldhq:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ld.s $r0 = 0[$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %0 = bitcast ptr %p to ptr 
  %1 = addrspacecast ptr %0 to ptr addrspace(258)
  %2 = load volatile <4 x i16>, ptr addrspace(258) %1, align 8
  ret <4 x i16> %2
}

define <2 x i32> @ldwp(ptr %p){
; CHECK-LABEL: ldwp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ld.s $r0 = 0[$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %0 = bitcast ptr %p to ptr 
  %1 = addrspacecast ptr %0 to ptr addrspace(258)
  %2 = load volatile <2 x i32>, ptr addrspace(258) %1, align 8
  ret <2 x i32> %2
}

define <2 x float> @ldfwp(ptr %p){
; CHECK-LABEL: ldfwp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ld.s $r0 = 0[$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %0 = bitcast ptr %p to ptr 
  %1 = addrspacecast ptr %0 to ptr addrspace(258)
  %2 = load volatile <2 x float>, ptr addrspace(258) %1, align 8
  ret <2 x float> %2
}

define void @sdbo(ptr %p, <8 x i8> %v){
; CHECK-LABEL: sdbo:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sd 0[$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %0 = bitcast ptr %p to ptr 
  store volatile <8 x i8> %v, ptr %0, align 8
  ret void
}

define void @sdhq(ptr %p, <4 x i16> %v){
; CHECK-LABEL: sdhq:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sd 0[$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %0 = bitcast ptr %p to ptr 
  store volatile <4 x i16> %v, ptr %0, align 8
  ret void
}

define void @sdwp(ptr %p, <2 x i32> %v){
; CHECK-LABEL: sdwp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sd 0[$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %0 = bitcast ptr %p to ptr 
  store volatile <2 x i32> %v, ptr %0, align 8
  ret void
}

define void @sdfwp(ptr %p, <2 x float> %v){
; CHECK-LABEL: sdfwp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sd 0[$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %0 = bitcast ptr %p to ptr 
  store volatile <2 x float> %v, ptr %0, align 8
  ret void
}

