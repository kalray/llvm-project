; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -o - %s -O2 -verify-machineinstrs | FileCheck %s --check-prefixes=CHECK
; RUN: llc -mcpu=kv3-2 -o - %s -O2 -verify-machineinstrs | FileCheck %s --check-prefixes=CHECK
; RUN: clang -O2 -c -o /dev/null %s
; RUN: clang -O2 -march=kv3-2 -c -o /dev/null %s

target triple = "kvx-kalray-cos"

define void @storebc(i8 %a, i8* nocapture %ptr) {
; CHECK-LABEL: storebc:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sb 0[$r1] = $r0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  store i8 %a, i8* %ptr
  ret void
}

define i32 @storebc_r(i8 %a, i8* %ptr, i32* nocapture readonly %load) {
; CHECK-LABEL: storebc_r:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lwz $r2 = 0[$r2]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sb 0[$r1] = $r0
; CHECK-NEXT:    iord $r2 = $r2, $r2
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    copyd $r0 = $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 4)
entry:
  %0 = load i32, i32* %load
  %1 = tail call i64 (...) @llvm.kvx.ready(i32 %0)
  %conv = trunc i64 %1 to i32
  %conv1 = zext i8 %a to i64
  %2 = bitcast i8* %ptr to i64*
  tail call void @llvm.kvx.store.i64.i32(i64 %conv1, i64* %2, i32 8, i32 %conv)
  ret i32 %conv
}

declare i64 @llvm.kvx.ready(...)

declare void @llvm.kvx.store.i64.i32(i64, i64*, i32, i32)

define void @storebl(i64 %a, i8* nocapture %ptr) {
; CHECK-LABEL: storebl:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sb 0[$r1] = $r0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %0 = trunc i64 %a to i8
  store i8 %0, i8* %ptr
  ret void
}

define i32 @storebl_r(i64 %a, i8* %ptr, i32* nocapture readonly %load) {
; CHECK-LABEL: storebl_r:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lwz $r2 = 0[$r2]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sb 0[$r1] = $r0
; CHECK-NEXT:    iord $r2 = $r2, $r2
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    copyd $r0 = $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 4)
entry:
  %0 = load i32, i32* %load
  %1 = tail call i64 (...) @llvm.kvx.ready(i32 %0)
  %conv = trunc i64 %1 to i32
  %2 = bitcast i8* %ptr to i64*
  tail call void @llvm.kvx.store.i64.i32(i64 %a, i64* %2, i32 8, i32 %conv)
  ret i32 %conv
}

define void @storehs(i16 %a, i8* nocapture %ptr) {
; CHECK-LABEL: storehs:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sh 0[$r1] = $r0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %0 = bitcast i8* %ptr to i16*
  store i16 %a, i16* %0
  ret void
}

define i32 @storehs_r(i16 %a, i8* %ptr, i32* nocapture readonly %load) {
; CHECK-LABEL: storehs_r:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lwz $r2 = 0[$r2]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sh 0[$r1] = $r0
; CHECK-NEXT:    iord $r2 = $r2, $r2
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    copyd $r0 = $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 4)
entry:
  %0 = load i32, i32* %load
  %1 = tail call i64 (...) @llvm.kvx.ready(i32 %0)
  %conv = trunc i64 %1 to i32
  %conv1 = zext i16 %a to i64
  %2 = bitcast i8* %ptr to i64*
  tail call void @llvm.kvx.store.i64.i32(i64 %conv1, i64* %2, i32 16, i32 %conv)
  ret i32 %conv
}

define void @storehl(i64 %a, i8* nocapture %ptr) {
; CHECK-LABEL: storehl:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sh 0[$r1] = $r0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %0 = trunc i64 %a to i16
  %1 = bitcast i8* %ptr to i16*
  store i16 %0, i16* %1
  ret void
}

define i32 @storehl_r(i64 %a, i8* %ptr, i32* nocapture readonly %load) {
; CHECK-LABEL: storehl_r:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lwz $r2 = 0[$r2]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sh 0[$r1] = $r0
; CHECK-NEXT:    iord $r2 = $r2, $r2
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    copyd $r0 = $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 4)
entry:
  %0 = load i32, i32* %load
  %1 = tail call i64 (...) @llvm.kvx.ready(i32 %0)
  %conv = trunc i64 %1 to i32
  %2 = bitcast i8* %ptr to i64*
  tail call void @llvm.kvx.store.i64.i32(i64 %a, i64* %2, i32 16, i32 %conv)
  ret i32 %conv
}

define void @storewi(i32 %a, i8* nocapture %ptr) {
; CHECK-LABEL: storewi:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sw 0[$r1] = $r0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %0 = bitcast i8* %ptr to i32*
  store i32 %a, i32* %0
  ret void
}

define i32 @storewi_r(i32 %a, i8* %ptr, i32* nocapture readonly %load) {
; CHECK-LABEL: storewi_r:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lwz $r2 = 0[$r2]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sw 0[$r1] = $r0
; CHECK-NEXT:    iord $r2 = $r2, $r2
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    copyd $r0 = $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 4)
entry:
  %0 = load i32, i32* %load
  %1 = tail call i64 (...) @llvm.kvx.ready(i32 %0)
  %conv = trunc i64 %1 to i32
  %conv1 = zext i32 %a to i64
  %2 = bitcast i8* %ptr to i64*
  tail call void @llvm.kvx.store.i64.i32(i64 %conv1, i64* %2, i32 32, i32 %conv)
  ret i32 %conv
}

define void @storewl(i64 %a, i8* nocapture %ptr) {
; CHECK-LABEL: storewl:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sw 0[$r1] = $r0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %0 = trunc i64 %a to i32
  %1 = bitcast i8* %ptr to i32*
  store i32 %0, i32* %1
  ret void
}

define i32 @storewl_r(i64 %a, i8* %ptr, i32* nocapture readonly %load) {
; CHECK-LABEL: storewl_r:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lwz $r2 = 0[$r2]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sw 0[$r1] = $r0
; CHECK-NEXT:    iord $r2 = $r2, $r2
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    copyd $r0 = $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 4)
entry:
  %0 = load i32, i32* %load
  %1 = tail call i64 (...) @llvm.kvx.ready(i32 %0)
  %conv = trunc i64 %1 to i32
  %2 = bitcast i8* %ptr to i64*
  tail call void @llvm.kvx.store.i64.i32(i64 %a, i64* %2, i32 32, i32 %conv)
  ret i32 %conv
}

define void @storedl(i64 %a, i8* nocapture %ptr) {
; CHECK-LABEL: storedl:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sd 0[$r1] = $r0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %0 = bitcast i8* %ptr to i64*
  store i64 %a, i64* %0
  ret void
}

define i32 @storedl_r(i64 %a, i8* %ptr, i32* nocapture readonly %load) {
; CHECK-LABEL: storedl_r:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lwz $r2 = 0[$r2]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 0[$r1] = $r0
; CHECK-NEXT:    iord $r2 = $r2, $r2
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    copyd $r0 = $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 4)
entry:
  %0 = load i32, i32* %load
  %1 = tail call i64 (...) @llvm.kvx.ready(i32 %0)
  %conv = trunc i64 %1 to i32
  %2 = bitcast i8* %ptr to i64*
  tail call void @llvm.kvx.store.i64.i32(i64 %a, i64* %2, i32 64, i32 %conv)
  ret i32 %conv
}

define void @storeq(i128 %a, i8* nocapture %ptr) {
; CHECK-LABEL: storeq:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sq 0[$r2] = $r0r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %0 = bitcast i8* %ptr to i128*
  store i128 %a, i128* %0
  ret void
}

define i32 @storeq_r(i128 %a, i8* %ptr, i32* nocapture readonly %load) {
; CHECK-LABEL: storeq_r:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lwz $r3 = 0[$r3]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sq 0[$r2] = $r0r1
; CHECK-NEXT:    iord $r3 = $r3, $r3
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    copyd $r0 = $r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 4)
entry:
  %0 = load i32, i32* %load
  %1 = tail call i64 (...) @llvm.kvx.ready(i32 %0)
  %conv = trunc i64 %1 to i32
  %2 = bitcast i128 %a to <2 x i64>
  %3 = bitcast i8* %ptr to <2 x i64>*
  tail call void @llvm.kvx.store.v2i64.i32(<2 x i64> %2, <2 x i64>* %3, i32 128, i32 %conv)
  ret i32 %conv
}

declare void @llvm.kvx.store.v2i64.i32(<2 x i64>, <2 x i64>*, i32, i32)

define void @storehf(half %a, i8* nocapture %ptr) {
; CHECK-LABEL: storehf:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sh 0[$r1] = $r0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %0 = bitcast i8* %ptr to half*
  store half %a, half* %0
  ret void
}

define i32 @storehf_r(half %a, i8* %ptr, i32* nocapture readonly %load) {
; CHECK-LABEL: storehf_r:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lwz $r2 = 0[$r2]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sh 0[$r1] = $r0
; CHECK-NEXT:    iord $r2 = $r2, $r2
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    copyd $r0 = $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 4)
entry:
  %0 = load i32, i32* %load
  %1 = tail call i64 (...) @llvm.kvx.ready(i32 %0)
  %conv = trunc i64 %1 to i32
  %2 = bitcast i8* %ptr to half*
  tail call void @llvm.kvx.store.f16.i32(half %a, half* %2, i32 16, i32 %conv)
  ret i32 %conv
}

declare void @llvm.kvx.store.f16.i32(half, half*, i32, i32)

define void @storewf(float %a, i8* nocapture %ptr) {
; CHECK-LABEL: storewf:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sw 0[$r1] = $r0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %0 = bitcast i8* %ptr to float*
  store float %a, float* %0
  ret void
}

define i32 @storewf_r(float %a, i8* %ptr, i32* nocapture readonly %load) {
; CHECK-LABEL: storewf_r:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lwz $r2 = 0[$r2]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sw 0[$r1] = $r0
; CHECK-NEXT:    iord $r2 = $r2, $r2
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    copyd $r0 = $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 4)
entry:
  %0 = load i32, i32* %load
  %1 = tail call i64 (...) @llvm.kvx.ready(i32 %0)
  %conv = trunc i64 %1 to i32
  %2 = bitcast i8* %ptr to float*
  tail call void @llvm.kvx.store.f32.i32(float %a, float* %2, i32 32, i32 %conv)
  ret i32 %conv
}

declare void @llvm.kvx.store.f32.i32(float, float*, i32, i32)

define void @storedf(double %a, i8* nocapture %ptr) {
; CHECK-LABEL: storedf:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sd 0[$r1] = $r0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %0 = bitcast i8* %ptr to double*
  store double %a, double* %0
  ret void
}

define i32 @storedf_r(double %a, i8* %ptr, i32* nocapture readonly %load) {
; CHECK-LABEL: storedf_r:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lwz $r2 = 0[$r2]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 0[$r1] = $r0
; CHECK-NEXT:    iord $r2 = $r2, $r2
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    copyd $r0 = $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 4)
entry:
  %0 = load i32, i32* %load
  %1 = tail call i64 (...) @llvm.kvx.ready(i32 %0)
  %conv = trunc i64 %1 to i32
  %2 = bitcast i8* %ptr to double*
  tail call void @llvm.kvx.store.f64.i32(double %a, double* %2, i32 64, i32 %conv)
  ret i32 %conv
}

declare void @llvm.kvx.store.f64.i32(double, double*, i32, i32)

define void @store64(<2 x i32> %a, i8* nocapture %ptr) {
; CHECK-LABEL: store64:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sd 0[$r1] = $r0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %0 = bitcast i8* %ptr to <2 x i32>*
  store <2 x i32> %a, <2 x i32>* %0
  ret void
}

define i32 @store64_r(<2 x i32> %a, i8* %ptr, i32* nocapture readonly %load) {
; CHECK-LABEL: store64_r:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lwz $r2 = 0[$r2]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 0[$r1] = $r0
; CHECK-NEXT:    iord $r2 = $r2, $r2
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    copyd $r0 = $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 4)
entry:
  %0 = load i32, i32* %load
  %1 = tail call i64 (...) @llvm.kvx.ready(i32 %0)
  %conv = trunc i64 %1 to i32
  %2 = bitcast <2 x i32> %a to i64
  %3 = bitcast i8* %ptr to i64*
  tail call void @llvm.kvx.store.i64.i32(i64 %2, i64* %3, i32 64, i32 %conv)
  ret i32 %conv
}

define void @store64h(<4 x i16> %a, i8* nocapture %ptr) {
; CHECK-LABEL: store64h:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sd 0[$r1] = $r0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %0 = bitcast i8* %ptr to <4 x i16>*
  store <4 x i16> %a, <4 x i16>* %0
  ret void
}

define i32 @store64h_r(<4 x i16> %a, i8* %ptr, i32* nocapture readonly %load) {
; CHECK-LABEL: store64h_r:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lwz $r2 = 0[$r2]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 0[$r1] = $r0
; CHECK-NEXT:    iord $r2 = $r2, $r2
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    copyd $r0 = $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 4)
entry:
  %0 = load i32, i32* %load
  %1 = tail call i64 (...) @llvm.kvx.ready(i32 %0)
  %conv = trunc i64 %1 to i32
  %2 = bitcast <4 x i16> %a to i64
  %3 = bitcast i8* %ptr to i64*
  tail call void @llvm.kvx.store.i64.i32(i64 %2, i64* %3, i32 64, i32 %conv)
  ret i32 %conv
}

define void @store128(<4 x i32> %a, i8* nocapture %ptr) {
; CHECK-LABEL: store128:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sq 0[$r2] = $r0r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %0 = bitcast i8* %ptr to <4 x i32>*
  store <4 x i32> %a, <4 x i32>* %0
  ret void
}

define i32 @store128_r(<4 x i32> %a, i8* %ptr, i32* nocapture readonly %load) {
; CHECK-LABEL: store128_r:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lwz $r3 = 0[$r3]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sq 0[$r2] = $r0r1
; CHECK-NEXT:    iord $r3 = $r3, $r3
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    copyd $r0 = $r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 4)
entry:
  %0 = load i32, i32* %load
  %1 = tail call i64 (...) @llvm.kvx.ready(i32 %0)
  %conv = trunc i64 %1 to i32
  %2 = bitcast <4 x i32> %a to <2 x i64>
  %3 = bitcast i8* %ptr to <2 x i64>*
  tail call void @llvm.kvx.store.v2i64.i32(<2 x i64> %2, <2 x i64>* %3, i32 128, i32 %conv)
  ret i32 %conv
}

define void @store128h(<8 x i16> %a, i8* nocapture %ptr) {
; CHECK-LABEL: store128h:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sq 0[$r2] = $r0r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %0 = bitcast i8* %ptr to <8 x i16>*
  store <8 x i16> %a, <8 x i16>* %0
  ret void
}

define i32 @store128h_r(<8 x i16> %a, i8* %ptr, i32* nocapture readonly %load) {
; CHECK-LABEL: store128h_r:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lwz $r3 = 0[$r3]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sq 0[$r2] = $r0r1
; CHECK-NEXT:    iord $r3 = $r3, $r3
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    copyd $r0 = $r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 4)
entry:
  %0 = load i32, i32* %load
  %1 = tail call i64 (...) @llvm.kvx.ready(i32 %0)
  %conv = trunc i64 %1 to i32
  %2 = bitcast <8 x i16> %a to <2 x i64>
  %3 = bitcast i8* %ptr to <2 x i64>*
  tail call void @llvm.kvx.store.v2i64.i32(<2 x i64> %2, <2 x i64>* %3, i32 128, i32 %conv)
  ret i32 %conv
}

define void @store256(<8 x i32> %a, i8* nocapture %ptr) {
; CHECK-LABEL: store256:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    so 0[$r4] = $r0r1r2r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %0 = bitcast i8* %ptr to <8 x i32>*
  store <8 x i32> %a, <8 x i32>* %0
  ret void
}

define i32 @store256_r(<8 x i32> %a, i8* %ptr, i32* nocapture readonly %load) {
; CHECK-LABEL: store256_r:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lwz $r5 = 0[$r5]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    so 0[$r4] = $r0r1r2r3
; CHECK-NEXT:    iord $r5 = $r5, $r5
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    copyd $r0 = $r5
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 4)
entry:
  %0 = load i32, i32* %load
  %1 = tail call i64 (...) @llvm.kvx.ready(i32 %0)
  %conv = trunc i64 %1 to i32
  %2 = bitcast <8 x i32> %a to <4 x i64>
  %3 = bitcast i8* %ptr to <4 x i64>*
  tail call void @llvm.kvx.store.v4i64.i32(<4 x i64> %2, <4 x i64>* %3, i32 256, i32 %conv)
  ret i32 %conv
}

declare void @llvm.kvx.store.v4i64.i32(<4 x i64>, <4 x i64>*, i32, i32)

define void @store256h(<16 x i16> %a, i8* nocapture %ptr) {
; CHECK-LABEL: store256h:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    so 0[$r4] = $r0r1r2r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %0 = bitcast i8* %ptr to <16 x i16>*
  store <16 x i16> %a, <16 x i16>* %0
  ret void
}

define i32 @store256h_r(<16 x i16> %a, i8* %ptr, i32* nocapture readonly %load) {
; CHECK-LABEL: store256h_r:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lwz $r5 = 0[$r5]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    so 0[$r4] = $r0r1r2r3
; CHECK-NEXT:    iord $r5 = $r5, $r5
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    copyd $r0 = $r5
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 4)
entry:
  %0 = load i32, i32* %load
  %1 = tail call i64 (...) @llvm.kvx.ready(i32 %0)
  %conv = trunc i64 %1 to i32
  %2 = bitcast <16 x i16> %a to <4 x i64>
  %3 = bitcast i8* %ptr to <4 x i64>*
  tail call void @llvm.kvx.store.v4i64.i32(<4 x i64> %2, <4 x i64>* %3, i32 256, i32 %conv)
  ret i32 %conv
}

define void @store_vol(i32 %a, i8* %ptr) {
; CHECK-LABEL: store_vol:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sw 0[$r1] = $r0
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sw 0[$r1] = $r0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
entry:
  %0 = bitcast i8* %ptr to i32*
  store volatile i32 %a, i32* %0
  store volatile i32 %a, i32* %0
  ret void
}

define void @store_novol(i32 %a, i8* nocapture %ptr) {
; CHECK-LABEL: store_novol:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sw 0[$r1] = $r0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %0 = bitcast i8* %ptr to i32*
  store i32 %a, i32* %0
  ret void
}

define i32 @store_r_vol(i32 %a, i8* %ptr, i32* nocapture readonly %load) {
; CHECK-LABEL: store_r_vol:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lwz $r2 = 0[$r2]
; CHECK-NEXT:    sxwd $r3 = $r0
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sw 0[$r1] = $r3
; CHECK-NEXT:    iord $r0 = $r2, $r2
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    sw 0[$r1] = $r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 4)
entry:
  %0 = load i32, i32* %load
  %1 = tail call i64 (...) @llvm.kvx.ready(i32 %0)
  %conv = trunc i64 %1 to i32
  %conv1 = sext i32 %a to i64
  %2 = bitcast i8* %ptr to i64*
  tail call void @llvm.kvx.store.vol.i64.i32(i64 %conv1, i64* %2, i32 32, i32 %conv)
  tail call void @llvm.kvx.store.vol.i64.i32(i64 %conv1, i64* %2, i32 32, i32 %conv)
  ret i32 %conv
}

declare void @llvm.kvx.store.vol.i64.i32(i64, i64*, i32, i32)

define i32 @store_r_novol(i32 %a, i8* %ptr, i32* nocapture readonly %load) {
; CHECK-LABEL: store_r_novol:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lwz $r2 = 0[$r2]
; CHECK-NEXT:    sxwd $r3 = $r0
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sw 0[$r1] = $r3
; CHECK-NEXT:    iord $r0 = $r2, $r2
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    sw 0[$r1] = $r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 4)
entry:
  %0 = load i32, i32* %load
  %1 = tail call i64 (...) @llvm.kvx.ready(i32 %0)
  %conv = trunc i64 %1 to i32
  %conv1 = sext i32 %a to i64
  %2 = bitcast i8* %ptr to i64*
  tail call void @llvm.kvx.store.i64.i32(i64 %conv1, i64* %2, i32 32, i32 %conv)
  tail call void @llvm.kvx.store.i64.i32(i64 %conv1, i64* %2, i32 32, i32 %conv)
  ret i32 %conv
}

define void @ready_then_store(i32* nocapture readonly %addr0, i32* nocapture readonly %addr1, i32* nocapture readonly %addr2, i32* %to0, i32* %to1, i32* %to2) {
; CHECK-LABEL: ready_then_store:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lws $r0 = 0[$r0]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    lws $r1 = 0[$r1]
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    lws $r2 = 0[$r2]
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    sw 0[$r3] = $r0
; CHECK-NEXT:    iord $r6 = $r0, $r1
; CHECK-NEXT:    iord $r6 = $r2, $r0
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    sw 0[$r4] = $r1
; CHECK-NEXT:    ;; # (end cycle 6)
; CHECK-NEXT:    sw 0[$r5] = $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 7)
entry:
  %0 = load i32, i32* %addr0
  %1 = load i32, i32* %addr1
  %2 = load i32, i32* %addr2
  %3 = tail call i64 (...) @llvm.kvx.ready(i32 %0, i32 %1, i32 %2)
  %conv = trunc i64 %3 to i32
  %conv1 = sext i32 %0 to i64
  %4 = bitcast i32* %to0 to i64*
  tail call void @llvm.kvx.store.i64.i32(i64 %conv1, i64* %4, i32 32, i32 %conv)
  %conv2 = sext i32 %1 to i64
  %5 = bitcast i32* %to1 to i64*
  tail call void @llvm.kvx.store.i64.i32(i64 %conv2, i64* %5, i32 32, i32 %conv)
  %conv3 = sext i32 %2 to i64
  %6 = bitcast i32* %to2 to i64*
  tail call void @llvm.kvx.store.i64.i32(i64 %conv3, i64* %6, i32 32, i32 %conv)
  ret void
}

define void @load_then_store(i32* nocapture readonly %addr0, i32* nocapture readonly %addr1, i32* nocapture readonly %addr2, i32* nocapture %to0, i32* nocapture %to1, i32* nocapture %to2) {
; CHECK-LABEL: load_then_store:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lwz $r0 = 0[$r0]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    lwz $r1 = 0[$r1]
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    lwz $r2 = 0[$r2]
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    sw 0[$r3] = $r0
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    sw 0[$r4] = $r1
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    sw 0[$r5] = $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 5)
entry:
  %0 = load i32, i32* %addr0
  %1 = load i32, i32* %addr1
  %2 = load i32, i32* %addr2
  store i32 %0, i32* %to0
  store i32 %1, i32* %to1
  store i32 %2, i32* %to2
  ret void
}

define void @store_imm(i32* %addr, i32 %sv, i32 %ready) {
; CHECK-LABEL: store_imm:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    addd $r0 = $r0, 4
; CHECK-NEXT:    sxwd $r1 = $r1
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sw 0[$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
entry:
  %conv = sext i32 %sv to i64
  %arrayidx = getelementptr inbounds i32, i32* %addr, i64 1
  %0 = bitcast i32* %arrayidx to i64*
  tail call void @llvm.kvx.store.i64.i32(i64 %conv, i64* nonnull %0, i32 32, i32 %ready)
  ret void
}

