; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mcpu=kv3-1 -o - %s -O2 | FileCheck %s --check-prefixes=CHECK,CV1
; RUN: llc -mcpu=kv3-2 -o - %s -O2 | FileCheck %s --check-prefixes=CHECK,CV2
; RUN: clang -O2 -c -o /dev/null %s
; RUN: clang -O2 -march=kv3-2 -c -o /dev/null %s

target triple = "kvx-kalray-cos"

define <2 x i32> @ctzwp(<2 x i32> %v){
; CHECK-LABEL: ctzwp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ctzwp $r0 = $r0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <2 x i32> @llvm.kvx.ctzwp(<2 x i32> %v)
  ret <2 x i32> %0
}

declare <2 x i32> @llvm.kvx.ctzwp(<2 x i32>) #1

define <2 x i32> @clzwp(<2 x i32> %v){
; CHECK-LABEL: clzwp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    clzwp $r0 = $r0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <2 x i32> @llvm.kvx.clzwp(<2 x i32> %v)
  ret <2 x i32> %0
}

declare <2 x i32> @llvm.kvx.clzwp(<2 x i32>) #1

define <2 x i32> @clswp(<2 x i32> %v){
; CHECK-LABEL: clswp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    clswp $r0 = $r0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <2 x i32> @llvm.kvx.clswp(<2 x i32> %v)
  ret <2 x i32> %0
}

declare <2 x i32> @llvm.kvx.clswp(<2 x i32>) #1

define <2 x i32> @cbswp(<2 x i32> %v){
; CHECK-LABEL: cbswp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cbswp $r0 = $r0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <2 x i32> @llvm.kvx.cbswp(<2 x i32> %v)
  ret <2 x i32> %0
}

declare <2 x i32> @llvm.kvx.cbswp(<2 x i32>) #1

define <4 x half> @fmulhq(<4 x half> %0, <4 x half> %1) {
; CHECK-LABEL: fmulhq:
; CHECK:       # %bb.0:
; CHECK-NEXT:    fmulhq.ru.s $r0 = $r0, $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %3 = tail call <4 x half> @llvm.kvx.fmulhq(<4 x half> %0, <4 x half> %1, i32 1, i32 1)
  ret <4 x half> %3
}

declare <4 x half> @llvm.kvx.fmulhq(<4 x half>, <4 x half>, i32, i32) #1

define <8 x half> @fmulho(<8 x half> %0, <8 x half> %1) {
; CHECK-LABEL: fmulho:
; CHECK:       # %bb.0:
; CHECK-NEXT:    fmulhq.ru.s $r0 = $r0, $r2
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fmulhq.ru.s $r1 = $r1, $r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %3 = shufflevector <8 x half> %0, <8 x half> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %4 = shufflevector <8 x half> %1, <8 x half> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %5 = tail call <4 x half> @llvm.kvx.fmulhq(<4 x half> %3, <4 x half> %4, i32 1, i32 1)
  %6 = shufflevector <8 x half> %0, <8 x half> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
  %7 = shufflevector <8 x half> %1, <8 x half> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
  %8 = tail call <4 x half> @llvm.kvx.fmulhq(<4 x half> %6, <4 x half> %7, i32 1, i32 1)
  %9 = shufflevector <4 x half> %5, <4 x half> %8, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
  ret <8 x half> %9
}

define <16 x half> @fmulhx(<16 x half> %0, <16 x half> %1) {
; CHECK-LABEL: fmulhx:
; CHECK:       # %bb.0:
; CHECK-NEXT:    fmulhq.ru.s $r0 = $r0, $r4
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fmulhq.ru.s $r1 = $r1, $r5
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fmulhq.ru.s $r2 = $r2, $r6
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fmulhq.ru.s $r3 = $r3, $r7
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %3 = shufflevector <16 x half> %0, <16 x half> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %4 = shufflevector <16 x half> %1, <16 x half> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %5 = tail call <4 x half> @llvm.kvx.fmulhq(<4 x half> %3, <4 x half> %4, i32 1, i32 1)
  %6 = shufflevector <16 x half> %0, <16 x half> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
  %7 = shufflevector <16 x half> %1, <16 x half> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
  %8 = tail call <4 x half> @llvm.kvx.fmulhq(<4 x half> %6, <4 x half> %7, i32 1, i32 1)
  %9 = shufflevector <4 x half> %5, <4 x half> %8, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %10 = shufflevector <16 x half> %0, <16 x half> undef, <4 x i32> <i32 8, i32 9, i32 10, i32 11>
  %11 = shufflevector <16 x half> %1, <16 x half> undef, <4 x i32> <i32 8, i32 9, i32 10, i32 11>
  %12 = tail call <4 x half> @llvm.kvx.fmulhq(<4 x half> %10, <4 x half> %11, i32 1, i32 1)
  %13 = shufflevector <4 x half> %12, <4 x half> undef, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %14 = shufflevector <16 x half> %9, <16 x half> %13, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 16, i32 17, i32 18, i32 19, i32 undef, i32 undef, i32 undef, i32 undef>
  %15 = shufflevector <16 x half> %0, <16 x half> undef, <4 x i32> <i32 12, i32 13, i32 14, i32 15>
  %16 = shufflevector <16 x half> %1, <16 x half> undef, <4 x i32> <i32 12, i32 13, i32 14, i32 15>
  %17 = tail call <4 x half> @llvm.kvx.fmulhq(<4 x half> %15, <4 x half> %16, i32 1, i32 1)
  %18 = shufflevector <4 x half> %17, <4 x half> undef, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %19 = shufflevector <16 x half> %14, <16 x half> %18, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 16, i32 17, i32 18, i32 19>
  ret <16 x half> %19
}

define <2 x float> @fmulwp(<2 x float> %v1, <2 x float> %v2){
; CHECK-LABEL: fmulwp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fmulwp.rn $r0 = $r0, $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <2 x float> @llvm.kvx.fmulwp(<2 x float> %v1, <2 x float> %v2, i32 0, i32 0)
  ret <2 x float> %0
}

declare <2 x float> @llvm.kvx.fmulwp(<2 x float>, <2 x float>, i32, i32) #1

define <4 x float> @fmulwq(<4 x float> %v1, <4 x float> %v2){
; CHECK-LABEL: fmulwq:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fmulwq.rn $r0r1 = $r0r1, $r2r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <4 x float> @llvm.kvx.fmulwq(<4 x float> %v1, <4 x float> %v2, i32 0, i32 0)
  ret <4 x float> %0
}

declare <4 x float> @llvm.kvx.fmulwq(<4 x float>, <4 x float>, i32, i32) #1

define <8 x float> @fmulwo(<8 x float> %v1, <8 x float> %v2){
; CHECK-LABEL: fmulwo:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fmulwq.rn $r0r1 = $r0r1, $r4r5
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fmulwq.rn $r2r3 = $r2r3, $r6r7
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = shufflevector <8 x float> %v1, <8 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %1 = shufflevector <8 x float> %v2, <8 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %2 = tail call <4 x float> @llvm.kvx.fmulwq(<4 x float> %0, <4 x float> %1, i32 0, i32 0)
  %3 = shufflevector <8 x float> %v1, <8 x float> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
  %4 = shufflevector <8 x float> %v2, <8 x float> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
  %5 = tail call <4 x float> @llvm.kvx.fmulwq(<4 x float> %3, <4 x float> %4, i32 0, i32 0)
  %6 = shufflevector <4 x float> %2, <4 x float> %5, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
  ret <8 x float> %6
}

define <2 x double> @fmuldp(<2 x double> %v1, <2 x double> %v2){
; CHECK-LABEL: fmuldp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fmuld.rn $r1 = $r1, $r3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fmuld.rn $r0 = $r0, $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <2 x double> @llvm.kvx.fmuldp(<2 x double> %v1, <2 x double> %v2, i32 0, i32 0)
  ret <2 x double> %0
}

declare <2 x double> @llvm.kvx.fmuldp(<2 x double>, <2 x double>, i32, i32) #1

define <4 x double> @fmuldq(<4 x double> %v1, <4 x double> %v2){
; CHECK-LABEL: fmuldq:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fmuld.rn $r1 = $r1, $r5
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fmuld.rn $r0 = $r0, $r4
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fmuld.rn $r3 = $r3, $r7
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fmuld.rn $r2 = $r2, $r6
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = shufflevector <4 x double> %v1, <4 x double> undef, <2 x i32> <i32 0, i32 1>
  %1 = shufflevector <4 x double> %v2, <4 x double> undef, <2 x i32> <i32 0, i32 1>
  %2 = tail call <2 x double> @llvm.kvx.fmuldp(<2 x double> %0, <2 x double> %1, i32 0, i32 0)
  %3 = shufflevector <4 x double> %v1, <4 x double> undef, <2 x i32> <i32 2, i32 3>
  %4 = shufflevector <4 x double> %v2, <4 x double> undef, <2 x i32> <i32 2, i32 3>
  %5 = tail call <2 x double> @llvm.kvx.fmuldp(<2 x double> %3, <2 x double> %4, i32 0, i32 0)
  %6 = shufflevector <2 x double> %2, <2 x double> %5, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  ret <4 x double> %6
}

define <4 x float> @fmm212w(<2 x float> %v1, <2 x float> %v2){
; CHECK-LABEL: fmm212w:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fmm212w.rn $r0r1 = $r0, $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <4 x float> @llvm.kvx.fmm212w(<2 x float> %v1, <2 x float> %v2, i32 0, i32 0)
  ret <4 x float> %0
}

declare <4 x float> @llvm.kvx.fmm212w(<2 x float>, <2 x float>, i32, i32) #1

define <4 x float> @fmma212w(<2 x float> %v1, <2 x float> %v2, <4 x float> %v3){
; CHECK-LABEL: fmma212w:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fmma212w.rn $r2r3 = $r0, $r1
; CHECK-NEXT:    ;;
; CHECK-NEXT:    copyd $r0 = $r2
; CHECK-NEXT:    copyd $r1 = $r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <4 x float> @llvm.kvx.fmma212w(<2 x float> %v1, <2 x float> %v2, <4 x float> %v3, i32 0, i32 0)
  ret <4 x float> %0
}

declare <4 x float> @llvm.kvx.fmma212w(<2 x float>, <2 x float>, <4 x float>, i32, i32) #1

define <4 x float> @fmms212w(<2 x float> %v1, <2 x float> %v2, <4 x float> %v3){
; CHECK-LABEL: fmms212w:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fmms212w.rn $r2r3 = $r0, $r1
; CHECK-NEXT:    ;;
; CHECK-NEXT:    copyd $r0 = $r2
; CHECK-NEXT:    copyd $r1 = $r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <4 x float> @llvm.kvx.fmms212w(<2 x float> %v1, <2 x float> %v2, <4 x float> %v3, i32 0, i32 0)
  ret <4 x float> %0
}

declare <4 x float> @llvm.kvx.fmms212w(<2 x float>, <2 x float>, <4 x float>, i32, i32) #1

define <4 x half> @ffmahq(<4 x half> %0, <4 x half> %1, <4 x half> %2) {
; CHECK-LABEL: ffmahq:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ffmahq.ru.s $r2 = $r0, $r1
; CHECK-NEXT:    ;;
; CHECK-NEXT:    copyd $r0 = $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = tail call <4 x half> @llvm.kvx.ffmahq(<4 x half> %0, <4 x half> %1, <4 x half> %2, i32 1, i32 1)
  ret <4 x half> %4
}

declare <4 x half> @llvm.kvx.ffmahq(<4 x half>, <4 x half>, <4 x half>, i32, i32) #1

define <8 x half> @ffmaho(<8 x half> %0, <8 x half> %1, <8 x half> %2) {
; CHECK-LABEL: ffmaho:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ffmahq.ru.s $r4 = $r0, $r2
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ffmahq.ru.s $r5 = $r1, $r3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    copyd $r0 = $r4
; CHECK-NEXT:    ;;
; CHECK-NEXT:    copyd $r1 = $r5
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = shufflevector <8 x half> %0, <8 x half> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %5 = shufflevector <8 x half> %1, <8 x half> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %6 = shufflevector <8 x half> %2, <8 x half> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %7 = tail call <4 x half> @llvm.kvx.ffmahq(<4 x half> %4, <4 x half> %5, <4 x half> %6, i32 1, i32 1)
  %8 = shufflevector <8 x half> %0, <8 x half> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
  %9 = shufflevector <8 x half> %1, <8 x half> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
  %10 = shufflevector <8 x half> %2, <8 x half> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
  %11 = tail call <4 x half> @llvm.kvx.ffmahq(<4 x half> %8, <4 x half> %9, <4 x half> %10, i32 1, i32 1)
  %12 = shufflevector <4 x half> %7, <4 x half> %11, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
  ret <8 x half> %12
}

define <16 x half> @ffmahx(<16 x half> %0, <16 x half> %1, <16 x half> %2) {
; CHECK-LABEL: ffmahx:
; CHECK:       # %bb.0:
; CHECK-NEXT:    ffmahq.ru.s $r8 = $r0, $r4
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ffmahq.ru.s $r9 = $r1, $r5
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ffmahq.ru.s $r10 = $r2, $r6
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ffmahq.ru.s $r11 = $r3, $r7
; CHECK-NEXT:    ;;
; CHECK-NEXT:    copyd $r0 = $r8
; CHECK-NEXT:    ;;
; CHECK-NEXT:    copyd $r1 = $r9
; CHECK-NEXT:    ;;
; CHECK-NEXT:    copyd $r2 = $r10
; CHECK-NEXT:    ;;
; CHECK-NEXT:    copyd $r3 = $r11
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %4 = shufflevector <16 x half> %0, <16 x half> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %5 = shufflevector <16 x half> %1, <16 x half> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %6 = shufflevector <16 x half> %2, <16 x half> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %7 = tail call <4 x half> @llvm.kvx.ffmahq(<4 x half> %4, <4 x half> %5, <4 x half> %6, i32 1, i32 1)
  %8 = shufflevector <16 x half> %0, <16 x half> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
  %9 = shufflevector <16 x half> %1, <16 x half> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
  %10 = shufflevector <16 x half> %2, <16 x half> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
  %11 = tail call <4 x half> @llvm.kvx.ffmahq(<4 x half> %8, <4 x half> %9, <4 x half> %10, i32 1, i32 1)
  %12 = shufflevector <4 x half> %7, <4 x half> %11, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %13 = shufflevector <16 x half> %0, <16 x half> undef, <4 x i32> <i32 8, i32 9, i32 10, i32 11>
  %14 = shufflevector <16 x half> %1, <16 x half> undef, <4 x i32> <i32 8, i32 9, i32 10, i32 11>
  %15 = shufflevector <16 x half> %2, <16 x half> undef, <4 x i32> <i32 8, i32 9, i32 10, i32 11>
  %16 = tail call <4 x half> @llvm.kvx.ffmahq(<4 x half> %13, <4 x half> %14, <4 x half> %15, i32 1, i32 1)
  %17 = shufflevector <4 x half> %16, <4 x half> undef, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %18 = shufflevector <16 x half> %12, <16 x half> %17, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 16, i32 17, i32 18, i32 19, i32 undef, i32 undef, i32 undef, i32 undef>
  %19 = shufflevector <16 x half> %0, <16 x half> undef, <4 x i32> <i32 12, i32 13, i32 14, i32 15>
  %20 = shufflevector <16 x half> %1, <16 x half> undef, <4 x i32> <i32 12, i32 13, i32 14, i32 15>
  %21 = shufflevector <16 x half> %2, <16 x half> undef, <4 x i32> <i32 12, i32 13, i32 14, i32 15>
  %22 = tail call <4 x half> @llvm.kvx.ffmahq(<4 x half> %19, <4 x half> %20, <4 x half> %21, i32 1, i32 1)
  %23 = shufflevector <4 x half> %22, <4 x half> undef, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %24 = shufflevector <16 x half> %18, <16 x half> %23, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 16, i32 17, i32 18, i32 19>
  ret <16 x half> %24
}

define <2 x float> @ffmawp(<2 x float> %v1, <2 x float> %v2, <2 x float> %v3){
; CHECK-LABEL: ffmawp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ffmawp.rn $r2 = $r0, $r1
; CHECK-NEXT:    ;;
; CHECK-NEXT:    copyd $r0 = $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <2 x float> @llvm.kvx.ffmawp(<2 x float> %v1, <2 x float> %v2, <2 x float> %v3, i32 0, i32 0)
  ret <2 x float> %0
}

declare <2 x float> @llvm.kvx.ffmawp(<2 x float>, <2 x float>, <2 x float>, i32, i32) #1

define <4 x float> @ffmawq(<4 x float> %v1, <4 x float> %v2, <4 x float> %v3){
; CV1-LABEL: ffmawq:
; CV1:       # %bb.0: # %entry
; CV1-NEXT:    ffmawp.rn $r5 = $r1, $r3
; CV1-NEXT:    ;;
; CV1-NEXT:    ffmawp.rn $r4 = $r0, $r2
; CV1-NEXT:    ;;
; CV1-NEXT:    copyd $r0 = $r4
; CV1-NEXT:    copyd $r1 = $r5
; CV1-NEXT:    ret
; CV1-NEXT:    ;;
;
; CV2-LABEL: ffmawq:
; CV2:       # %bb.0: # %entry
; CV2-NEXT:    ffmawq.rn $r0r1 = $r2r3, $r4r5
; CV2-NEXT:    ret
; CV2-NEXT:    ;;
entry:
  %0 = tail call <4 x float> @llvm.kvx.ffmawq(<4 x float> %v1, <4 x float> %v2, <4 x float> %v3, i32 0, i32 0)
  ret <4 x float> %0
}

declare <4 x float> @llvm.kvx.ffmawq(<4 x float>, <4 x float>, <4 x float>, i32, i32) #1

define <8 x float> @ffmawo(<8 x float> %v1, <8 x float> %v2, <8 x float> %v3){
; CV1-LABEL: ffmawo:
; CV1:       # %bb.0: # %entry
; CV1-NEXT:    ffmawp.rn $r9 = $r1, $r5
; CV1-NEXT:    ;;
; CV1-NEXT:    ffmawp.rn $r8 = $r0, $r4
; CV1-NEXT:    ;;
; CV1-NEXT:    ffmawp.rn $r11 = $r3, $r7
; CV1-NEXT:    ;;
; CV1-NEXT:    ffmawp.rn $r10 = $r2, $r6
; CV1-NEXT:    ;;
; CV1-NEXT:    copyd $r0 = $r8
; CV1-NEXT:    copyd $r1 = $r9
; CV1-NEXT:    ;;
; CV1-NEXT:    copyd $r2 = $r10
; CV1-NEXT:    copyd $r3 = $r11
; CV1-NEXT:    ret
; CV1-NEXT:    ;;
;
; CV2-LABEL: ffmawo:
; CV2:       # %bb.0: # %entry
; CV2-NEXT:    ffmawq.rn $r0r1 = $r4r5, $r8r9
; CV2-NEXT:    ;;
; CV2-NEXT:    ffmawq.rn $r2r3 = $r6r7, $r10r11
; CV2-NEXT:    ret
; CV2-NEXT:    ;;
entry:
  %0 = shufflevector <8 x float> %v1, <8 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %1 = shufflevector <8 x float> %v2, <8 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %2 = shufflevector <8 x float> %v3, <8 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %3 = tail call <4 x float> @llvm.kvx.ffmawq(<4 x float> %0, <4 x float> %1, <4 x float> %2, i32 0, i32 0)
  %4 = shufflevector <8 x float> %v1, <8 x float> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
  %5 = shufflevector <8 x float> %v2, <8 x float> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
  %6 = shufflevector <8 x float> %v3, <8 x float> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
  %7 = tail call <4 x float> @llvm.kvx.ffmawq(<4 x float> %4, <4 x float> %5, <4 x float> %6, i32 0, i32 0)
  %8 = shufflevector <4 x float> %3, <4 x float> %7, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
  ret <8 x float> %8
}

define <2 x double> @ffmadp(<2 x double> %v1, <2 x double> %v2, <2 x double> %v3){
; CHECK-LABEL: ffmadp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ffmad.rn $r5 = $r1, $r3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ffmad.rn $r4 = $r0, $r2
; CHECK-NEXT:    ;;
; CHECK-NEXT:    copyd $r0 = $r4
; CHECK-NEXT:    copyd $r1 = $r5
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <2 x double> @llvm.kvx.ffmadp(<2 x double> %v1, <2 x double> %v2, <2 x double> %v3, i32 0, i32 0)
  ret <2 x double> %0
}

declare <2 x double> @llvm.kvx.ffmadp(<2 x double>, <2 x double>, <2 x double>, i32, i32) #1

define <4 x double> @ffmadq(<4 x double> %v1, <4 x double> %v2, <4 x double> %v3){
; CHECK-LABEL: ffmadq:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ffmad.rn $r9 = $r1, $r5
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ffmad.rn $r8 = $r0, $r4
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ffmad.rn $r11 = $r3, $r7
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ffmad.rn $r10 = $r2, $r6
; CHECK-NEXT:    ;;
; CHECK-NEXT:    copyd $r0 = $r8
; CHECK-NEXT:    copyd $r1 = $r9
; CHECK-NEXT:    ;;
; CHECK-NEXT:    copyd $r2 = $r10
; CHECK-NEXT:    copyd $r3 = $r11
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = shufflevector <4 x double> %v1, <4 x double> undef, <2 x i32> <i32 0, i32 1>
  %1 = shufflevector <4 x double> %v2, <4 x double> undef, <2 x i32> <i32 0, i32 1>
  %2 = shufflevector <4 x double> %v3, <4 x double> undef, <2 x i32> <i32 0, i32 1>
  %3 = tail call <2 x double> @llvm.kvx.ffmadp(<2 x double> %0, <2 x double> %1, <2 x double> %2, i32 0, i32 0)
  %4 = shufflevector <4 x double> %v1, <4 x double> undef, <2 x i32> <i32 2, i32 3>
  %5 = shufflevector <4 x double> %v2, <4 x double> undef, <2 x i32> <i32 2, i32 3>
  %6 = shufflevector <4 x double> %v3, <4 x double> undef, <2 x i32> <i32 2, i32 3>
  %7 = tail call <2 x double> @llvm.kvx.ffmadp(<2 x double> %4, <2 x double> %5, <2 x double> %6, i32 0, i32 0)
  %8 = shufflevector <2 x double> %3, <2 x double> %7, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  ret <4 x double> %8
}

define <2 x float> @ffmswp(<2 x float> %v1, <2 x float> %v2, <2 x float> %v3){
; CHECK-LABEL: ffmswp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ffmswp.rn $r2 = $r0, $r1
; CHECK-NEXT:    ;;
; CHECK-NEXT:    copyd $r0 = $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <2 x float> @llvm.kvx.ffmswp(<2 x float> %v1, <2 x float> %v2, <2 x float> %v3, i32 0, i32 0)
  ret <2 x float> %0
}

declare <2 x float> @llvm.kvx.ffmswp(<2 x float>, <2 x float>, <2 x float>, i32, i32) #1

define <4 x float> @ffmswq(<4 x float> %v1, <4 x float> %v2, <4 x float> %v3){
; CV1-LABEL: ffmswq:
; CV1:       # %bb.0: # %entry
; CV1-NEXT:    ffmswp.rn $r5 = $r1, $r3
; CV1-NEXT:    ;;
; CV1-NEXT:    ffmswp.rn $r4 = $r0, $r2
; CV1-NEXT:    ;;
; CV1-NEXT:    copyd $r0 = $r4
; CV1-NEXT:    copyd $r1 = $r5
; CV1-NEXT:    ret
; CV1-NEXT:    ;;
;
; CV2-LABEL: ffmswq:
; CV2:       # %bb.0: # %entry
; CV2-NEXT:    ffmswq.rn $r4r5 = $r2r3, $r0r1
; CV2-NEXT:    ;;
; CV2-NEXT:    copyd $r0 = $r4
; CV2-NEXT:    copyd $r1 = $r5
; CV2-NEXT:    ret
; CV2-NEXT:    ;;
entry:
  %0 = tail call <4 x float> @llvm.kvx.ffmswq(<4 x float> %v1, <4 x float> %v2, <4 x float> %v3, i32 0, i32 0)
  ret <4 x float> %0
}

declare <4 x float> @llvm.kvx.ffmswq(<4 x float>, <4 x float>, <4 x float>, i32, i32) #1

define <8 x float> @ffmswo(<8 x float> %v1, <8 x float> %v2, <8 x float> %v3){
; CV1-LABEL: ffmswo:
; CV1:       # %bb.0: # %entry
; CV1-NEXT:    ffmswp.rn $r9 = $r1, $r5
; CV1-NEXT:    ;;
; CV1-NEXT:    ffmswp.rn $r8 = $r0, $r4
; CV1-NEXT:    ;;
; CV1-NEXT:    ffmswp.rn $r11 = $r3, $r7
; CV1-NEXT:    ;;
; CV1-NEXT:    ffmswp.rn $r10 = $r2, $r6
; CV1-NEXT:    ;;
; CV1-NEXT:    copyd $r0 = $r8
; CV1-NEXT:    copyd $r1 = $r9
; CV1-NEXT:    ;;
; CV1-NEXT:    copyd $r2 = $r10
; CV1-NEXT:    copyd $r3 = $r11
; CV1-NEXT:    ret
; CV1-NEXT:    ;;
;
; CV2-LABEL: ffmswo:
; CV2:       # %bb.0: # %entry
; CV2-NEXT:    ffmswq.rn $r8r9 = $r4r5, $r0r1
; CV2-NEXT:    ;;
; CV2-NEXT:    ffmswq.rn $r10r11 = $r6r7, $r2r3
; CV2-NEXT:    ;;
; CV2-NEXT:    copyd $r0 = $r8
; CV2-NEXT:    copyd $r1 = $r9
; CV2-NEXT:    ;;
; CV2-NEXT:    copyd $r2 = $r10
; CV2-NEXT:    copyd $r3 = $r11
; CV2-NEXT:    ret
; CV2-NEXT:    ;;
entry:
  %0 = shufflevector <8 x float> %v1, <8 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %1 = shufflevector <8 x float> %v2, <8 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %2 = shufflevector <8 x float> %v3, <8 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %3 = tail call <4 x float> @llvm.kvx.ffmswq(<4 x float> %0, <4 x float> %1, <4 x float> %2, i32 0, i32 0)
  %4 = shufflevector <8 x float> %v1, <8 x float> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
  %5 = shufflevector <8 x float> %v2, <8 x float> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
  %6 = shufflevector <8 x float> %v3, <8 x float> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
  %7 = tail call <4 x float> @llvm.kvx.ffmswq(<4 x float> %4, <4 x float> %5, <4 x float> %6, i32 0, i32 0)
  %8 = shufflevector <4 x float> %3, <4 x float> %7, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
  ret <8 x float> %8
}

define <2 x double> @ffmsdp(<2 x double> %v1, <2 x double> %v2, <2 x double> %v3){
; CHECK-LABEL: ffmsdp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ffmsd.rn $r5 = $r1, $r3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ffmsd.rn $r4 = $r0, $r2
; CHECK-NEXT:    ;;
; CHECK-NEXT:    copyd $r0 = $r4
; CHECK-NEXT:    copyd $r1 = $r5
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <2 x double> @llvm.kvx.ffmsdp(<2 x double> %v1, <2 x double> %v2, <2 x double> %v3, i32 0, i32 0)
  ret <2 x double> %0
}

declare <2 x double> @llvm.kvx.ffmsdp(<2 x double>, <2 x double>, <2 x double>, i32, i32) #1

define <4 x double> @ffmsdq(<4 x double> %v1, <4 x double> %v2, <4 x double> %v3){
; CHECK-LABEL: ffmsdq:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ffmsd.rn $r9 = $r1, $r5
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ffmsd.rn $r8 = $r0, $r4
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ffmsd.rn $r11 = $r3, $r7
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ffmsd.rn $r10 = $r2, $r6
; CHECK-NEXT:    ;;
; CHECK-NEXT:    copyd $r0 = $r8
; CHECK-NEXT:    copyd $r1 = $r9
; CHECK-NEXT:    ;;
; CHECK-NEXT:    copyd $r2 = $r10
; CHECK-NEXT:    copyd $r3 = $r11
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = shufflevector <4 x double> %v1, <4 x double> undef, <2 x i32> <i32 0, i32 1>
  %1 = shufflevector <4 x double> %v2, <4 x double> undef, <2 x i32> <i32 0, i32 1>
  %2 = shufflevector <4 x double> %v3, <4 x double> undef, <2 x i32> <i32 0, i32 1>
  %3 = tail call <2 x double> @llvm.kvx.ffmsdp(<2 x double> %0, <2 x double> %1, <2 x double> %2, i32 0, i32 0)
  %4 = shufflevector <4 x double> %v1, <4 x double> undef, <2 x i32> <i32 2, i32 3>
  %5 = shufflevector <4 x double> %v2, <4 x double> undef, <2 x i32> <i32 2, i32 3>
  %6 = shufflevector <4 x double> %v3, <4 x double> undef, <2 x i32> <i32 2, i32 3>
  %7 = tail call <2 x double> @llvm.kvx.ffmsdp(<2 x double> %4, <2 x double> %5, <2 x double> %6, i32 0, i32 0)
  %8 = shufflevector <2 x double> %3, <2 x double> %7, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  ret <4 x double> %8
}

define <2 x float> @floatwp(<2 x i32> %v){
; CHECK-LABEL: floatwp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    floatwp.rn $r0 = $r0, 3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <2 x float> @llvm.kvx.floatwp(<2 x i32> %v, i64 3, i32 0, i32 0)
  ret <2 x float> %0
}

define <2 x float> @floatwp_s(<2 x i32> %v){
; CHECK-LABEL: floatwp_s:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    floatwp.rn.s $r0 = $r0, 3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <2 x float> @llvm.kvx.floatwp(<2 x i32> %v, i64 3, i32 0, i32 1)
  ret <2 x float> %0
}

declare <2 x float> @llvm.kvx.floatwp(<2 x i32>, i64, i32, i32) #1

define <4 x float> @floatwq(<4 x i32> %v){
; CHECK-LABEL: floatwq:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    floatwp.rn $r0 = $r0, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    floatwp.rn $r1 = $r1, 3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = shufflevector <4 x i32> %v, <4 x i32> undef, <2 x i32> <i32 0, i32 1>
  %1 = tail call <2 x float> @llvm.kvx.floatwp(<2 x i32> %0, i64 3, i32 0, i32 0)
  %2 = shufflevector <4 x i32> %v, <4 x i32> undef, <2 x i32> <i32 2, i32 3>
  %3 = tail call <2 x float> @llvm.kvx.floatwp(<2 x i32> %2, i64 3, i32 0, i32 0)
  %4 = shufflevector <2 x float> %1, <2 x float> %3, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  ret <4 x float> %4
}

define <4 x float> @floatwq_s(<4 x i32> %v){
; CHECK-LABEL: floatwq_s:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    floatwp.rn.s $r0 = $r0, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    floatwp.rn.s $r1 = $r1, 3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = shufflevector <4 x i32> %v, <4 x i32> undef, <2 x i32> <i32 0, i32 1>
  %1 = tail call <2 x float> @llvm.kvx.floatwp(<2 x i32> %0, i64 3, i32 0, i32 1)
  %2 = shufflevector <4 x i32> %v, <4 x i32> undef, <2 x i32> <i32 2, i32 3>
  %3 = tail call <2 x float> @llvm.kvx.floatwp(<2 x i32> %2, i64 3, i32 0, i32 1)
  %4 = shufflevector <2 x float> %1, <2 x float> %3, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  ret <4 x float> %4
}

define <8 x float> @floatwo(<8 x i32> %v){
; CHECK-LABEL: floatwo:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    floatwp.rn $r0 = $r0, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    floatwp.rn $r1 = $r1, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    floatwp.rn $r2 = $r2, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    floatwp.rn $r3 = $r3, 3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = shufflevector <8 x i32> %v, <8 x i32> undef, <2 x i32> <i32 0, i32 1>
  %1 = tail call <2 x float> @llvm.kvx.floatwp(<2 x i32> %0, i64 3, i32 0, i32 0)
  %2 = shufflevector <8 x i32> %v, <8 x i32> undef, <2 x i32> <i32 2, i32 3>
  %3 = tail call <2 x float> @llvm.kvx.floatwp(<2 x i32> %2, i64 3, i32 0, i32 0)
  %4 = shufflevector <2 x float> %1, <2 x float> %3, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 undef, i32 undef, i32 undef, i32 undef>
  %5 = shufflevector <8 x i32> %v, <8 x i32> undef, <2 x i32> <i32 4, i32 5>
  %6 = tail call <2 x float> @llvm.kvx.floatwp(<2 x i32> %5, i64 3, i32 0, i32 0)
  %7 = shufflevector <2 x float> %6, <2 x float> undef, <8 x i32> <i32 0, i32 1, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %8 = shufflevector <8 x float> %4, <8 x float> %7, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 8, i32 9, i32 undef, i32 undef>
  %9 = shufflevector <8 x i32> %v, <8 x i32> undef, <2 x i32> <i32 6, i32 7>
  %10 = tail call <2 x float> @llvm.kvx.floatwp(<2 x i32> %9, i64 3, i32 0, i32 0)
  %11 = shufflevector <2 x float> %10, <2 x float> undef, <8 x i32> <i32 0, i32 1, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %12 = shufflevector <8 x float> %8, <8 x float> %11, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 8, i32 9>
  ret <8 x float> %12
}

define <2 x double> @floatdp(<2 x i64> %v){
; CHECK-LABEL: floatdp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    floatd.rn $r0 = $r0, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    floatd.rn $r1 = $r1, 3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = extractelement <2 x i64> %v, i64 0
  %1 = tail call double @llvm.kvx.floatd(i64 %0, i64 3, i32 0, i32 0)
  %2 = insertelement <2 x double> undef, double %1, i64 0
  %3 = extractelement <2 x i64> %v, i64 1
  %4 = tail call double @llvm.kvx.floatd(i64 %3, i64 3, i32 0, i32 0)
  %5 = insertelement <2 x double> %2, double %4, i64 1
  ret <2 x double> %5
}

declare double @llvm.kvx.floatd(i64, i64, i32, i32) #1

define <4 x double> @floatdq(<4 x i64> %v){
; CHECK-LABEL: floatdq:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    floatd.rn $r0 = $r0, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    floatd.rn $r1 = $r1, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    floatd.rn $r2 = $r2, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    floatd.rn $r3 = $r3, 3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = extractelement <4 x i64> %v, i64 0
  %1 = tail call double @llvm.kvx.floatd(i64 %0, i64 3, i32 0, i32 0)
  %2 = insertelement <4 x double> undef, double %1, i64 0
  %3 = extractelement <4 x i64> %v, i64 1
  %4 = tail call double @llvm.kvx.floatd(i64 %3, i64 3, i32 0, i32 0)
  %5 = insertelement <4 x double> %2, double %4, i64 1
  %6 = extractelement <4 x i64> %v, i64 2
  %7 = tail call double @llvm.kvx.floatd(i64 %6, i64 3, i32 0, i32 0)
  %8 = insertelement <4 x double> %5, double %7, i64 2
  %9 = extractelement <4 x i64> %v, i64 3
  %10 = tail call double @llvm.kvx.floatd(i64 %9, i64 3, i32 0, i32 0)
  %11 = insertelement <4 x double> %8, double %10, i64 3
  ret <4 x double> %11
}

define <2 x float> @floatuwp(<2 x i32> %v){
; CHECK-LABEL: floatuwp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    floatuwp.rn $r0 = $r0, 3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <2 x float> @llvm.kvx.floatuwp(<2 x i32> %v, i64 3, i32 0, i32 0)
  ret <2 x float> %0
}

declare <2 x float> @llvm.kvx.floatuwp(<2 x i32>, i64, i32, i32) #1

define <4 x float> @floatuwq(<4 x i32> %v){
; CHECK-LABEL: floatuwq:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    floatuwp.rn $r0 = $r0, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    floatuwp.rn $r1 = $r1, 3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = shufflevector <4 x i32> %v, <4 x i32> undef, <2 x i32> <i32 0, i32 1>
  %1 = tail call <2 x float> @llvm.kvx.floatuwp(<2 x i32> %0, i64 3, i32 0, i32 0)
  %2 = shufflevector <4 x i32> %v, <4 x i32> undef, <2 x i32> <i32 2, i32 3>
  %3 = tail call <2 x float> @llvm.kvx.floatuwp(<2 x i32> %2, i64 3, i32 0, i32 0)
  %4 = shufflevector <2 x float> %1, <2 x float> %3, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  ret <4 x float> %4
}

define <8 x float> @floatuwo(<8 x i32> %v){
; CHECK-LABEL: floatuwo:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    floatuwp.rn $r0 = $r0, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    floatuwp.rn $r1 = $r1, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    floatuwp.rn $r2 = $r2, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    floatuwp.rn $r3 = $r3, 3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = shufflevector <8 x i32> %v, <8 x i32> undef, <2 x i32> <i32 0, i32 1>
  %1 = tail call <2 x float> @llvm.kvx.floatuwp(<2 x i32> %0, i64 3, i32 0, i32 0)
  %2 = shufflevector <8 x i32> %v, <8 x i32> undef, <2 x i32> <i32 2, i32 3>
  %3 = tail call <2 x float> @llvm.kvx.floatuwp(<2 x i32> %2, i64 3, i32 0, i32 0)
  %4 = shufflevector <2 x float> %1, <2 x float> %3, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 undef, i32 undef, i32 undef, i32 undef>
  %5 = shufflevector <8 x i32> %v, <8 x i32> undef, <2 x i32> <i32 4, i32 5>
  %6 = tail call <2 x float> @llvm.kvx.floatuwp(<2 x i32> %5, i64 3, i32 0, i32 0)
  %7 = shufflevector <2 x float> %6, <2 x float> undef, <8 x i32> <i32 0, i32 1, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %8 = shufflevector <8 x float> %4, <8 x float> %7, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 8, i32 9, i32 undef, i32 undef>
  %9 = shufflevector <8 x i32> %v, <8 x i32> undef, <2 x i32> <i32 6, i32 7>
  %10 = tail call <2 x float> @llvm.kvx.floatuwp(<2 x i32> %9, i64 3, i32 0, i32 0)
  %11 = shufflevector <2 x float> %10, <2 x float> undef, <8 x i32> <i32 0, i32 1, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %12 = shufflevector <8 x float> %8, <8 x float> %11, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 8, i32 9>
  ret <8 x float> %12
}

define <2 x double> @floatudp(<2 x i64> %v){
; CHECK-LABEL: floatudp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    floatud.rn $r0 = $r0, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    floatud.rn $r1 = $r1, 3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = extractelement <2 x i64> %v, i64 0
  %1 = tail call double @llvm.kvx.floatud(i64 %0, i64 3, i32 0, i32 0)
  %2 = insertelement <2 x double> undef, double %1, i64 0
  %3 = extractelement <2 x i64> %v, i64 1
  %4 = tail call double @llvm.kvx.floatud(i64 %3, i64 3, i32 0, i32 0)
  %5 = insertelement <2 x double> %2, double %4, i64 1
  ret <2 x double> %5
}

declare double @llvm.kvx.floatud(i64, i64, i32, i32) #1

define <4 x double> @floatudq(<4 x i64> %v){
; CHECK-LABEL: floatudq:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    floatud.rn $r0 = $r0, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    floatud.rn $r1 = $r1, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    floatud.rn $r2 = $r2, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    floatud.rn $r3 = $r3, 3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = extractelement <4 x i64> %v, i64 0
  %1 = tail call double @llvm.kvx.floatud(i64 %0, i64 3, i32 0, i32 0)
  %2 = insertelement <4 x double> undef, double %1, i64 0
  %3 = extractelement <4 x i64> %v, i64 1
  %4 = tail call double @llvm.kvx.floatud(i64 %3, i64 3, i32 0, i32 0)
  %5 = insertelement <4 x double> %2, double %4, i64 1
  %6 = extractelement <4 x i64> %v, i64 2
  %7 = tail call double @llvm.kvx.floatud(i64 %6, i64 3, i32 0, i32 0)
  %8 = insertelement <4 x double> %5, double %7, i64 2
  %9 = extractelement <4 x i64> %v, i64 3
  %10 = tail call double @llvm.kvx.floatud(i64 %9, i64 3, i32 0, i32 0)
  %11 = insertelement <4 x double> %8, double %10, i64 3
  ret <4 x double> %11
}

define <2 x i32> @fixedwp(<2 x float> %v){
; CHECK-LABEL: fixedwp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fixedwp.rn $r0 = $r0, 3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <2 x i32> @llvm.kvx.fixedwp(<2 x float> %v, i64 3, i32 0, i32 0)
  ret <2 x i32> %0
}

define <2 x i32> @fixedwp_s(<2 x float> %v){
; CHECK-LABEL: fixedwp_s:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fixedwp.rn.s $r0 = $r0, 3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <2 x i32> @llvm.kvx.fixedwp(<2 x float> %v, i64 3, i32 0, i32 1)
  ret <2 x i32> %0
}

declare <2 x i32> @llvm.kvx.fixedwp(<2 x float>, i64, i32, i32) #1

define <4 x i32> @fixedwq(<4 x float> %v){
; CHECK-LABEL: fixedwq:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fixedwp.rn $r0 = $r0, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fixedwp.rn $r1 = $r1, 3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = shufflevector <4 x float> %v, <4 x float> undef, <2 x i32> <i32 0, i32 1>
  %1 = tail call <2 x i32> @llvm.kvx.fixedwp(<2 x float> %0, i64 3, i32 0, i32 0)
  %2 = shufflevector <4 x float> %v, <4 x float> undef, <2 x i32> <i32 2, i32 3>
  %3 = tail call <2 x i32> @llvm.kvx.fixedwp(<2 x float> %2, i64 3, i32 0, i32 0)
  %4 = shufflevector <2 x i32> %1, <2 x i32> %3, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  ret <4 x i32> %4
}

define <4 x i32> @fixedwq_s(<4 x float> %v){
; CHECK-LABEL: fixedwq_s:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fixedwp.rn.s $r0 = $r0, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fixedwp.rn.s $r1 = $r1, 3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = shufflevector <4 x float> %v, <4 x float> undef, <2 x i32> <i32 0, i32 1>
  %1 = tail call <2 x i32> @llvm.kvx.fixedwp(<2 x float> %0, i64 3, i32 0, i32 1)
  %2 = shufflevector <4 x float> %v, <4 x float> undef, <2 x i32> <i32 2, i32 3>
  %3 = tail call <2 x i32> @llvm.kvx.fixedwp(<2 x float> %2, i64 3, i32 0, i32 1)
  %4 = shufflevector <2 x i32> %1, <2 x i32> %3, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  ret <4 x i32> %4
}

define <8 x i32> @fixedwo(<8 x float> %v){
; CHECK-LABEL: fixedwo:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fixedwp.rn $r0 = $r0, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fixedwp.rn $r1 = $r1, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fixedwp.rn $r2 = $r2, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fixedwp.rn $r3 = $r3, 3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = shufflevector <8 x float> %v, <8 x float> undef, <2 x i32> <i32 0, i32 1>
  %1 = tail call <2 x i32> @llvm.kvx.fixedwp(<2 x float> %0, i64 3, i32 0, i32 0)
  %2 = shufflevector <8 x float> %v, <8 x float> undef, <2 x i32> <i32 2, i32 3>
  %3 = tail call <2 x i32> @llvm.kvx.fixedwp(<2 x float> %2, i64 3, i32 0, i32 0)
  %4 = shufflevector <2 x i32> %1, <2 x i32> %3, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 undef, i32 undef, i32 undef, i32 undef>
  %5 = shufflevector <8 x float> %v, <8 x float> undef, <2 x i32> <i32 4, i32 5>
  %6 = tail call <2 x i32> @llvm.kvx.fixedwp(<2 x float> %5, i64 3, i32 0, i32 0)
  %7 = shufflevector <2 x i32> %6, <2 x i32> undef, <8 x i32> <i32 0, i32 1, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %8 = shufflevector <8 x i32> %4, <8 x i32> %7, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 8, i32 9, i32 undef, i32 undef>
  %9 = shufflevector <8 x float> %v, <8 x float> undef, <2 x i32> <i32 6, i32 7>
  %10 = tail call <2 x i32> @llvm.kvx.fixedwp(<2 x float> %9, i64 3, i32 0, i32 0)
  %11 = shufflevector <2 x i32> %10, <2 x i32> undef, <8 x i32> <i32 0, i32 1, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %12 = shufflevector <8 x i32> %8, <8 x i32> %11, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 8, i32 9>
  ret <8 x i32> %12
}

define <2 x double> @fixeddp(<2 x i64> %v){
; CHECK-LABEL: fixeddp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fixedd.rn $r0 = $r0, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fixedd.rn $r1 = $r1, 3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = bitcast <2 x i64> %v to <2 x double>
  %1 = extractelement <2 x double> %0, i64 0
  %2 = tail call i64 @llvm.kvx.fixedd(double %1, i64 3, i32 0, i32 0)
  %3 = insertelement <2 x i64> undef, i64 %2, i64 0
  %4 = extractelement <2 x double> %0, i64 1
  %5 = tail call i64 @llvm.kvx.fixedd(double %4, i64 3, i32 0, i32 0)
  %6 = insertelement <2 x i64> %3, i64 %5, i64 1
  %7 = bitcast <2 x i64> %6 to <2 x double>
  ret <2 x double> %7
}

declare i64 @llvm.kvx.fixedd(double, i64, i32, i32) #1

define <4 x double> @fixeddq(<4 x i64> %v){
; CHECK-LABEL: fixeddq:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fixedd.rn $r0 = $r0, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fixedd.rn $r1 = $r1, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fixedd.rn $r2 = $r2, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fixedd.rn $r3 = $r3, 3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = bitcast <4 x i64> %v to <4 x double>
  %1 = extractelement <4 x double> %0, i64 0
  %2 = tail call i64 @llvm.kvx.fixedd(double %1, i64 3, i32 0, i32 0)
  %3 = insertelement <4 x i64> undef, i64 %2, i64 0
  %4 = extractelement <4 x double> %0, i64 1
  %5 = tail call i64 @llvm.kvx.fixedd(double %4, i64 3, i32 0, i32 0)
  %6 = insertelement <4 x i64> %3, i64 %5, i64 1
  %7 = extractelement <4 x double> %0, i64 2
  %8 = tail call i64 @llvm.kvx.fixedd(double %7, i64 3, i32 0, i32 0)
  %9 = insertelement <4 x i64> %6, i64 %8, i64 2
  %10 = extractelement <4 x double> %0, i64 3
  %11 = tail call i64 @llvm.kvx.fixedd(double %10, i64 3, i32 0, i32 0)
  %12 = insertelement <4 x i64> %9, i64 %11, i64 3
  %13 = bitcast <4 x i64> %12 to <4 x double>
  ret <4 x double> %13
}

define <2 x i32> @fixeduwp(<2 x float> %v){
; CHECK-LABEL: fixeduwp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fixeduwp.rn $r0 = $r0, 3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <2 x i32> @llvm.kvx.fixeduwp(<2 x float> %v, i64 3, i32 0, i32 0)
  ret <2 x i32> %0
}

declare <2 x i32> @llvm.kvx.fixeduwp(<2 x float>, i64, i32, i32) #1

define <4 x i32> @fixeduwq(<4 x float> %v){
; CHECK-LABEL: fixeduwq:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fixeduwp.rn $r0 = $r0, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fixeduwp.rn $r1 = $r1, 3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = shufflevector <4 x float> %v, <4 x float> undef, <2 x i32> <i32 0, i32 1>
  %1 = tail call <2 x i32> @llvm.kvx.fixeduwp(<2 x float> %0, i64 3, i32 0, i32 0)
  %2 = shufflevector <4 x float> %v, <4 x float> undef, <2 x i32> <i32 2, i32 3>
  %3 = tail call <2 x i32> @llvm.kvx.fixeduwp(<2 x float> %2, i64 3, i32 0, i32 0)
  %4 = shufflevector <2 x i32> %1, <2 x i32> %3, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  ret <4 x i32> %4
}

define <8 x i32> @fixeduwo(<8 x float> %v){
; CHECK-LABEL: fixeduwo:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fixeduwp.rn $r0 = $r0, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fixeduwp.rn $r1 = $r1, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fixeduwp.rn $r2 = $r2, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fixeduwp.rn $r3 = $r3, 3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = shufflevector <8 x float> %v, <8 x float> undef, <2 x i32> <i32 0, i32 1>
  %1 = tail call <2 x i32> @llvm.kvx.fixeduwp(<2 x float> %0, i64 3, i32 0, i32 0)
  %2 = shufflevector <8 x float> %v, <8 x float> undef, <2 x i32> <i32 2, i32 3>
  %3 = tail call <2 x i32> @llvm.kvx.fixeduwp(<2 x float> %2, i64 3, i32 0, i32 0)
  %4 = shufflevector <2 x i32> %1, <2 x i32> %3, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 undef, i32 undef, i32 undef, i32 undef>
  %5 = shufflevector <8 x float> %v, <8 x float> undef, <2 x i32> <i32 4, i32 5>
  %6 = tail call <2 x i32> @llvm.kvx.fixeduwp(<2 x float> %5, i64 3, i32 0, i32 0)
  %7 = shufflevector <2 x i32> %6, <2 x i32> undef, <8 x i32> <i32 0, i32 1, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %8 = shufflevector <8 x i32> %4, <8 x i32> %7, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 8, i32 9, i32 undef, i32 undef>
  %9 = shufflevector <8 x float> %v, <8 x float> undef, <2 x i32> <i32 6, i32 7>
  %10 = tail call <2 x i32> @llvm.kvx.fixeduwp(<2 x float> %9, i64 3, i32 0, i32 0)
  %11 = shufflevector <2 x i32> %10, <2 x i32> undef, <8 x i32> <i32 0, i32 1, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %12 = shufflevector <8 x i32> %8, <8 x i32> %11, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 8, i32 9>
  ret <8 x i32> %12
}

define <2 x double> @fixedudp(<2 x i64> %v){
; CHECK-LABEL: fixedudp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fixedud.rn $r0 = $r0, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fixedud.rn $r1 = $r1, 3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = bitcast <2 x i64> %v to <2 x double>
  %1 = extractelement <2 x double> %0, i64 0
  %2 = tail call i64 @llvm.kvx.fixedud(double %1, i64 3, i32 0, i32 0)
  %3 = insertelement <2 x i64> undef, i64 %2, i64 0
  %4 = extractelement <2 x double> %0, i64 1
  %5 = tail call i64 @llvm.kvx.fixedud(double %4, i64 3, i32 0, i32 0)
  %6 = insertelement <2 x i64> %3, i64 %5, i64 1
  %7 = bitcast <2 x i64> %6 to <2 x double>
  ret <2 x double> %7
}

declare i64 @llvm.kvx.fixedud(double, i64, i32, i32) #1

define <4 x double> @fixedudq(<4 x i64> %v){
; CHECK-LABEL: fixedudq:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fixedud.rn $r0 = $r0, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fixedud.rn $r1 = $r1, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fixedud.rn $r2 = $r2, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fixedud.rn $r3 = $r3, 3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = bitcast <4 x i64> %v to <4 x double>
  %1 = extractelement <4 x double> %0, i64 0
  %2 = tail call i64 @llvm.kvx.fixedud(double %1, i64 3, i32 0, i32 0)
  %3 = insertelement <4 x i64> undef, i64 %2, i64 0
  %4 = extractelement <4 x double> %0, i64 1
  %5 = tail call i64 @llvm.kvx.fixedud(double %4, i64 3, i32 0, i32 0)
  %6 = insertelement <4 x i64> %3, i64 %5, i64 1
  %7 = extractelement <4 x double> %0, i64 2
  %8 = tail call i64 @llvm.kvx.fixedud(double %7, i64 3, i32 0, i32 0)
  %9 = insertelement <4 x i64> %6, i64 %8, i64 2
  %10 = extractelement <4 x double> %0, i64 3
  %11 = tail call i64 @llvm.kvx.fixedud(double %10, i64 3, i32 0, i32 0)
  %12 = insertelement <4 x i64> %9, i64 %11, i64 3
  %13 = bitcast <4 x i64> %12 to <4 x double>
  ret <4 x double> %13
}

define <4 x half> @fnarrowwhq(<4 x float> %0) {
; CHECK-LABEL: fnarrowwhq:
; CHECK:       # %bb.0:
; CHECK-NEXT:    fnarrowwhq.ru.s $r0 = $r0r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %2 = tail call <4 x half> @llvm.kvx.fnarrowwhq(<4 x float> %0, i32 1, i32 1)
  ret <4 x half> %2
}

declare <4 x half> @llvm.kvx.fnarrowwhq(<4 x float>, i32, i32) #1

define <8 x half> @fnarrowwho(<8 x float> %0) {
; CHECK-LABEL: fnarrowwho:
; CHECK:       # %bb.0:
; CHECK-NEXT:    fnarrowwhq.ru.s $r0 = $r0r1
; CHECK-NEXT:    fnarrowwhq.ru.s $r1 = $r2r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %2 = shufflevector <8 x float> %0, <8 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %3 = tail call <4 x half> @llvm.kvx.fnarrowwhq(<4 x float> %2, i32 1, i32 1)
  %4 = shufflevector <8 x float> %0, <8 x float> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
  %5 = tail call <4 x half> @llvm.kvx.fnarrowwhq(<4 x float> %4, i32 1, i32 1)
  %6 = shufflevector <4 x half> %3, <4 x half> %5, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
  ret <8 x half> %6
}

define <2 x float> @fnarrowdwp(<2 x double> %0) {
; CHECK-LABEL: fnarrowdwp:
; CHECK:       # %bb.0:
; CHECK-NEXT:    fnarrowdwp.ru.s $r0 = $r0r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %2 = tail call <2 x float> @llvm.kvx.fnarrowdwp(<2 x double> %0, i32 1, i32 1)
  ret <2 x float> %2
}

declare <2 x float> @llvm.kvx.fnarrowdwp(<2 x double>, i32, i32) #1

define <4 x float> @fnarrowdwq(<4 x double> %0) {
; CHECK-LABEL: fnarrowdwq:
; CHECK:       # %bb.0:
; CHECK-NEXT:    fnarrowdwp.ru.s $r0 = $r0r1
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fnarrowdwp.ru.s $r1 = $r2r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %2 = shufflevector <4 x double> %0, <4 x double> undef, <2 x i32> <i32 0, i32 1>
  %3 = tail call <2 x float> @llvm.kvx.fnarrowdwp(<2 x double> %2, i32 1, i32 1)
  %4 = shufflevector <4 x double> %0, <4 x double> undef, <2 x i32> <i32 2, i32 3>
  %5 = tail call <2 x float> @llvm.kvx.fnarrowdwp(<2 x double> %4, i32 1, i32 1)
  %6 = shufflevector <2 x float> %3, <2 x float> %5, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  ret <4 x float> %6
}
