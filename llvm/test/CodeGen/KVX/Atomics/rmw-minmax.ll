; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mcpu=kv3-1 -o - %s | FileCheck %s --check-prefixes=CV1
; RUN: llc -mcpu=kv3-2 -o - %s | FileCheck %s --check-prefixes=CV2
; RUN: clang -c -o /dev/null %s
; RUN: clang -march=kv3-2 -c -o /dev/null %s

target triple = "kvx-kalray-cos"

define i32 @f32min(ptr %src, i32 %b) {
; CV1-LABEL: f32min:
; CV1:       # %bb.0:
; CV1-NEXT:    fence
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    lwz $r3 = 0[$r0]
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:  .LBB0_1: # %atomicrmw.start
; CV1-NEXT:    # =>This Inner Loop Header: Depth=1
; CV1-NEXT:    minw $r2 = $r3, $r1
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    copyq $r4r5 = $r2, $r3
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:    acswapw 0[$r0] = $r4r5
; CV1-NEXT:    ;; # (end cycle 2)
; CV1-NEXT:    lwz.u $r2 = 0[$r0]
; CV1-NEXT:    ;; # (end cycle 3)
; CV1-NEXT:    cmoved.even $r4 ? $r3 = $r2
; CV1-NEXT:    cb.even $r4 ? .LBB0_1
; CV1-NEXT:    ;; # (end cycle 6)
; CV1-NEXT:  # %bb.2: # %atomicrmw.end
; CV1-NEXT:    fence
; CV1-NEXT:    copyd $r0 = $r3
; CV1-NEXT:    ret
; CV1-NEXT:    ;; # (end cycle 0)
;
; CV2-LABEL: f32min:
; CV2:       # %bb.0:
; CV2-NEXT:    fence
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    lwz $r3 = 0[$r0]
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:  .LBB0_1: # %atomicrmw.start
; CV2-NEXT:    # =>This Inner Loop Header: Depth=1
; CV2-NEXT:    minw $r2 = $r3, $r1
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    acswapw $r2, [$r0] = $r2r3
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:    lwz.u $r4 = 0[$r0]
; CV2-NEXT:    ;; # (end cycle 2)
; CV2-NEXT:    cb.even $r2 ? .LBB0_1
; CV2-NEXT:    cmoved.even $r2 ? $r3 = $r4
; CV2-NEXT:    ;; # (end cycle 5)
; CV2-NEXT:  # %bb.2: # %atomicrmw.end
; CV2-NEXT:    fence
; CV2-NEXT:    copyd $r0 = $r3
; CV2-NEXT:    ret
; CV2-NEXT:    ;; # (end cycle 0)
  %res = atomicrmw min ptr %src, i32 %b seq_cst
  ret i32 %res
}

define i32 @f32max(ptr %src, i32 %b) {
; CV1-LABEL: f32max:
; CV1:       # %bb.0:
; CV1-NEXT:    fence
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    lwz $r3 = 0[$r0]
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:  .LBB1_1: # %atomicrmw.start
; CV1-NEXT:    # =>This Inner Loop Header: Depth=1
; CV1-NEXT:    maxw $r2 = $r3, $r1
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    copyq $r4r5 = $r2, $r3
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:    acswapw 0[$r0] = $r4r5
; CV1-NEXT:    ;; # (end cycle 2)
; CV1-NEXT:    lwz.u $r2 = 0[$r0]
; CV1-NEXT:    ;; # (end cycle 3)
; CV1-NEXT:    cmoved.even $r4 ? $r3 = $r2
; CV1-NEXT:    cb.even $r4 ? .LBB1_1
; CV1-NEXT:    ;; # (end cycle 6)
; CV1-NEXT:  # %bb.2: # %atomicrmw.end
; CV1-NEXT:    fence
; CV1-NEXT:    copyd $r0 = $r3
; CV1-NEXT:    ret
; CV1-NEXT:    ;; # (end cycle 0)
;
; CV2-LABEL: f32max:
; CV2:       # %bb.0:
; CV2-NEXT:    fence
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    lwz $r3 = 0[$r0]
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:  .LBB1_1: # %atomicrmw.start
; CV2-NEXT:    # =>This Inner Loop Header: Depth=1
; CV2-NEXT:    maxw $r2 = $r3, $r1
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    acswapw $r2, [$r0] = $r2r3
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:    lwz.u $r4 = 0[$r0]
; CV2-NEXT:    ;; # (end cycle 2)
; CV2-NEXT:    cb.even $r2 ? .LBB1_1
; CV2-NEXT:    cmoved.even $r2 ? $r3 = $r4
; CV2-NEXT:    ;; # (end cycle 5)
; CV2-NEXT:  # %bb.2: # %atomicrmw.end
; CV2-NEXT:    fence
; CV2-NEXT:    copyd $r0 = $r3
; CV2-NEXT:    ret
; CV2-NEXT:    ;; # (end cycle 0)
  %res = atomicrmw max ptr %src, i32 %b seq_cst
  ret i32 %res
}

define i32 @f32umin(ptr %src, i32 %b) {
; CV1-LABEL: f32umin:
; CV1:       # %bb.0:
; CV1-NEXT:    fence
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    lwz $r3 = 0[$r0]
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:  .LBB2_1: # %atomicrmw.start
; CV1-NEXT:    # =>This Inner Loop Header: Depth=1
; CV1-NEXT:    minuw $r2 = $r3, $r1
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    copyq $r4r5 = $r2, $r3
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:    acswapw 0[$r0] = $r4r5
; CV1-NEXT:    ;; # (end cycle 2)
; CV1-NEXT:    lwz.u $r2 = 0[$r0]
; CV1-NEXT:    ;; # (end cycle 3)
; CV1-NEXT:    cmoved.even $r4 ? $r3 = $r2
; CV1-NEXT:    cb.even $r4 ? .LBB2_1
; CV1-NEXT:    ;; # (end cycle 6)
; CV1-NEXT:  # %bb.2: # %atomicrmw.end
; CV1-NEXT:    fence
; CV1-NEXT:    copyd $r0 = $r3
; CV1-NEXT:    ret
; CV1-NEXT:    ;; # (end cycle 0)
;
; CV2-LABEL: f32umin:
; CV2:       # %bb.0:
; CV2-NEXT:    fence
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    lwz $r3 = 0[$r0]
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:  .LBB2_1: # %atomicrmw.start
; CV2-NEXT:    # =>This Inner Loop Header: Depth=1
; CV2-NEXT:    minuw $r2 = $r3, $r1
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    acswapw $r2, [$r0] = $r2r3
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:    lwz.u $r4 = 0[$r0]
; CV2-NEXT:    ;; # (end cycle 2)
; CV2-NEXT:    cb.even $r2 ? .LBB2_1
; CV2-NEXT:    cmoved.even $r2 ? $r3 = $r4
; CV2-NEXT:    ;; # (end cycle 5)
; CV2-NEXT:  # %bb.2: # %atomicrmw.end
; CV2-NEXT:    fence
; CV2-NEXT:    copyd $r0 = $r3
; CV2-NEXT:    ret
; CV2-NEXT:    ;; # (end cycle 0)
  %res = atomicrmw umin ptr %src, i32 %b seq_cst
  ret i32 %res
}

define i32 @f32umax(ptr %src, i32 %b) {
; CV1-LABEL: f32umax:
; CV1:       # %bb.0:
; CV1-NEXT:    fence
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    lwz $r3 = 0[$r0]
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:  .LBB3_1: # %atomicrmw.start
; CV1-NEXT:    # =>This Inner Loop Header: Depth=1
; CV1-NEXT:    maxuw $r2 = $r3, $r1
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    copyq $r4r5 = $r2, $r3
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:    acswapw 0[$r0] = $r4r5
; CV1-NEXT:    ;; # (end cycle 2)
; CV1-NEXT:    lwz.u $r2 = 0[$r0]
; CV1-NEXT:    ;; # (end cycle 3)
; CV1-NEXT:    cmoved.even $r4 ? $r3 = $r2
; CV1-NEXT:    cb.even $r4 ? .LBB3_1
; CV1-NEXT:    ;; # (end cycle 6)
; CV1-NEXT:  # %bb.2: # %atomicrmw.end
; CV1-NEXT:    fence
; CV1-NEXT:    copyd $r0 = $r3
; CV1-NEXT:    ret
; CV1-NEXT:    ;; # (end cycle 0)
;
; CV2-LABEL: f32umax:
; CV2:       # %bb.0:
; CV2-NEXT:    fence
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    lwz $r3 = 0[$r0]
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:  .LBB3_1: # %atomicrmw.start
; CV2-NEXT:    # =>This Inner Loop Header: Depth=1
; CV2-NEXT:    maxuw $r2 = $r3, $r1
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    acswapw $r2, [$r0] = $r2r3
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:    lwz.u $r4 = 0[$r0]
; CV2-NEXT:    ;; # (end cycle 2)
; CV2-NEXT:    cb.even $r2 ? .LBB3_1
; CV2-NEXT:    cmoved.even $r2 ? $r3 = $r4
; CV2-NEXT:    ;; # (end cycle 5)
; CV2-NEXT:  # %bb.2: # %atomicrmw.end
; CV2-NEXT:    fence
; CV2-NEXT:    copyd $r0 = $r3
; CV2-NEXT:    ret
; CV2-NEXT:    ;; # (end cycle 0)
  %res = atomicrmw umax ptr %src, i32 %b seq_cst
  ret i32 %res
}

define i64 @f64min(ptr %src, i64 %b) {
; CV1-LABEL: f64min:
; CV1:       # %bb.0:
; CV1-NEXT:    fence
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    ld $r3 = 0[$r0]
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:  .LBB4_1: # %atomicrmw.start
; CV1-NEXT:    # =>This Inner Loop Header: Depth=1
; CV1-NEXT:    mind $r2 = $r3, $r1
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    copyq $r4r5 = $r2, $r3
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:    acswapd 0[$r0] = $r4r5
; CV1-NEXT:    ;; # (end cycle 2)
; CV1-NEXT:    ld.u $r2 = 0[$r0]
; CV1-NEXT:    ;; # (end cycle 3)
; CV1-NEXT:    cmoved.even $r4 ? $r3 = $r2
; CV1-NEXT:    cb.even $r4 ? .LBB4_1
; CV1-NEXT:    ;; # (end cycle 6)
; CV1-NEXT:  # %bb.2: # %atomicrmw.end
; CV1-NEXT:    fence
; CV1-NEXT:    copyd $r0 = $r3
; CV1-NEXT:    ret
; CV1-NEXT:    ;; # (end cycle 0)
;
; CV2-LABEL: f64min:
; CV2:       # %bb.0:
; CV2-NEXT:    fence
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    ld $r3 = 0[$r0]
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:  .LBB4_1: # %atomicrmw.start
; CV2-NEXT:    # =>This Inner Loop Header: Depth=1
; CV2-NEXT:    mind $r2 = $r3, $r1
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    acswapd $r2, [$r0] = $r2r3
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:    ld.u $r4 = 0[$r0]
; CV2-NEXT:    ;; # (end cycle 2)
; CV2-NEXT:    cb.even $r2 ? .LBB4_1
; CV2-NEXT:    cmoved.even $r2 ? $r3 = $r4
; CV2-NEXT:    ;; # (end cycle 5)
; CV2-NEXT:  # %bb.2: # %atomicrmw.end
; CV2-NEXT:    fence
; CV2-NEXT:    copyd $r0 = $r3
; CV2-NEXT:    ret
; CV2-NEXT:    ;; # (end cycle 0)
  %res = atomicrmw min ptr %src, i64 %b seq_cst
  ret i64 %res
}

define i64 @f64max(ptr %src, i64 %b) {
; CV1-LABEL: f64max:
; CV1:       # %bb.0:
; CV1-NEXT:    fence
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    ld $r3 = 0[$r0]
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:  .LBB5_1: # %atomicrmw.start
; CV1-NEXT:    # =>This Inner Loop Header: Depth=1
; CV1-NEXT:    maxd $r2 = $r3, $r1
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    copyq $r4r5 = $r2, $r3
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:    acswapd 0[$r0] = $r4r5
; CV1-NEXT:    ;; # (end cycle 2)
; CV1-NEXT:    ld.u $r2 = 0[$r0]
; CV1-NEXT:    ;; # (end cycle 3)
; CV1-NEXT:    cmoved.even $r4 ? $r3 = $r2
; CV1-NEXT:    cb.even $r4 ? .LBB5_1
; CV1-NEXT:    ;; # (end cycle 6)
; CV1-NEXT:  # %bb.2: # %atomicrmw.end
; CV1-NEXT:    fence
; CV1-NEXT:    copyd $r0 = $r3
; CV1-NEXT:    ret
; CV1-NEXT:    ;; # (end cycle 0)
;
; CV2-LABEL: f64max:
; CV2:       # %bb.0:
; CV2-NEXT:    fence
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    ld $r3 = 0[$r0]
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:  .LBB5_1: # %atomicrmw.start
; CV2-NEXT:    # =>This Inner Loop Header: Depth=1
; CV2-NEXT:    maxd $r2 = $r3, $r1
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    acswapd $r2, [$r0] = $r2r3
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:    ld.u $r4 = 0[$r0]
; CV2-NEXT:    ;; # (end cycle 2)
; CV2-NEXT:    cb.even $r2 ? .LBB5_1
; CV2-NEXT:    cmoved.even $r2 ? $r3 = $r4
; CV2-NEXT:    ;; # (end cycle 5)
; CV2-NEXT:  # %bb.2: # %atomicrmw.end
; CV2-NEXT:    fence
; CV2-NEXT:    copyd $r0 = $r3
; CV2-NEXT:    ret
; CV2-NEXT:    ;; # (end cycle 0)
  %res = atomicrmw max ptr %src, i64 %b seq_cst
  ret i64 %res
}

define i64 @f64umin(ptr %src, i64 %b) {
; CV1-LABEL: f64umin:
; CV1:       # %bb.0:
; CV1-NEXT:    fence
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    ld $r3 = 0[$r0]
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:  .LBB6_1: # %atomicrmw.start
; CV1-NEXT:    # =>This Inner Loop Header: Depth=1
; CV1-NEXT:    minud $r2 = $r3, $r1
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    copyq $r4r5 = $r2, $r3
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:    acswapd 0[$r0] = $r4r5
; CV1-NEXT:    ;; # (end cycle 2)
; CV1-NEXT:    ld.u $r2 = 0[$r0]
; CV1-NEXT:    ;; # (end cycle 3)
; CV1-NEXT:    cmoved.even $r4 ? $r3 = $r2
; CV1-NEXT:    cb.even $r4 ? .LBB6_1
; CV1-NEXT:    ;; # (end cycle 6)
; CV1-NEXT:  # %bb.2: # %atomicrmw.end
; CV1-NEXT:    fence
; CV1-NEXT:    copyd $r0 = $r3
; CV1-NEXT:    ret
; CV1-NEXT:    ;; # (end cycle 0)
;
; CV2-LABEL: f64umin:
; CV2:       # %bb.0:
; CV2-NEXT:    fence
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    ld $r3 = 0[$r0]
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:  .LBB6_1: # %atomicrmw.start
; CV2-NEXT:    # =>This Inner Loop Header: Depth=1
; CV2-NEXT:    minud $r2 = $r3, $r1
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    acswapd $r2, [$r0] = $r2r3
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:    ld.u $r4 = 0[$r0]
; CV2-NEXT:    ;; # (end cycle 2)
; CV2-NEXT:    cb.even $r2 ? .LBB6_1
; CV2-NEXT:    cmoved.even $r2 ? $r3 = $r4
; CV2-NEXT:    ;; # (end cycle 5)
; CV2-NEXT:  # %bb.2: # %atomicrmw.end
; CV2-NEXT:    fence
; CV2-NEXT:    copyd $r0 = $r3
; CV2-NEXT:    ret
; CV2-NEXT:    ;; # (end cycle 0)
  %res = atomicrmw umin ptr %src, i64 %b seq_cst
  ret i64 %res
}

define i64 @f64umax(ptr %src, i64 %b) {
; CV1-LABEL: f64umax:
; CV1:       # %bb.0:
; CV1-NEXT:    fence
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    ld $r3 = 0[$r0]
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:  .LBB7_1: # %atomicrmw.start
; CV1-NEXT:    # =>This Inner Loop Header: Depth=1
; CV1-NEXT:    maxud $r2 = $r3, $r1
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    copyq $r4r5 = $r2, $r3
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:    acswapd 0[$r0] = $r4r5
; CV1-NEXT:    ;; # (end cycle 2)
; CV1-NEXT:    ld.u $r2 = 0[$r0]
; CV1-NEXT:    ;; # (end cycle 3)
; CV1-NEXT:    cmoved.even $r4 ? $r3 = $r2
; CV1-NEXT:    cb.even $r4 ? .LBB7_1
; CV1-NEXT:    ;; # (end cycle 6)
; CV1-NEXT:  # %bb.2: # %atomicrmw.end
; CV1-NEXT:    fence
; CV1-NEXT:    copyd $r0 = $r3
; CV1-NEXT:    ret
; CV1-NEXT:    ;; # (end cycle 0)
;
; CV2-LABEL: f64umax:
; CV2:       # %bb.0:
; CV2-NEXT:    fence
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    ld $r3 = 0[$r0]
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:  .LBB7_1: # %atomicrmw.start
; CV2-NEXT:    # =>This Inner Loop Header: Depth=1
; CV2-NEXT:    maxud $r2 = $r3, $r1
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    acswapd $r2, [$r0] = $r2r3
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:    ld.u $r4 = 0[$r0]
; CV2-NEXT:    ;; # (end cycle 2)
; CV2-NEXT:    cb.even $r2 ? .LBB7_1
; CV2-NEXT:    cmoved.even $r2 ? $r3 = $r4
; CV2-NEXT:    ;; # (end cycle 5)
; CV2-NEXT:  # %bb.2: # %atomicrmw.end
; CV2-NEXT:    fence
; CV2-NEXT:    copyd $r0 = $r3
; CV2-NEXT:    ret
; CV2-NEXT:    ;; # (end cycle 0)
  %res = atomicrmw umax ptr %src, i64 %b seq_cst
  ret i64 %res
}
