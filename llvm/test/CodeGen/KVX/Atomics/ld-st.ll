; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mcpu=kv3-1 -o - %s -O2 | FileCheck %s --check-prefixes=CHECK
; RUN: llc -mcpu=kv3-2 -o - %s -O2 | FileCheck %s --check-prefixes=CHECK
; RUN: clang -O2 -march=kv3-1 -c -o /dev/null %s
; RUN: clang -O2 -march=kv3-2 -c -o /dev/null %s

target triple = "kvx-kalray-cos"

define i8 @atomic_load_signed_char__ATOMIC_RELAXED(ptr %p) {
; CHECK-LABEL: atomic_load_signed_char__ATOMIC_RELAXED:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lbz.u $r0 = 0[$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %0 = load atomic i8, ptr %p monotonic, align 1
  ret i8 %0
}

define void @atomic_store_signed_char__ATOMIC_RELAXED(ptr %p, i8 %v) {
; CHECK-LABEL: atomic_store_signed_char__ATOMIC_RELAXED:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sb 0[$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  store atomic i8 %v, ptr %p monotonic, align 1
  ret void
}

define i8 @atomic_load_signed_char__ATOMIC_CONSUME(ptr %p) {
; CHECK-LABEL: atomic_load_signed_char__ATOMIC_CONSUME:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lbz.u $r0 = 0[$r0]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    fence
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
entry:
  %0 = load atomic i8, ptr %p acquire, align 1
  ret i8 %0
}

define i8 @atomic_load_signed_char__ATOMIC_ACQUIRE(ptr %p) {
; CHECK-LABEL: atomic_load_signed_char__ATOMIC_ACQUIRE:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lbz.u $r0 = 0[$r0]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    fence
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
entry:
  %0 = load atomic i8, ptr %p acquire, align 1
  ret i8 %0
}

define void @atomic_store_signed_char__ATOMIC_RELEASE(ptr %p, i8 %v) {
; CHECK-LABEL: atomic_store_signed_char__ATOMIC_RELEASE:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fence
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sb 0[$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
entry:
  store atomic i8 %v, ptr %p release, align 1
  ret void
}

define i8 @atomic_load_signed_char__ATOMIC_SEQ_CST(ptr %p) {
; CHECK-LABEL: atomic_load_signed_char__ATOMIC_SEQ_CST:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fence
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    lbz.u $r0 = 0[$r0]
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    fence
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 2)
entry:
  %0 = load atomic i8, ptr %p seq_cst, align 1
  ret i8 %0
}

define void @atomic_store_signed_char__ATOMIC_SEQ_CST(ptr %p, i8 %v) {
; CHECK-LABEL: atomic_store_signed_char__ATOMIC_SEQ_CST:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fence
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sb 0[$r0] = $r1
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    fence
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 2)
entry:
  store atomic i8 %v, ptr %p seq_cst, align 1
  ret void
}

define i8 @atomic_load_unsigned_char__ATOMIC_RELAXED(ptr %p) {
; CHECK-LABEL: atomic_load_unsigned_char__ATOMIC_RELAXED:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lbz.u $r0 = 0[$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %0 = load atomic i8, ptr %p monotonic, align 1
  ret i8 %0
}

define void @atomic_store_unsigned_char__ATOMIC_RELAXED(ptr %p, i8 %v) {
; CHECK-LABEL: atomic_store_unsigned_char__ATOMIC_RELAXED:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sb 0[$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  store atomic i8 %v, ptr %p monotonic, align 1
  ret void
}

define i8 @atomic_load_unsigned_char__ATOMIC_CONSUME(ptr %p) {
; CHECK-LABEL: atomic_load_unsigned_char__ATOMIC_CONSUME:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lbz.u $r0 = 0[$r0]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    fence
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
entry:
  %0 = load atomic i8, ptr %p acquire, align 1
  ret i8 %0
}

define i8 @atomic_load_unsigned_char__ATOMIC_ACQUIRE(ptr %p) {
; CHECK-LABEL: atomic_load_unsigned_char__ATOMIC_ACQUIRE:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lbz.u $r0 = 0[$r0]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    fence
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
entry:
  %0 = load atomic i8, ptr %p acquire, align 1
  ret i8 %0
}

define void @atomic_store_unsigned_char__ATOMIC_RELEASE(ptr %p, i8 %v) {
; CHECK-LABEL: atomic_store_unsigned_char__ATOMIC_RELEASE:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fence
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sb 0[$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
entry:
  store atomic i8 %v, ptr %p release, align 1
  ret void
}

define i8 @atomic_load_unsigned_char__ATOMIC_SEQ_CST(ptr %p) {
; CHECK-LABEL: atomic_load_unsigned_char__ATOMIC_SEQ_CST:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fence
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    lbz.u $r0 = 0[$r0]
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    fence
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 2)
entry:
  %0 = load atomic i8, ptr %p seq_cst, align 1
  ret i8 %0
}

define void @atomic_store_unsigned_char__ATOMIC_SEQ_CST(ptr %p, i8 %v) {
; CHECK-LABEL: atomic_store_unsigned_char__ATOMIC_SEQ_CST:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fence
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sb 0[$r0] = $r1
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    fence
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 2)
entry:
  store atomic i8 %v, ptr %p seq_cst, align 1
  ret void
}

define i16 @atomic_load_signed_short__ATOMIC_RELAXED(ptr %p) {
; CHECK-LABEL: atomic_load_signed_short__ATOMIC_RELAXED:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lhz.u $r0 = 0[$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %0 = load atomic i16, ptr %p monotonic, align 2
  ret i16 %0
}

define void @atomic_store_signed_short__ATOMIC_RELAXED(ptr %p, i16 %v) {
; CHECK-LABEL: atomic_store_signed_short__ATOMIC_RELAXED:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sh 0[$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  store atomic i16 %v, ptr %p monotonic, align 2
  ret void
}

define i16 @atomic_load_signed_short__ATOMIC_CONSUME(ptr %p) {
; CHECK-LABEL: atomic_load_signed_short__ATOMIC_CONSUME:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lhz.u $r0 = 0[$r0]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    fence
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
entry:
  %0 = load atomic i16, ptr %p acquire, align 2
  ret i16 %0
}

define i16 @atomic_load_signed_short__ATOMIC_ACQUIRE(ptr %p) {
; CHECK-LABEL: atomic_load_signed_short__ATOMIC_ACQUIRE:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lhz.u $r0 = 0[$r0]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    fence
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
entry:
  %0 = load atomic i16, ptr %p acquire, align 2
  ret i16 %0
}

define void @atomic_store_signed_short__ATOMIC_RELEASE(ptr %p, i16 %v) {
; CHECK-LABEL: atomic_store_signed_short__ATOMIC_RELEASE:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fence
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sh 0[$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
entry:
  store atomic i16 %v, ptr %p release, align 2
  ret void
}

define i16 @atomic_load_signed_short__ATOMIC_SEQ_CST(ptr %p) {
; CHECK-LABEL: atomic_load_signed_short__ATOMIC_SEQ_CST:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fence
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    lhz.u $r0 = 0[$r0]
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    fence
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 2)
entry:
  %0 = load atomic i16, ptr %p seq_cst, align 2
  ret i16 %0
}

define void @atomic_store_signed_short__ATOMIC_SEQ_CST(ptr %p, i16 %v) {
; CHECK-LABEL: atomic_store_signed_short__ATOMIC_SEQ_CST:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fence
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sh 0[$r0] = $r1
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    fence
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 2)
entry:
  store atomic i16 %v, ptr %p seq_cst, align 2
  ret void
}

define i16 @atomic_load_unsigned_short__ATOMIC_RELAXED(ptr %p) {
; CHECK-LABEL: atomic_load_unsigned_short__ATOMIC_RELAXED:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lhz.u $r0 = 0[$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %0 = load atomic i16, ptr %p monotonic, align 2
  ret i16 %0
}

define void @atomic_store_unsigned_short__ATOMIC_RELAXED(ptr %p, i16 %v) {
; CHECK-LABEL: atomic_store_unsigned_short__ATOMIC_RELAXED:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sh 0[$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  store atomic i16 %v, ptr %p monotonic, align 2
  ret void
}

define i16 @atomic_load_unsigned_short__ATOMIC_CONSUME(ptr %p) {
; CHECK-LABEL: atomic_load_unsigned_short__ATOMIC_CONSUME:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lhz.u $r0 = 0[$r0]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    fence
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
entry:
  %0 = load atomic i16, ptr %p acquire, align 2
  ret i16 %0
}

define i16 @atomic_load_unsigned_short__ATOMIC_ACQUIRE(ptr %p) {
; CHECK-LABEL: atomic_load_unsigned_short__ATOMIC_ACQUIRE:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lhz.u $r0 = 0[$r0]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    fence
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
entry:
  %0 = load atomic i16, ptr %p acquire, align 2
  ret i16 %0
}

define void @atomic_store_unsigned_short__ATOMIC_RELEASE(ptr %p, i16 %v) {
; CHECK-LABEL: atomic_store_unsigned_short__ATOMIC_RELEASE:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fence
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sh 0[$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
entry:
  store atomic i16 %v, ptr %p release, align 2
  ret void
}

define i16 @atomic_load_unsigned_short__ATOMIC_SEQ_CST(ptr %p) {
; CHECK-LABEL: atomic_load_unsigned_short__ATOMIC_SEQ_CST:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fence
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    lhz.u $r0 = 0[$r0]
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    fence
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 2)
entry:
  %0 = load atomic i16, ptr %p seq_cst, align 2
  ret i16 %0
}

define void @atomic_store_unsigned_short__ATOMIC_SEQ_CST(ptr %p, i16 %v) {
; CHECK-LABEL: atomic_store_unsigned_short__ATOMIC_SEQ_CST:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fence
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sh 0[$r0] = $r1
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    fence
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 2)
entry:
  store atomic i16 %v, ptr %p seq_cst, align 2
  ret void
}

define i32 @atomic_load_signed_int__ATOMIC_RELAXED(ptr %p) {
; CHECK-LABEL: atomic_load_signed_int__ATOMIC_RELAXED:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lwz.u $r0 = 0[$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %0 = load atomic i32, ptr %p monotonic, align 4
  ret i32 %0
}

define void @atomic_store_signed_int__ATOMIC_RELAXED(ptr %p, i32 %v) {
; CHECK-LABEL: atomic_store_signed_int__ATOMIC_RELAXED:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sw 0[$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  store atomic i32 %v, ptr %p monotonic, align 4
  ret void
}

define i32 @atomic_load_signed_int__ATOMIC_CONSUME(ptr %p) {
; CHECK-LABEL: atomic_load_signed_int__ATOMIC_CONSUME:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lwz.u $r0 = 0[$r0]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    fence
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
entry:
  %0 = load atomic i32, ptr %p acquire, align 4
  ret i32 %0
}

define i32 @atomic_load_signed_int__ATOMIC_ACQUIRE(ptr %p) {
; CHECK-LABEL: atomic_load_signed_int__ATOMIC_ACQUIRE:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lwz.u $r0 = 0[$r0]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    fence
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
entry:
  %0 = load atomic i32, ptr %p acquire, align 4
  ret i32 %0
}

define void @atomic_store_signed_int__ATOMIC_RELEASE(ptr %p, i32 %v) {
; CHECK-LABEL: atomic_store_signed_int__ATOMIC_RELEASE:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fence
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sw 0[$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
entry:
  store atomic i32 %v, ptr %p release, align 4
  ret void
}

define i32 @atomic_load_signed_int__ATOMIC_SEQ_CST(ptr %p) {
; CHECK-LABEL: atomic_load_signed_int__ATOMIC_SEQ_CST:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fence
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    lwz.u $r0 = 0[$r0]
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    fence
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 2)
entry:
  %0 = load atomic i32, ptr %p seq_cst, align 4
  ret i32 %0
}

define void @atomic_store_signed_int__ATOMIC_SEQ_CST(ptr %p, i32 %v) {
; CHECK-LABEL: atomic_store_signed_int__ATOMIC_SEQ_CST:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fence
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sw 0[$r0] = $r1
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    fence
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 2)
entry:
  store atomic i32 %v, ptr %p seq_cst, align 4
  ret void
}

define i32 @atomic_load_unsigned_int__ATOMIC_RELAXED(ptr %p) {
; CHECK-LABEL: atomic_load_unsigned_int__ATOMIC_RELAXED:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lwz.u $r0 = 0[$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %0 = load atomic i32, ptr %p monotonic, align 4
  ret i32 %0
}

define void @atomic_store_unsigned_int__ATOMIC_RELAXED(ptr %p, i32 %v) {
; CHECK-LABEL: atomic_store_unsigned_int__ATOMIC_RELAXED:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sw 0[$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  store atomic i32 %v, ptr %p monotonic, align 4
  ret void
}

define i32 @atomic_load_unsigned_int__ATOMIC_CONSUME(ptr %p) {
; CHECK-LABEL: atomic_load_unsigned_int__ATOMIC_CONSUME:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lwz.u $r0 = 0[$r0]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    fence
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
entry:
  %0 = load atomic i32, ptr %p acquire, align 4
  ret i32 %0
}

define i32 @atomic_load_unsigned_int__ATOMIC_ACQUIRE(ptr %p) {
; CHECK-LABEL: atomic_load_unsigned_int__ATOMIC_ACQUIRE:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lwz.u $r0 = 0[$r0]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    fence
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
entry:
  %0 = load atomic i32, ptr %p acquire, align 4
  ret i32 %0
}

define void @atomic_store_unsigned_int__ATOMIC_RELEASE(ptr %p, i32 %v) {
; CHECK-LABEL: atomic_store_unsigned_int__ATOMIC_RELEASE:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fence
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sw 0[$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
entry:
  store atomic i32 %v, ptr %p release, align 4
  ret void
}

define i32 @atomic_load_unsigned_int__ATOMIC_SEQ_CST(ptr %p) {
; CHECK-LABEL: atomic_load_unsigned_int__ATOMIC_SEQ_CST:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fence
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    lwz.u $r0 = 0[$r0]
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    fence
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 2)
entry:
  %0 = load atomic i32, ptr %p seq_cst, align 4
  ret i32 %0
}

define void @atomic_store_unsigned_int__ATOMIC_SEQ_CST(ptr %p, i32 %v) {
; CHECK-LABEL: atomic_store_unsigned_int__ATOMIC_SEQ_CST:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fence
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sw 0[$r0] = $r1
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    fence
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 2)
entry:
  store atomic i32 %v, ptr %p seq_cst, align 4
  ret void
}

define i64 @atomic_load_signed_long__ATOMIC_RELAXED(ptr %p) {
; CHECK-LABEL: atomic_load_signed_long__ATOMIC_RELAXED:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ld.u $r0 = 0[$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %0 = load atomic i64, ptr %p monotonic, align 8
  ret i64 %0
}

define void @atomic_store_signed_long__ATOMIC_RELAXED(ptr %p, i64 %v) {
; CHECK-LABEL: atomic_store_signed_long__ATOMIC_RELAXED:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sd 0[$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  store atomic i64 %v, ptr %p monotonic, align 8
  ret void
}

define i64 @atomic_load_signed_long__ATOMIC_CONSUME(ptr %p) {
; CHECK-LABEL: atomic_load_signed_long__ATOMIC_CONSUME:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ld.u $r0 = 0[$r0]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    fence
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
entry:
  %0 = load atomic i64, ptr %p acquire, align 8
  ret i64 %0
}

define i64 @atomic_load_signed_long__ATOMIC_ACQUIRE(ptr %p) {
; CHECK-LABEL: atomic_load_signed_long__ATOMIC_ACQUIRE:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ld.u $r0 = 0[$r0]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    fence
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
entry:
  %0 = load atomic i64, ptr %p acquire, align 8
  ret i64 %0
}

define void @atomic_store_signed_long__ATOMIC_RELEASE(ptr %p, i64 %v) {
; CHECK-LABEL: atomic_store_signed_long__ATOMIC_RELEASE:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fence
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 0[$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
entry:
  store atomic i64 %v, ptr %p release, align 8
  ret void
}

define i64 @atomic_load_signed_long__ATOMIC_SEQ_CST(ptr %p) {
; CHECK-LABEL: atomic_load_signed_long__ATOMIC_SEQ_CST:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fence
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    ld.u $r0 = 0[$r0]
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    fence
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 2)
entry:
  %0 = load atomic i64, ptr %p seq_cst, align 8
  ret i64 %0
}

define void @atomic_store_signed_long__ATOMIC_SEQ_CST(ptr %p, i64 %v) {
; CHECK-LABEL: atomic_store_signed_long__ATOMIC_SEQ_CST:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fence
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 0[$r0] = $r1
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    fence
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 2)
entry:
  store atomic i64 %v, ptr %p seq_cst, align 8
  ret void
}

define i64 @atomic_load_unsigned_long__ATOMIC_RELAXED(ptr %p) {
; CHECK-LABEL: atomic_load_unsigned_long__ATOMIC_RELAXED:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ld.u $r0 = 0[$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %0 = load atomic i64, ptr %p monotonic, align 8
  ret i64 %0
}

define void @atomic_store_unsigned_long__ATOMIC_RELAXED(ptr %p, i64 %v) {
; CHECK-LABEL: atomic_store_unsigned_long__ATOMIC_RELAXED:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sd 0[$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  store atomic i64 %v, ptr %p monotonic, align 8
  ret void
}

define i64 @atomic_load_unsigned_long__ATOMIC_CONSUME(ptr %p) {
; CHECK-LABEL: atomic_load_unsigned_long__ATOMIC_CONSUME:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ld.u $r0 = 0[$r0]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    fence
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
entry:
  %0 = load atomic i64, ptr %p acquire, align 8
  ret i64 %0
}

define i64 @atomic_load_unsigned_long__ATOMIC_ACQUIRE(ptr %p) {
; CHECK-LABEL: atomic_load_unsigned_long__ATOMIC_ACQUIRE:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ld.u $r0 = 0[$r0]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    fence
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
entry:
  %0 = load atomic i64, ptr %p acquire, align 8
  ret i64 %0
}

define void @atomic_store_unsigned_long__ATOMIC_RELEASE(ptr %p, i64 %v) {
; CHECK-LABEL: atomic_store_unsigned_long__ATOMIC_RELEASE:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fence
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 0[$r0] = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 1)
entry:
  store atomic i64 %v, ptr %p release, align 8
  ret void
}

define i64 @atomic_load_unsigned_long__ATOMIC_SEQ_CST(ptr %p) {
; CHECK-LABEL: atomic_load_unsigned_long__ATOMIC_SEQ_CST:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fence
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    ld.u $r0 = 0[$r0]
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    fence
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 2)
entry:
  %0 = load atomic i64, ptr %p seq_cst, align 8
  ret i64 %0
}

define void @atomic_store_unsigned_long__ATOMIC_SEQ_CST(ptr %p, i64 %v) {
; CHECK-LABEL: atomic_store_unsigned_long__ATOMIC_SEQ_CST:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fence
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 0[$r0] = $r1
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    fence
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 2)
entry:
  store atomic i64 %v, ptr %p seq_cst, align 8
  ret void
}

