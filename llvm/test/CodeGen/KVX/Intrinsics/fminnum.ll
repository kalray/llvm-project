; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -o - %s | FileCheck %s --check-prefixes=CHECK,CV1
; RUN: llc -mcpu=kv3-2 -o - %s | FileCheck %s --check-prefixes=CHECK,CV2
; RUN: clang -c -o /dev/null %s
; RUN: clang -march=kv3-2 -c -o /dev/null %s

target triple = "kvx-kalray-cos"

define half @fminh(half %a, half %b) {
; CV1-LABEL: fminh:
; CV1:       # %bb.0:
; CV1-NEXT:    sllhqs $r2 = $r0, 1
; CV1-NEXT:    fcompnhq.olt $r3 = $r1, $r0
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    compnhq.gtu $r2 = $r2, 0xf800
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:    iorw $r2 = $r3, $r2
; CV1-NEXT:    ;; # (end cycle 2)
; CV1-NEXT:    cmovehq.odd $r2 ? $r0 = $r1
; CV1-NEXT:    ret
; CV1-NEXT:    ;; # (end cycle 3)
;
; CV2-LABEL: fminh:
; CV2:       # %bb.0:
; CV2-NEXT:    fminhq $r0 = $r0, $r1
; CV2-NEXT:    ret
; CV2-NEXT:    ;; # (end cycle 0)
  %res = call half @llvm.minnum.f16(half %a, half %b)
  ret half %res
}

define half @fminh_fast(half %a, half %b) {
; CHECK-LABEL: fminh_fast:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fminhq $r0 = $r0, $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %0 = tail call fast half @llvm.minnum.f16(half %a, half %b)
  ret half %0
}

declare half @llvm.minnum.f16(half, half)


define float @fminw(float %a, float %b) {
; CV1-LABEL: fminw:
; CV1:       # %bb.0:
; CV1-NEXT:    sllw $r2 = $r0, 1
; CV1-NEXT:    fcompw.olt $r3 = $r1, $r0
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    compw.gtu $r2 = $r2, 0xff000000
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:    iorw $r2 = $r3, $r2
; CV1-NEXT:    ;; # (end cycle 2)
; CV1-NEXT:    cmoved.odd $r2 ? $r0 = $r1
; CV1-NEXT:    ret
; CV1-NEXT:    ;; # (end cycle 3)
;
; CV2-LABEL: fminw:
; CV2:       # %bb.0:
; CV2-NEXT:    fminw $r0 = $r0, $r1
; CV2-NEXT:    ret
; CV2-NEXT:    ;; # (end cycle 0)
  %res = call float @llvm.minnum.f32(float %a, float %b)
  ret float %res
}

define dso_local float @fminw_fast(float %a, float %b) {
; CHECK-LABEL: fminw_fast:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fminw $r0 = $r0, $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %0 = tail call fast float @llvm.minnum.f32(float %a, float %b)
  ret float %0
}

declare float @llvm.minnum.f32(float, float)

define double @fmind(double %a, double %b) {
; CV1-LABEL: fmind:
; CV1:       # %bb.0:
; CV1-NEXT:    slld $r2 = $r0, 1
; CV1-NEXT:    fcompd.olt $r3 = $r1, $r0
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    compd.gtu $r2 = $r2, 0xffe0000000000000
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:    iord $r2 = $r3, $r2
; CV1-NEXT:    ;; # (end cycle 2)
; CV1-NEXT:    cmoved.odd $r2 ? $r0 = $r1
; CV1-NEXT:    ret
; CV1-NEXT:    ;; # (end cycle 3)
;
; CV2-LABEL: fmind:
; CV2:       # %bb.0:
; CV2-NEXT:    fmind $r0 = $r0, $r1
; CV2-NEXT:    ret
; CV2-NEXT:    ;; # (end cycle 0)
  %res = call double @llvm.minnum.f64(double %a, double %b)
  ret double %res
}

define dso_local double @fmind_fast(double %a, double %b) {
; CHECK-LABEL: fmind_fast:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fmind $r0 = $r0, $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 0)
entry:
  %0 = tail call fast double @llvm.minnum.f64(double %a, double %b)
  ret double %0
}

declare double @llvm.minnum.f64(double, double)
