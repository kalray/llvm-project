; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mcpu=kv3-1 -o - %s -O2 | FileCheck %s --check-prefixes=CHECK,CV1
; RUN: llc -mcpu=kv3-2 -o - %s -O2 | FileCheck %s --check-prefixes=CHECK,CV2
target triple = "kvx-kalray-cos"

define i32 @acswapw(i32* %p, i32 %a, i32 %b){
; CV1-LABEL: acswapw:
; CV1:       # %bb.0: # %entry
; CV1-NEXT:    copyd $r2 = $r1
; CV1-NEXT:    copyd $r3 = $r2
; CV1-NEXT:    ;;
; CV1-NEXT:    acswapw 0[$r0] = $r2r3
; CV1-NEXT:    ;;
; CV1-NEXT:    copyd $r0 = $r2
; CV1-NEXT:    ret
; CV1-NEXT:    ;;
;
; CV2-LABEL: acswapw:
; CV2:       # %bb.0: # %entry
; CV2-NEXT:    copyd $r2 = $r1
; CV2-NEXT:    copyd $r3 = $r2
; CV2-NEXT:    ;;
; CV2-NEXT:    acswapw.v $r0, [$r0] = $r2r3
; CV2-NEXT:    ret
; CV2-NEXT:    ;;
entry:
  %0 = bitcast i32* %p to i8*
  %1 = tail call i32 @llvm.kvx.acswapw(i8* %0, i32 %a, i32 %b)
  ret i32 %1
}

declare i32 @llvm.kvx.acswapw(i8*, i32, i32) #1

define i64 @acswapd(i32* %p, i64 %a, i64 %b){
; CV1-LABEL: acswapd:
; CV1:       # %bb.0: # %entry
; CV1-NEXT:    copyd $r2 = $r1
; CV1-NEXT:    copyd $r3 = $r2
; CV1-NEXT:    ;;
; CV1-NEXT:    acswapd 0[$r0] = $r2r3
; CV1-NEXT:    ;;
; CV1-NEXT:    copyd $r0 = $r2
; CV1-NEXT:    ret
; CV1-NEXT:    ;;
;
; CV2-LABEL: acswapd:
; CV2:       # %bb.0: # %entry
; CV2-NEXT:    copyd $r2 = $r1
; CV2-NEXT:    copyd $r3 = $r2
; CV2-NEXT:    ;;
; CV2-NEXT:    acswapd.v $r0, [$r0] = $r2r3
; CV2-NEXT:    ret
; CV2-NEXT:    ;;
entry:
  %0 = bitcast i32* %p to i8*
  %1 = tail call i64 @llvm.kvx.acswapd(i8* %0, i64 %a, i64 %b)
  ret i64 %1
}

declare i64 @llvm.kvx.acswapd(i8*, i64, i64) #1

define i64 @aladdd(i8* readonly %p, i64 %v){
; CHECK-LABEL: aladdd:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    aladdd 0[$r0] = $r1
; CHECK-NEXT:    ;;
; CHECK-NEXT:    copyd $r0 = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call i64 @llvm.kvx.aladdd(i8* %p, i64 %v)
  ret i64 %0
}

declare i64 @llvm.kvx.aladdd(i8*, i64) #3

define i32 @aladdw(i8* readonly %p, i32 %v){
; CHECK-LABEL: aladdw:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    aladdw 0[$r0] = $r1
; CHECK-NEXT:    ;;
; CHECK-NEXT:    copyd $r0 = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call i32 @llvm.kvx.aladdw(i8* %p, i32 %v)
  ret i32 %0
}

declare i32 @llvm.kvx.aladdw(i8*, i32) #3

define i64 @alclrd(i8* readonly %p){
; CHECK-LABEL: alclrd:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    alclrd $r0 = 0[$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call i64 @llvm.kvx.alclrd(i8* %p)
  ret i64 %0
}

declare i64 @llvm.kvx.alclrd(i8*) #3

define i32 @alclrw(i8* readonly %p){
; CHECK-LABEL: alclrw:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    alclrw $r0 = 0[$r0]
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call i32 @llvm.kvx.alclrw(i8* %p)
  ret i32 %0
}

declare i32 @llvm.kvx.alclrw(i8*) #3
