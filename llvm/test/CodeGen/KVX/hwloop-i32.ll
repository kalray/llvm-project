; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc --disable-kvx-hwloops=false < %s | FileCheck %s
target triple = "kvx-kalray-cos"
; Check that we generate hardware loop instructions.

; Case 1 : Loop with a constant number of iterations.

@a = common global [10 x i32] zeroinitializer, align 4
define i32 @hwloop1() nounwind {
; CHECK-LABEL: hwloop1:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    make $r0 = 0
; CHECK-NEXT:    make $r2 = 10
; CHECK-NEXT:    make $r1 = a
; CHECK-NEXT:    ;;
; CHECK-NEXT:    loopdo $r2, .LBB0_2
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_1: # %for.body
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    sw 0[$r1] = $r0
; CHECK-NEXT:    addw $r0 = $r0, 1
; CHECK-NEXT:    addd $r1 = $r1, 4
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_2: # Block address taken
; CHECK-NEXT:    # %for.end
; CHECK-NEXT:    make $r0 = 0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  br label %for.body
for.body:
  %i.01 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %arrayidx = getelementptr inbounds [10 x i32], [10 x i32]* @a, i32 0, i32 %i.01
  store i32 %i.01, i32* %arrayidx, align 4
  %inc = add nsw i32 %i.01, 1
  %exitcond = icmp eq i32 %inc, 10
  br i1 %exitcond, label %for.end, label %for.body
for.end:
  ret i32 0
}

; Case 2 : Loop with a run-time number of iterations.

define i32 @hwloop2(i32 %n, i32* nocapture %b) nounwind {
; CHECK-LABEL: hwloop2:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    copyd $r2 = $r0
; CHECK-NEXT:    make $r0 = 0
; CHECK-NEXT:    ;;
; CHECK-NEXT:    cb.wlez $r2 ? .LBB1_3
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.1: # %for.body.preheader
; CHECK-NEXT:    make $r0 = 0
; CHECK-NEXT:    cb.dlez $r2 ? .LBB1_2
; CHECK-NEXT:    ;;
; CHECK-NEXT:    loopdo $r2, .LBB1_3
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB1_2: # %for.body
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    lwz $r2 = 0[$r1]
; CHECK-NEXT:    addd $r1 = $r1, 4
; CHECK-NEXT:    ;;
; CHECK-NEXT:    addw $r0 = $r2, $r0
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB1_3: # Block address taken
; CHECK-NEXT:    # %for.end
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %cmp1 = icmp sgt i32 %n, 0
  br i1 %cmp1, label %for.body.preheader, label %for.end

for.body.preheader:
  br label %for.body

for.body:
  %a.03 = phi i32 [ %add, %for.body ], [ 0, %for.body.preheader ]
  %i.02 = phi i32 [ %inc, %for.body ], [ 0, %for.body.preheader ]
  %arrayidx = getelementptr inbounds i32, i32* %b, i32 %i.02
  %0 = load i32, i32* %arrayidx, align 4
  %add = add nsw i32 %0, %a.03
  %inc = add nsw i32 %i.02, 1
  %exitcond = icmp eq i32 %inc, %n
  br i1 %exitcond, label %for.end.loopexit, label %for.body

for.end.loopexit:
  br label %for.end

for.end:
  %a.0.lcssa = phi i32 [ 0, %entry ], [ %add, %for.end.loopexit ]
  ret i32 %a.0.lcssa
}

; Case 3 : Induction variable increment more than 1.

define i32 @hwloop3(i32 %n, i32* nocapture %b) nounwind {
; CHECK-LABEL: hwloop3:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    make $r2 = 0
; CHECK-NEXT:    cb.wlez $r0 ? .LBB2_3
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.1: # %for.body.preheader
; CHECK-NEXT:    make $r2 = 0
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB2_2: # %for.body
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    lwz $r3 = 0[$r1]
; CHECK-NEXT:    addw $r0 = $r0, -4
; CHECK-NEXT:    addd $r1 = $r1, 16
; CHECK-NEXT:    ;;
; CHECK-NEXT:    addw $r2 = $r3, $r2
; CHECK-NEXT:    cb.wnez $r0 ? .LBB2_2
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB2_3: # %for.end
; CHECK-NEXT:    copyd $r0 = $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %cmp1 = icmp sgt i32 %n, 0
  br i1 %cmp1, label %for.body.preheader, label %for.end

for.body.preheader:
  br label %for.body

for.body:
  %a.03 = phi i32 [ %add, %for.body ], [ 0, %for.body.preheader ]
  %i.02 = phi i32 [ %inc, %for.body ], [ 0, %for.body.preheader ]
  %arrayidx = getelementptr inbounds i32, i32* %b, i32 %i.02
  %0 = load i32, i32* %arrayidx, align 4
  %add = add nsw i32 %0, %a.03
  %inc = add nsw i32 %i.02, 4
  %exitcond = icmp eq i32 %inc, %n
  br i1 %exitcond, label %for.end.loopexit, label %for.body

for.end.loopexit:
  br label %for.end

for.end:
  %a.0.lcssa = phi i32 [ 0, %entry ], [ %add, %for.end.loopexit ]
  ret i32 %a.0.lcssa
}

; Case 4 : Loop exit compare uses register instead of immediate value.

define i32 @hwloop4(i32 %n, i32* nocapture %b) nounwind {
; CHECK-LABEL: hwloop4:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cb.wlez $r0 ? .LBB3_3
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.1: # %for.body.preheader
; CHECK-NEXT:    make $r2 = 0
; CHECK-NEXT:    cb.dlez $r0 ? .LBB3_2
; CHECK-NEXT:    ;;
; CHECK-NEXT:    loopdo $r0, .LBB3_3
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB3_2: # %for.body
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    sw 0[$r1] = $r2
; CHECK-NEXT:    addw $r2 = $r2, 1
; CHECK-NEXT:    addd $r1 = $r1, 4
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB3_3: # Block address taken
; CHECK-NEXT:    # %for.end
; CHECK-NEXT:    make $r0 = 0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %cmp1 = icmp sgt i32 %n, 0
  br i1 %cmp1, label %for.body.preheader, label %for.end

for.body.preheader:
  br label %for.body

for.body:
  %i.02 = phi i32 [ %inc, %for.body ], [ 0, %for.body.preheader ]
  %arrayidx = getelementptr inbounds i32, i32* %b, i32 %i.02
  store i32 %i.02, i32* %arrayidx, align 4
  %inc = add nsw i32 %i.02, 1
  %exitcond = icmp eq i32 %inc, %n
  br i1 %exitcond, label %for.end.loopexit, label %for.body

for.end.loopexit:
  br label %for.end

for.end:
  ret i32 0
}

; Case 5: After LSR, the initial value is 100 and the iv decrements to 0.

define void @hwloop5(i32* nocapture %a, i32* nocapture %res) nounwind {
; CHECK-LABEL: hwloop5:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    make $r2 = 100
; CHECK-NEXT:    ;;
; CHECK-NEXT:    make $r2 = 100
; CHECK-NEXT:    ;;
; CHECK-NEXT:    loopdo $r2, .LBB4_2
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB4_1: # %for.body
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    lwz $r2 = 0[$r0]
; CHECK-NEXT:    addd $r0 = $r0, 4
; CHECK-NEXT:    ;;
; CHECK-NEXT:    mulw $r2 = $r2, $r2
; CHECK-NEXT:    ;;
; CHECK-NEXT:    sw 0[$r1] = $r2
; CHECK-NEXT:    addd $r1 = $r1, 4
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB4_2: # Block address taken
; CHECK-NEXT:    # %for.end
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  br label %for.body

for.body:
  %i.03 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %arrayidx = getelementptr inbounds i32, i32* %a, i32 %i.03
  %0 = load i32, i32* %arrayidx, align 4
  %mul = mul nsw i32 %0, %0
  %arrayidx2 = getelementptr inbounds i32, i32* %res, i32 %i.03
  store i32 %mul, i32* %arrayidx2, align 4
  %inc = add nsw i32 %i.03, 1
  %exitcond = icmp eq i32 %inc, 100
  br i1 %exitcond, label %for.end, label %for.body

for.end:
  ret void
}
