; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mcpu=kv3-1 -O3 -o - %s | FileCheck --check-prefix=CV1 %s
; RUN: llc -mcpu=kv3-2 -O3 -o - %s | FileCheck --check-prefix=CV2 %s
; RUN: clang -march=kv3-1 -O3 -c -o /dev/null %s
; RUN: clang -march=kv3-2 -O3 -c -o /dev/null %s

; From the c src:
; a() {
;   int b = 0;
;   __kvx_x256 c;
;   __kvx_x512 d = __builtin_kvx_xcat512(c, c);
;   for (int col;; col += 2) {
;     int e;
;     __kvx_x512 f, g;
;     __kvx_x1024 h;
;     __kvx_x256 i;
; #pragma unroll 3
;     for (; e < b; ++e)
;       f = d;
;     h = __builtin_kvx_xcat1024(f, g);
;     i = __builtin_kvx_xconvwbv(h, ".rz.sat");
;     *(__kvx_x256 *)col = i;
;   }
; }
; Replaced cv1 only xconvwbv by xmt44d

target triple = "kvx-kalray-cos"

define i32 @a() {
; CV1-LABEL: a:
; CV1:       # %bb.0:
; CV1-NEXT:    # implicit-def: $w0
; CV1-NEXT:    # implicit-def: $r2
; CV1-NEXT:    make $r0 = 0
; CV1-NEXT:    goto .LBB0_3
; CV1-NEXT:    ;;
; CV1-NEXT:  .LBB0_1: # in Loop: Header=BB0_3 Depth=1
; CV1-NEXT:    xcopyo $a2 = $a1
; CV1-NEXT:    compw.eq $r2 = $r3, 1
; CV1-NEXT:    ;;
; CV1-NEXT:    xcopyo $a3 = $a0
; CV1-NEXT:    sllw $r2 = $r2, 6
; CV1-NEXT:    ;;
; CV1-NEXT:    alignv $a1 = $a1, $a2, $r2
; CV1-NEXT:    ;;
; CV1-NEXT:    alignv $a0 = $a0, $a3, $r2
; CV1-NEXT:    ;;
; CV1-NEXT:  .LBB0_2: # in Loop: Header=BB0_3 Depth=1
; CV1-NEXT:    xmt44d $a4a5a6a7 = $a0a1a2a3
; CV1-NEXT:    ;;
; CV1-NEXT:    xso 96[$r0] = $a7
; CV1-NEXT:    ;;
; CV1-NEXT:    xso 64[$r0] = $a6
; CV1-NEXT:    ;;
; CV1-NEXT:    xso 32[$r0] = $a5
; CV1-NEXT:    ;;
; CV1-NEXT:    xso 0[$r0] = $a4
; CV1-NEXT:    addd $r0 = $r0, 2
; CV1-NEXT:    copyd $r2 = $r1
; CV1-NEXT:    ;;
; CV1-NEXT:  .LBB0_3: # =>This Loop Header: Depth=1
; CV1-NEXT:    # Child Loop BB0_5 Depth 2
; CV1-NEXT:    maxw $r1 = $r2, 0
; CV1-NEXT:    ;;
; CV1-NEXT:    sbfw $r3 = $r2, $r1
; CV1-NEXT:    ;;
; CV1-NEXT:    muluwd $r4 = $r3, 0xaaaaaaab
; CV1-NEXT:    compw.ltu $r5 = $r3, 2
; CV1-NEXT:    ;;
; CV1-NEXT:    srld $r4 = $r4, 32
; CV1-NEXT:    ;;
; CV1-NEXT:    srlw $r4 = $r4, 1
; CV1-NEXT:    ;;
; CV1-NEXT:    msbfw $r3 = $r4, 3
; CV1-NEXT:    ;;
; CV1-NEXT:    addw $r3 = $r3, 1
; CV1-NEXT:    ;;
; CV1-NEXT:    zxbd $r3 = $r3
; CV1-NEXT:    ;;
; CV1-NEXT:    muluwd $r4 = $r3, 0xaaaaaaab
; CV1-NEXT:    ;;
; CV1-NEXT:    srld $r4 = $r4, 32
; CV1-NEXT:    ;;
; CV1-NEXT:    srlw $r4 = $r4, 1
; CV1-NEXT:    ;;
; CV1-NEXT:    msbfw $r3 = $r4, 3
; CV1-NEXT:    cb.odd $r5 ? .LBB0_1
; CV1-NEXT:    ;;
; CV1-NEXT:  # %bb.4: # in Loop: Header=BB0_3 Depth=1
; CV1-NEXT:    zxbd $r3 = $r3
; CV1-NEXT:    make $r5 = 1
; CV1-NEXT:    ;;
; CV1-NEXT:    compw.eq $r4 = $r3, 1
; CV1-NEXT:    ;;
; CV1-NEXT:    cmoved.even $r4 ? $r5 = 2
; CV1-NEXT:    ;;
; CV1-NEXT:    cmoved.weqz $r3 ? $r5 = 0
; CV1-NEXT:    ;;
; CV1-NEXT:    addw $r2 = $r5, $r2
; CV1-NEXT:    ;;
; CV1-NEXT:    addw $r2 = $r2, -3
; CV1-NEXT:    ;;
; CV1-NEXT:  .LBB0_5: # Parent Loop BB0_3 Depth=1
; CV1-NEXT:    # => This Inner Loop Header: Depth=2
; CV1-NEXT:    # implicit-def: $w0
; CV1-NEXT:    addw $r2 = $r2, 3
; CV1-NEXT:    ;;
; CV1-NEXT:    compw.lt $r3 = $r2, -2
; CV1-NEXT:    ;;
; CV1-NEXT:    cb.odd $r3 ? .LBB0_5
; CV1-NEXT:    ;;
; CV1-NEXT:    goto .LBB0_2
; CV1-NEXT:    ;;
;
; CV2-LABEL: a:
; CV2:       # %bb.0:
; CV2-NEXT:    # implicit-def: $w0
; CV2-NEXT:    # implicit-def: $r2
; CV2-NEXT:    make $r0 = 0
; CV2-NEXT:    goto .LBB0_3
; CV2-NEXT:    ;;
; CV2-NEXT:  .LBB0_1: # in Loop: Header=BB0_3 Depth=1
; CV2-NEXT:    xcopyo $a3 = $a0
; CV2-NEXT:    compw.eq $r2 = $r3, 1
; CV2-NEXT:    ;;
; CV2-NEXT:    cmoved.wnez $r2 ? $r2 = 32
; CV2-NEXT:    ;;
; CV2-NEXT:    xaligno $a1 = $a0..a1, $r2
; CV2-NEXT:    ;;
; CV2-NEXT:    xaligno $a0 = $a2..a3, $r2
; CV2-NEXT:    ;;
; CV2-NEXT:  .LBB0_2: # in Loop: Header=BB0_3 Depth=1
; CV2-NEXT:    xmt44d $a4a5a6a7 = $a0a1a2a3
; CV2-NEXT:    ;;
; CV2-NEXT:    xso 96[$r0] = $a7
; CV2-NEXT:    ;;
; CV2-NEXT:    xso 64[$r0] = $a6
; CV2-NEXT:    ;;
; CV2-NEXT:    xso 32[$r0] = $a5
; CV2-NEXT:    ;;
; CV2-NEXT:    xso 0[$r0] = $a4
; CV2-NEXT:    addd $r0 = $r0, 2
; CV2-NEXT:    copyd $r2 = $r1
; CV2-NEXT:    ;;
; CV2-NEXT:  .LBB0_3: # =>This Loop Header: Depth=1
; CV2-NEXT:    # Child Loop BB0_5 Depth 2
; CV2-NEXT:    maxw $r1 = $r2, 0
; CV2-NEXT:    ;;
; CV2-NEXT:    sbfw $r3 = $r2, $r1
; CV2-NEXT:    ;;
; CV2-NEXT:    muluwd $r4 = $r3, 0xaaaaaaab
; CV2-NEXT:    compw.ltu $r5 = $r3, 2
; CV2-NEXT:    ;;
; CV2-NEXT:    srld $r4 = $r4, 32
; CV2-NEXT:    ;;
; CV2-NEXT:    srlw $r4 = $r4, 1
; CV2-NEXT:    ;;
; CV2-NEXT:    msbfw $r3 = $r4, 3
; CV2-NEXT:    ;;
; CV2-NEXT:    addw $r3 = $r3, 1
; CV2-NEXT:    ;;
; CV2-NEXT:    zxbd $r3 = $r3
; CV2-NEXT:    ;;
; CV2-NEXT:    muluwd $r4 = $r3, 0xaaaaaaab
; CV2-NEXT:    ;;
; CV2-NEXT:    srld $r4 = $r4, 32
; CV2-NEXT:    ;;
; CV2-NEXT:    srlw $r4 = $r4, 1
; CV2-NEXT:    ;;
; CV2-NEXT:    msbfw $r3 = $r4, 3
; CV2-NEXT:    cb.odd $r5 ? .LBB0_1
; CV2-NEXT:    ;;
; CV2-NEXT:  # %bb.4: # in Loop: Header=BB0_3 Depth=1
; CV2-NEXT:    zxbd $r3 = $r3
; CV2-NEXT:    make $r5 = 1
; CV2-NEXT:    ;;
; CV2-NEXT:    compw.eq $r4 = $r3, 1
; CV2-NEXT:    ;;
; CV2-NEXT:    cmoved.even $r4 ? $r5 = 2
; CV2-NEXT:    ;;
; CV2-NEXT:    cmoved.weqz $r3 ? $r5 = 0
; CV2-NEXT:    ;;
; CV2-NEXT:    addw $r2 = $r5, $r2
; CV2-NEXT:    ;;
; CV2-NEXT:    addw $r2 = $r2, -3
; CV2-NEXT:    ;;
; CV2-NEXT:  .LBB0_5: # Parent Loop BB0_3 Depth=1
; CV2-NEXT:    # => This Inner Loop Header: Depth=2
; CV2-NEXT:    # implicit-def: $w0
; CV2-NEXT:    addw $r2 = $r2, 3
; CV2-NEXT:    ;;
; CV2-NEXT:    compw.lt $r3 = $r2, -2
; CV2-NEXT:    ;;
; CV2-NEXT:    cb.odd $r3 ? .LBB0_5
; CV2-NEXT:    ;;
; CV2-NEXT:    goto .LBB0_2
; CV2-NEXT:    ;;
  %1 = tail call <512 x i1> @llvm.kvx.cat.v512i1(<256 x i1> undef, <256 x i1> undef)
  br label %2

2:
  %3 = phi i64 [ %30, %25 ], [ 0, %0 ]
  %4 = phi <512 x i1> [ %26, %25 ], [ undef, %0 ]
  %5 = phi i32 [ %7, %25 ], [ undef, %0 ]
  %6 = icmp sgt i32 %5, 0
  %7 = select i1 %6, i32 %5, i32 0
  %8 = sub i32 %7, %5
  %9 = urem i32 %8, 3
  %10 = trunc i32 %9 to i8
  %11 = add nuw nsw i8 %10, 1
  %12 = urem i8 %11, 3
  %13 = icmp eq i8 %12, 1
  %14 = select i1 %13, <512 x i1> %4, <512 x i1> %1
  %15 = icmp ult i32 %8, 2
  br i1 %15, label %25, label %16

16:
  %17 = icmp eq i8 %12, 0
  %18 = select i1 %13, i32 1, i32 2
  %19 = select i1 %17, i32 0, i32 %18
  %20 = add nsw i32 %5, %19
  br label %21

21:
  %22 = phi i32 [ %24, %21 ], [ %20, %16 ]
  %23 = icmp slt i32 %22, -2
  %24 = add nsw i32 %22, 3
  br i1 %23, label %21, label %25

25:
  %26 = phi <512 x i1> [ %14, %2 ], [ %1, %21 ]
  %27 = tail call <1024 x i1> @llvm.kvx.cat.v1024i1(<512 x i1> %26, <512 x i1> undef)
  %28 = tail call <1024 x i1> @llvm.kvx.xmt44d(<1024 x i1> %27)
  %29 = inttoptr i64 %3 to <1024 x i1>*
  store <1024 x i1> %28, <1024 x i1>* %29, align 128
  %30 = add i64 %3, 2
  br label %2
}

declare <512 x i1> @llvm.kvx.cat.v512i1(<256 x i1>, <256 x i1>)

declare <1024 x i1> @llvm.kvx.cat.v1024i1(<512 x i1>, <512 x i1>)

declare <1024 x i1> @llvm.kvx.xmt44d(<1024 x i1>)

