; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -disable-kvx-hwloops=false -min-hwloop-trip-count=4 -O2 -o - %s | FileCheck %s
; Ensure that loopdo is created above the copy generated by phis
; Taken from Polybench/linear-algebra/kernels/2mm/
target triple = "kvx-kalray-cos"

define internal fastcc void @init_array(double* nocapture %alpha, double* nocapture %beta, [4 x double]* nocapture %A, [4 x double]* nocapture %B, [4 x double]* nocapture %C, [4 x double]* nocapture %D, [4 x double]* nocapture %D_StrictFP) {
; CHECK-LABEL: init_array:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    make $r4 = 0x40dfa70000000000
; CHECK-NEXT:    ;;
; CHECK-NEXT:    sd 0[$r0] = $r4
; CHECK-NEXT:    make $r0 = 0x40a0960000000000
; CHECK-NEXT:    ;;
; CHECK-NEXT:    sd 0[$r1] = $r0
; CHECK-NEXT:    make $r0 = 0
; CHECK-NEXT:    make $r1 = 4
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_1: # %for.cond1.preheader
; CHECK-NEXT:    # =>This Loop Header: Depth=1
; CHECK-NEXT:    # Child Loop BB0_2 Depth 2
; CHECK-NEXT:    sxwd $r4 = $r0
; CHECK-NEXT:    make $r5 = 0
; CHECK-NEXT:    ;;
; CHECK-NEXT:    floatd.rn $r4 = $r4, 0
; CHECK-NEXT:    ;;
; CHECK-NEXT:    loopdo $r1, .__LOOPDO_1_END_
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_2: # %for.body3
; CHECK-NEXT:    # Parent Loop BB0_1 Depth=1
; CHECK-NEXT:    # => This Inner Loop Header: Depth=2
; CHECK-NEXT:    sxwd $r6 = $r5
; CHECK-NEXT:    ;;
; CHECK-NEXT:    floatd.rn $r6 = $r6, 0
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fmuld $r6 = $r4, $r6
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fmuld $r6 = $r6, 0x3fd0000000000000
; CHECK-NEXT:    ;;
; CHECK-NEXT:    sd.xs $r5[$r2] = $r6
; CHECK-NEXT:    addd $r5 = $r5, 1
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .__LOOPDO_1_END_:
; CHECK-NEXT:  # %bb.3: # %for.inc8
; CHECK-NEXT:    # in Loop: Header=BB0_1 Depth=1
; CHECK-NEXT:    addd $r0 = $r0, 1
; CHECK-NEXT:    addd $r2 = $r2, 32
; CHECK-NEXT:    ;;
; CHECK-NEXT:    compd.ne $r4 = $r0, 4
; CHECK-NEXT:    ;;
; CHECK-NEXT:    cb.odd $r4 ? .LBB0_1
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.4: # %for.cond15.preheader.preheader
; CHECK-NEXT:    make $r0 = 0
; CHECK-NEXT:    make $r1 = 4
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_5: # %for.cond15.preheader
; CHECK-NEXT:    # =>This Loop Header: Depth=1
; CHECK-NEXT:    # Child Loop BB0_6 Depth 2
; CHECK-NEXT:    sxwd $r2 = $r0
; CHECK-NEXT:    make $r4 = 0
; CHECK-NEXT:    ;;
; CHECK-NEXT:    floatd.rn $r2 = $r2, 0
; CHECK-NEXT:    ;;
; CHECK-NEXT:    loopdo $r1, .__LOOPDO_0_END_
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_6: # %for.body18
; CHECK-NEXT:    # Parent Loop BB0_5 Depth=1
; CHECK-NEXT:    # => This Inner Loop Header: Depth=2
; CHECK-NEXT:    copyd $r5 = $r4
; CHECK-NEXT:    ;;
; CHECK-NEXT:    addd $r4 = $r5, 1
; CHECK-NEXT:    ;;
; CHECK-NEXT:    sxwd $r6 = $r4
; CHECK-NEXT:    ;;
; CHECK-NEXT:    floatd.rn $r6 = $r6, 0
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fmuld $r6 = $r2, $r6
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fmuld $r6 = $r6, 0x3fd0000000000000
; CHECK-NEXT:    ;;
; CHECK-NEXT:    sd.xs $r5[$r3] = $r6
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .__LOOPDO_0_END_:
; CHECK-NEXT:  # %bb.7: # %for.inc31
; CHECK-NEXT:    # in Loop: Header=BB0_5 Depth=1
; CHECK-NEXT:    addd $r0 = $r0, 1
; CHECK-NEXT:    addd $r3 = $r3, 32
; CHECK-NEXT:    ;;
; CHECK-NEXT:    compd.ne $r2 = $r0, 4
; CHECK-NEXT:    ;;
; CHECK-NEXT:    cb.odd $r2 ? .LBB0_5
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.8: # %for.end85
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  store double 3.241200e+04, double* %alpha, align 8
  store double 2.123000e+03, double* %beta, align 8
  br label %for.cond1.preheader

for.cond1.preheader:
  %indvars.iv29 = phi i64 [ 0, %entry ], [ %indvars.iv.next30, %for.inc8 ]
  %0 = trunc i64 %indvars.iv29 to i32
  %conv = sitofp i32 %0 to double
  br label %for.body3

for.body3:
  %indvars.iv26 = phi i64 [ 0, %for.cond1.preheader ], [ %indvars.iv.next27, %for.body3 ]
  %1 = trunc i64 %indvars.iv26 to i32
  %conv4 = sitofp i32 %1 to double
  %mul = fmul double %conv, %conv4
  %div = fmul double %mul, 2.500000e-01
  %arrayidx7 = getelementptr inbounds [4 x double], [4 x double]* %A, i64 %indvars.iv29, i64 %indvars.iv26
  store double %div, double* %arrayidx7, align 8
  %indvars.iv.next27 = add nuw nsw i64 %indvars.iv26, 1
  %exitcond28 = icmp eq i64 %indvars.iv.next27, 4
  br i1 %exitcond28, label %for.inc8, label %for.body3

for.inc8:
  %indvars.iv.next30 = add nuw nsw i64 %indvars.iv29, 1
  %exitcond31 = icmp eq i64 %indvars.iv.next30, 4
  br i1 %exitcond31, label %for.cond15.preheader, label %for.cond1.preheader

for.cond15.preheader:
  %indvars.iv23 = phi i64 [ %indvars.iv.next24, %for.inc31 ], [ 0, %for.inc8 ]
  %2 = trunc i64 %indvars.iv23 to i32
  %conv19 = sitofp i32 %2 to double
  br label %for.body18

for.body18:
  %indvars.iv20 = phi i64 [ 0, %for.cond15.preheader ], [ %indvars.iv.next21, %for.body18 ]
  %indvars.iv.next21 = add nuw nsw i64 %indvars.iv20, 1
  %3 = trunc i64 %indvars.iv.next21 to i32
  %conv20 = sitofp i32 %3 to double
  %mul21 = fmul double %conv19, %conv20
  %div23 = fmul double %mul21, 2.500000e-01
  %arrayidx27 = getelementptr inbounds [4 x double], [4 x double]* %B, i64 %indvars.iv23, i64 %indvars.iv20
  store double %div23, double* %arrayidx27, align 8
  %exitcond22 = icmp eq i64 %indvars.iv.next21, 4
  br i1 %exitcond22, label %for.inc31, label %for.body18

for.inc31:
  %indvars.iv.next24 = add nuw nsw i64 %indvars.iv23, 1
  %exitcond25 = icmp eq i64 %indvars.iv.next24, 4
  br i1 %exitcond25, label %for.end85, label %for.cond15.preheader

for.end85:
  ret void
}
