; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -o - %s -mtriple=kvx-kalray-cos -fstack-limit-register=sr | FileCheck %s --check-prefixes=CHECK
; RUN: llc -mcpu=kv3-2 -o - %s -mtriple=kvx-kalray-cos -fstack-limit-register=sr | FileCheck %s --check-prefixes=CHECK

; Function Attrs: norecurse nounwind readnone
define dso_local i32 @testalloca(i32 %n) local_unnamed_addr  {
; CHECK-LABEL: testalloca:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addd $r16 = $r12, -32
; CHECK-NEXT:    get $r17 = $sr
; CHECK-NEXT:    ;;
; CHECK-NEXT:    sbfd $r16 = $r16, $r17
; CHECK-NEXT:    ;;
; CHECK-NEXT:    cb.dgtz $r16 ? .LBB0_5
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.1: # %entry
; CHECK-NEXT:    sxwd $r1 = $r0
; CHECK-NEXT:    addd $r12 = $r12, -32
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;;
; CHECK-NEXT:    sd 24[$r12] = $r16
; CHECK-NEXT:    addx4d $r1 = $r1, 31
; CHECK-NEXT:    ;;
; CHECK-NEXT:    sd 16[$r12] = $r14
; CHECK-NEXT:    andd $r1 = $r1, -32
; CHECK-NEXT:    get $r2 = $sr
; CHECK-NEXT:    ;;
; CHECK-NEXT:    sbfd $r1 = $r1, $r12
; CHECK-NEXT:    addd $r14 = $r12, 16
; CHECK-NEXT:    ;;
; CHECK-NEXT:    sbfd $r2 = $r1, $r2
; CHECK-NEXT:    ;;
; CHECK-NEXT:    cb.dgtz $r2 ? .LBB0_5
; CHECK-NEXT:    ;;
; CHECK-NEXT:    copyd $r12 = $r1
; CHECK-NEXT:    ;;
; CHECK-NEXT:    cb.wlez $r0 ? .LBB0_3
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.2: # %for.body.preheader
; CHECK-NEXT:    make $r2 = 0
; CHECK-NEXT:    zxwd $r3 = $r0
; CHECK-NEXT:    ;;
; CHECK-NEXT:    loopdo $r3, .__LOOPDO_0_END_
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_4: # %for.body
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    sw.xs $r2[$r1] = $r2
; CHECK-NEXT:    addd $r2 = $r2, 1
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .__LOOPDO_0_END_:
; CHECK-NEXT:  .LBB0_3: # %for.cond.cleanup
; CHECK-NEXT:    addw $r0 = $r0, -2
; CHECK-NEXT:    ;;
; CHECK-NEXT:    sxwd $r0 = $r0
; CHECK-NEXT:    ;;
; CHECK-NEXT:    lwz.xs $r0 = $r0[$r1]
; CHECK-NEXT:    addd $r12 = $r14, -16
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ld $r14 = 16[$r12]
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ld $r16 = 24[$r12]
; CHECK-NEXT:    ;;
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 32
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_5: # Label of block must be emitted
; CHECK-NEXT:    get $r0 = $pc
; CHECK-NEXT:    copyd $r1 = $r12
; CHECK-NEXT:    ;;
; CHECK-NEXT:    call __stack_overflow_detected
; CHECK-NEXT:    ;;
entry:
  %conv = sext i32 %n to i64
  %0 = alloca i32, i64 %conv, align 8
  %cmp12 = icmp sgt i32 %n, 0
  br i1 %cmp12, label %for.body.preheader, label %for.cond.cleanup

for.body.preheader:                               ; preds = %entry
  %wide.trip.count = zext i32 %n to i64
  br label %for.body

for.cond.cleanup:                                 ; preds = %for.body, %entry
  %sub = add nsw i32 %n, -2
  %idxprom2 = sext i32 %sub to i64
  %arrayidx3 = getelementptr inbounds i32, i32* %0, i64 %idxprom2
  %1 = load i32, i32* %arrayidx3, align 4
  ret i32 %1

for.body:                                         ; preds = %for.body, %for.body.preheader
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ]
  %arrayidx = getelementptr inbounds i32, i32* %0, i64 %indvars.iv
  %2 = trunc i64 %indvars.iv to i32
  store i32 %2, i32* %arrayidx, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond, label %for.cond.cleanup, label %for.body
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.lifetime.start.p0i8(i64 immarg, i8* nocapture)

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.lifetime.end.p0i8(i64 immarg, i8* nocapture)

; Function Attrs: nounwind
define dso_local i32 @testrealign() local_unnamed_addr  {
; CHECK-LABEL: testrealign:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addd $r16 = $r12, -256
; CHECK-NEXT:    get $r17 = $sr
; CHECK-NEXT:    ;;
; CHECK-NEXT:    sbfd $r16 = $r16, $r17
; CHECK-NEXT:    ;;
; CHECK-NEXT:    cb.dgtz $r16 ? .LBB1_2
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.1: # %entry
; CHECK-NEXT:    make $r0 = 7
; CHECK-NEXT:    addd $r12 = $r12, -256
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;;
; CHECK-NEXT:    sd 248[$r12] = $r16
; CHECK-NEXT:    ;;
; CHECK-NEXT:    sd 240[$r12] = $r14
; CHECK-NEXT:    addd $r14 = $r12, 240
; CHECK-NEXT:    ;;
; CHECK-NEXT:    sd 232[$r12] = $r31
; CHECK-NEXT:    andd $r31 = $r12, -128
; CHECK-NEXT:    ;;
; CHECK-NEXT:    sw 228[$r31] = $r0
; CHECK-NEXT:    make $r0 = 0x4d2
; CHECK-NEXT:    addd $r1 = $r31, 128
; CHECK-NEXT:    ;;
; CHECK-NEXT:    sw 128[$r31] = $r0
; CHECK-NEXT:    addd $r0 = $r31, 228
; CHECK-NEXT:    call other
; CHECK-NEXT:    ;;
; CHECK-NEXT:    addd $r12 = $r14, -240
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ld $r31 = 232[$r12]
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ld $r14 = 240[$r12]
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ld $r16 = 248[$r12]
; CHECK-NEXT:    ;;
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 256
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB1_2: # Label of block must be emitted
; CHECK-NEXT:    get $r0 = $pc
; CHECK-NEXT:    copyd $r1 = $r12
; CHECK-NEXT:    ;;
; CHECK-NEXT:    call __stack_overflow_detected
; CHECK-NEXT:    ;;
entry:
  %c = alloca i32, align 4
  %i = alloca i32, align 128
  %0 = bitcast i32* %c to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %0)
  store i32 7, i32* %c, align 4
  %1 = bitcast i32* %i to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %1)
  store i32 1234, i32* %i, align 128
  %call = call i32 @other(i32* nonnull %c, i32* nonnull %i)
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %1)
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %0)
  ret i32 %call
}

declare dso_local i32 @other(i32*, i32*) local_unnamed_addr
