; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=kvx-kalray-cos -fstack-limit-register=sr | FileCheck %s

; Function Attrs: norecurse nounwind readnone
define dso_local i32 @testalloca(i32 %n) local_unnamed_addr  {
; CHECK-LABEL: testalloca:
; CHECK:       # %bb.0:
; CHECK-NEXT:    get $r17 = $sr
; CHECK-NEXT:    addd $r16 = $r12, -32
; CHECK-NEXT:    ;;
; CHECK-NEXT:    sbfd $r16 = $r16, $r17
; CHECK-NEXT:    ;;
; CHECK-NEXT:    cb.dlez $r16 ? .LBB0_2
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_1:
; CHECK-NEXT:    get $r0 = $pc
; CHECK-NEXT:    copyd $r1 = $r12
; CHECK-NEXT:    ;;
; CHECK-NEXT:    call __stack_overflow_detected
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_2: # %entry
; CHECK-NEXT:    addd $r12 = $r12, -32
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;;
; CHECK-NEXT:    .cfi_def_cfa_offset 32
; CHECK-NEXT:    sd 8[$r12] = $r16
; CHECK-NEXT:    ;;
; CHECK-NEXT:    .cfi_offset 67, -24
; CHECK-NEXT:    sd 0[$r12] = $r14
; CHECK-NEXT:    copyd $r14 = $r12
; CHECK-NEXT:    sxwd $r1 = $r0
; CHECK-NEXT:    ;;
; CHECK-NEXT:    .cfi_offset 14, -32
; CHECK-NEXT:    .cfi_def_cfa_register 14
; CHECK-NEXT:    get $r2 = $sr
; CHECK-NEXT:    addx4d $r1 = $r1, 31
; CHECK-NEXT:    ;;
; CHECK-NEXT:    andd $r1 = $r1, -32
; CHECK-NEXT:    ;;
; CHECK-NEXT:    sbfd $r1 = $r1, $r12
; CHECK-NEXT:    ;;
; CHECK-NEXT:    sbfd $r2 = $r1, $r2
; CHECK-NEXT:    ;;
; CHECK-NEXT:    cb.dgtz $r2 ? .LBB0_1
; CHECK-NEXT:    ;;
; CHECK-NEXT:    copyd $r12 = $r1
; CHECK-NEXT:    cb.wlez $r0 ? .LBB0_5
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.3: # %for.body.preheader
; CHECK-NEXT:    make $r3 = 0
; CHECK-NEXT:    zxwd $r2 = $r0
; CHECK-NEXT:    copyd $r4 = $r1
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_4: # %for.body
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    sw 0[$r4] = $r3
; CHECK-NEXT:    addd $r2 = $r2, -1
; CHECK-NEXT:    addw $r3 = $r3, 1
; CHECK-NEXT:    addd $r4 = $r4, 4
; CHECK-NEXT:    ;;
; CHECK-NEXT:    cb.dnez $r2 ? .LBB0_4
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_5: # %for.cond.cleanup
; CHECK-NEXT:    addw $r0 = $r0, -2
; CHECK-NEXT:    ;;
; CHECK-NEXT:    sxwd $r0 = $r0
; CHECK-NEXT:    ;;
; CHECK-NEXT:    lwz.xs $r0 = $r0[$r1]
; CHECK-NEXT:    copyd $r12 = $r14
; CHECK-NEXT:    ;;
; CHECK-NEXT:    .cfi_def_cfa_register 12
; CHECK-NEXT:    ld $r16 = 8[$r12]
; CHECK-NEXT:    ;;
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    ld $r14 = 0[$r12]
; CHECK-NEXT:    addd $r12 = $r12, 32
; CHECK-NEXT:    ;;
; CHECK-NEXT:    .cfi_def_cfa_offset 0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %conv = sext i32 %n to i64
  %0 = alloca i32, i64 %conv, align 8
  %cmp12 = icmp sgt i32 %n, 0
  br i1 %cmp12, label %for.body.preheader, label %for.cond.cleanup

for.body.preheader:                               ; preds = %entry
  %wide.trip.count = zext i32 %n to i64
  br label %for.body

for.cond.cleanup:                                 ; preds = %for.body, %entry
  %sub = add nsw i32 %n, -2
  %idxprom2 = sext i32 %sub to i64
  %arrayidx3 = getelementptr inbounds i32, i32* %0, i64 %idxprom2
  %1 = load i32, i32* %arrayidx3, align 4
  ret i32 %1

for.body:                                         ; preds = %for.body, %for.body.preheader
  %indvars.iv = phi i64 [ 0, %for.body.preheader ], [ %indvars.iv.next, %for.body ]
  %arrayidx = getelementptr inbounds i32, i32* %0, i64 %indvars.iv
  %2 = trunc i64 %indvars.iv to i32
  store i32 %2, i32* %arrayidx, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond, label %for.cond.cleanup, label %for.body
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.lifetime.start.p0i8(i64 immarg, i8* nocapture)

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.lifetime.end.p0i8(i64 immarg, i8* nocapture)

; Function Attrs: nounwind
define dso_local i32 @testrealign() local_unnamed_addr  {
; CHECK-LABEL: testrealign:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addd $r16 = $r12, -384
; CHECK-NEXT:    get $r17 = $sr
; CHECK-NEXT:    ;;
; CHECK-NEXT:    addd $r16 = $r16, 96
; CHECK-NEXT:    ;;
; CHECK-NEXT:    andd $r16 = $r16, -128
; CHECK-NEXT:    ;;
; CHECK-NEXT:    sbfd $r16 = $r16, $r17
; CHECK-NEXT:    ;;
; CHECK-NEXT:    cb.dlez $r16 ? .LBB1_2
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    get $r0 = $pc
; CHECK-NEXT:    copyd $r1 = $r12
; CHECK-NEXT:    ;;
; CHECK-NEXT:    call __stack_overflow_detected
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB1_2: # %entry
; CHECK-NEXT:    addd $r12 = $r12, -384
; CHECK-NEXT:    ;;
; CHECK-NEXT:    .cfi_def_cfa_offset 384
; CHECK-NEXT:    copyd $r32 = $r12
; CHECK-NEXT:    addd $r12 = $r12, 96
; CHECK-NEXT:    ;;
; CHECK-NEXT:    .cfi_def_cfa_register 32
; CHECK-NEXT:    andd $r12 = $r12, -128
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;;
; CHECK-NEXT:    sd 8[$r12] = $r16
; CHECK-NEXT:    ;;
; CHECK-NEXT:    .cfi_escape 0x10, 0x43, 0x02, 0x7c, 0x08
; CHECK-NEXT:    sd 0[$r12] = $r14
; CHECK-NEXT:    copyd $r14 = $r32
; CHECK-NEXT:    make $r0 = 7
; CHECK-NEXT:    addd $r1 = $r12, 128
; CHECK-NEXT:    ;;
; CHECK-NEXT:    .cfi_escape 0x10, 0x0e, 0x02, 0x7c, 0x00
; CHECK-NEXT:    .cfi_def_cfa_register 14
; CHECK-NEXT:    sw 16[$r12] = $r0
; CHECK-NEXT:    make $r0 = 0x4d2
; CHECK-NEXT:    ;;
; CHECK-NEXT:    sw 128[$r12] = $r0
; CHECK-NEXT:    addd $r0 = $r12, 16
; CHECK-NEXT:    call other
; CHECK-NEXT:    ;;
; CHECK-NEXT:    copyd $r32 = $r14
; CHECK-NEXT:    ld $r16 = 8[$r12]
; CHECK-NEXT:    ;;
; CHECK-NEXT:    .cfi_def_cfa_register 32
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    ld $r14 = 0[$r12]
; CHECK-NEXT:    copyd $r12 = $r32
; CHECK-NEXT:    ;;
; CHECK-NEXT:    .cfi_restore 67
; CHECK-NEXT:    .cfi_def_cfa_register 12
; CHECK-NEXT:    addd $r12 = $r12, 384
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %c = alloca i32, align 4
  %i = alloca i32, align 128
  %0 = bitcast i32* %c to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %0)
  store i32 7, i32* %c, align 4
  %1 = bitcast i32* %i to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %1)
  store i32 1234, i32* %i, align 128
  %call = call i32 @other(i32* nonnull %c, i32* nonnull %i)
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %1)
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %0)
  ret i32 %call
}

declare dso_local i32 @other(i32*, i32*) local_unnamed_addr
