; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -verify-machineinstrs < %s -mtriple=kvx-kalray-cos | FileCheck %s

%struct.atomic_flag = type { i8 }

; Function Attrs: noinline nounwind optnone
define dso_local i32 @a() {
; CHECK-LABEL: a:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addd $r12 = $r12, -32
; CHECK-NEXT:    ;;
; CHECK-NEXT:    lwz $r0 = 28[$r12]
; CHECK-NEXT:    addd $r12 = $r12, 32
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %1 = alloca i32, align 4
  %2 = load i32, i32* %1, align 4
  ret i32 %2
}

; Function Attrs: noinline nounwind optnone
define internal i1 @atomic_flag_test_and_set(%struct.atomic_flag* %0) {
; CHECK-LABEL: atomic_flag_test_and_set:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addd $r12 = $r12, -32
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;;
; CHECK-NEXT:    sd 24[$r12] = $r16
; CHECK-NEXT:    make $r1 = 5
; CHECK-NEXT:    ;;
; CHECK-NEXT:    sd 16[$r12] = $r0
; CHECK-NEXT:    call atomic_flag_test_and_set_explicit
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ld $r16 = 24[$r12]
; CHECK-NEXT:    ;;
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 32
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %2 = alloca %struct.atomic_flag*, align 8
  store %struct.atomic_flag* %0, %struct.atomic_flag** %2, align 8
  %3 = load %struct.atomic_flag*, %struct.atomic_flag** %2, align 8
  %4 = call i1 @atomic_flag_test_and_set_explicit(%struct.atomic_flag* %3, i32 5)
  ret i1 %4
}

; Function Attrs: noinline nounwind optnone
define internal i1 @atomic_flag_test_and_set_explicit(%struct.atomic_flag* %0, i32 %1) {
; CHECK-LABEL: atomic_flag_test_and_set_explicit:
; CHECK:       # %bb.0:
; CHECK-NEXT:    make $r2 = 1
; CHECK-NEXT:    compw.gt $r3 = $r1, 3
; CHECK-NEXT:    addd $r12 = $r12, -32
; CHECK-NEXT:    ;;
; CHECK-NEXT:    sd 24[$r12] = $r0
; CHECK-NEXT:    ;;
; CHECK-NEXT:    sw 20[$r12] = $r1
; CHECK-NEXT:    ;;
; CHECK-NEXT:    sb 19[$r12] = $r2
; CHECK-NEXT:    cb.odd $r3 ? .LBB2_4
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    addw $r2 = $r1, -1
; CHECK-NEXT:    ;;
; CHECK-NEXT:    compw.ltu $r2 = $r2, 2
; CHECK-NEXT:    ;;
; CHECK-NEXT:    cb.even $r2 ? .LBB2_2
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.9:
; CHECK-NEXT:    lbz $r1 = 19[$r12]
; CHECK-NEXT:    ;;
; CHECK-NEXT:    andd $r3 = $r0, 3
; CHECK-NEXT:    fence
; CHECK-NEXT:    ;;
; CHECK-NEXT:    slld $r3 = $r3, 3
; CHECK-NEXT:    sbfd $r7 = $r3, 0
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB2_10: # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    lwz.u $r5 = $r7[$r0]
; CHECK-NEXT:    sllw $r6 = $r1, $r3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    srlw $r2 = $r5, $r3
; CHECK-NEXT:    orw $r4 = $r5, $r6
; CHECK-NEXT:    ;;
; CHECK-NEXT:    andw $r2 = $r2, 255
; CHECK-NEXT:    ;;
; CHECK-NEXT:    cb.wnez $r2 ? .LBB2_17
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.11: # in Loop: Header=BB2_10 Depth=1
; CHECK-NEXT:    acswapw $r7[$r0] = $r4r5
; CHECK-NEXT:    ;;
; CHECK-NEXT:    cb.even $r4 ? .LBB2_10
; CHECK-NEXT:    ;;
; CHECK-NEXT:    goto .LBB2_17
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB2_4:
; CHECK-NEXT:    compw.eq $r2 = $r1, 4
; CHECK-NEXT:    ;;
; CHECK-NEXT:    cb.odd $r2 ? .LBB2_12
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.5:
; CHECK-NEXT:    compw.eq $r1 = $r1, 5
; CHECK-NEXT:    ;;
; CHECK-NEXT:    cb.even $r1 ? .LBB2_6
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB2_12:
; CHECK-NEXT:    lbz $r1 = 19[$r12]
; CHECK-NEXT:    ;;
; CHECK-NEXT:    goto .LBB2_13
; CHECK-NEXT:    fence
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB2_2:
; CHECK-NEXT:    compw.eq $r1 = $r1, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    cb.even $r1 ? .LBB2_6
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.3:
; CHECK-NEXT:    lbz $r1 = 19[$r12]
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB2_13:
; CHECK-NEXT:    andd $r3 = $r0, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    slld $r3 = $r3, 3
; CHECK-NEXT:    sbfd $r7 = $r3, 0
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB2_14: # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    lwz.u $r5 = $r7[$r0]
; CHECK-NEXT:    sllw $r6 = $r1, $r3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    srlw $r2 = $r5, $r3
; CHECK-NEXT:    orw $r4 = $r5, $r6
; CHECK-NEXT:    ;;
; CHECK-NEXT:    andw $r2 = $r2, 255
; CHECK-NEXT:    ;;
; CHECK-NEXT:    cb.wnez $r2 ? .LBB2_16
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.15: # in Loop: Header=BB2_14 Depth=1
; CHECK-NEXT:    acswapw $r7[$r0] = $r4r5
; CHECK-NEXT:    ;;
; CHECK-NEXT:    cb.even $r4 ? .LBB2_14
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB2_16: # Label of block must be emitted
; CHECK-NEXT:    fence
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB2_17:
; CHECK-NEXT:    sb 18[$r12] = $r2
; CHECK-NEXT:    ;;
; CHECK-NEXT:    lbz $r0 = 18[$r12]
; CHECK-NEXT:    addd $r12 = $r12, 32
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB2_6:
; CHECK-NEXT:    lbz $r1 = 19[$r12]
; CHECK-NEXT:    andd $r3 = $r0, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    slld $r3 = $r3, 3
; CHECK-NEXT:    sbfd $r7 = $r3, 0
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB2_7: # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    lwz.u $r5 = $r7[$r0]
; CHECK-NEXT:    sllw $r6 = $r1, $r3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    srlw $r2 = $r5, $r3
; CHECK-NEXT:    orw $r4 = $r5, $r6
; CHECK-NEXT:    ;;
; CHECK-NEXT:    andw $r2 = $r2, 255
; CHECK-NEXT:    ;;
; CHECK-NEXT:    cb.wnez $r2 ? .LBB2_17
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.8: # in Loop: Header=BB2_7 Depth=1
; CHECK-NEXT:    acswapw $r7[$r0] = $r4r5
; CHECK-NEXT:    ;;
; CHECK-NEXT:    cb.even $r4 ? .LBB2_7
; CHECK-NEXT:    ;;
; CHECK-NEXT:    goto .LBB2_17
; CHECK-NEXT:    ;;
  %3 = alloca %struct.atomic_flag*, align 8
  %4 = alloca i32, align 4
  %5 = alloca i8, align 1
  %6 = alloca i8, align 1
  store %struct.atomic_flag* %0, %struct.atomic_flag** %3, align 8
  store i32 %1, i32* %4, align 4
  %7 = load %struct.atomic_flag*, %struct.atomic_flag** %3, align 8
  %8 = getelementptr inbounds %struct.atomic_flag, %struct.atomic_flag* %7, i32 0, i32 0
  %9 = load i32, i32* %4, align 4
  store i8 1, i8* %5, align 1
  switch i32 %9, label %10 [
    i32 1, label %13
    i32 2, label %13
    i32 3, label %16
    i32 4, label %19
    i32 5, label %22
  ]

10:                                               ; preds = %2
  %11 = load i8, i8* %5, align 1
  %12 = atomicrmw volatile xchg i8* %8, i8 %11 monotonic
  store i8 %12, i8* %6, align 1
  br label %25

13:                                               ; preds = %2, %2
  %14 = load i8, i8* %5, align 1
  %15 = atomicrmw volatile xchg i8* %8, i8 %14 acquire
  store i8 %15, i8* %6, align 1
  br label %25

16:                                               ; preds = %2
  %17 = load i8, i8* %5, align 1
  %18 = atomicrmw volatile xchg i8* %8, i8 %17 release
  store i8 %18, i8* %6, align 1
  br label %25

19:                                               ; preds = %2
  %20 = load i8, i8* %5, align 1
  %21 = atomicrmw volatile xchg i8* %8, i8 %20 acq_rel
  store i8 %21, i8* %6, align 1
  br label %25

22:                                               ; preds = %2
  %23 = load i8, i8* %5, align 1
  %24 = atomicrmw volatile xchg i8* %8, i8 %23 seq_cst
  store i8 %24, i8* %6, align 1
  br label %25

25:                                               ; preds = %22, %19, %16, %13, %10
  %26 = load i8, i8* %6, align 1
  %27 = trunc i8 %26 to i1
  ret i1 %27
}
