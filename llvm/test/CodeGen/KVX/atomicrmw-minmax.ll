; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mcpu=kv3-1 < %s -mtriple=kvx-kalray-cos | FileCheck %s --check-prefixes=CV1
; RUN: llc -mcpu=kv3-2 < %s -mtriple=kvx-kalray-cos | FileCheck %s --check-prefixes=CV2

define i32 @f32min(i32 *%src, i32 %b) {
; CV1-LABEL: f32min:
; CV1:       # %bb.0:
; CV1-NEXT:    fence
; CV1-NEXT:    ;;
; CV1-NEXT:  .LBB0_1: # =>This Inner Loop Header: Depth=1
; CV1-NEXT:    lwz.u $r3 = 0[$r0]
; CV1-NEXT:    ;;
; CV1-NEXT:    minw $r2 = $r1, $r3
; CV1-NEXT:    ;;
; CV1-NEXT:    acswapw 0[$r0] = $r2r3
; CV1-NEXT:    ;;
; CV1-NEXT:    cb.even $r2 ? .LBB0_1
; CV1-NEXT:    ;;
; CV1-NEXT:  # %bb.2:
; CV1-NEXT:    copyw $r0 = $r3
; CV1-NEXT:    fence
; CV1-NEXT:    ret
; CV1-NEXT:    ;;
;
; CV2-LABEL: f32min:
; CV2:       # %bb.0:
; CV2-NEXT:    fence
; CV2-NEXT:    ;;
; CV2-NEXT:  .LBB0_1: # =>This Inner Loop Header: Depth=1
; CV2-NEXT:    lwz.u $r3 = 0[$r0]
; CV2-NEXT:    ;;
; CV2-NEXT:    minw $r2 = $r1, $r3
; CV2-NEXT:    ;;
; CV2-NEXT:    acswapw.v $r2, [$r0] = $r2r3
; CV2-NEXT:    ;;
; CV2-NEXT:    cb.even $r2 ? .LBB0_1
; CV2-NEXT:    ;;
; CV2-NEXT:  # %bb.2:
; CV2-NEXT:    copyw $r0 = $r3
; CV2-NEXT:    fence
; CV2-NEXT:    ret
; CV2-NEXT:    ;;
  %res = atomicrmw min i32 *%src, i32 %b seq_cst
  ret i32 %res
}

define i32 @f32max(i32 *%src, i32 %b) {
; CV1-LABEL: f32max:
; CV1:       # %bb.0:
; CV1-NEXT:    fence
; CV1-NEXT:    ;;
; CV1-NEXT:  .LBB1_1: # =>This Inner Loop Header: Depth=1
; CV1-NEXT:    lwz.u $r3 = 0[$r0]
; CV1-NEXT:    ;;
; CV1-NEXT:    maxw $r2 = $r1, $r3
; CV1-NEXT:    ;;
; CV1-NEXT:    acswapw 0[$r0] = $r2r3
; CV1-NEXT:    ;;
; CV1-NEXT:    cb.even $r2 ? .LBB1_1
; CV1-NEXT:    ;;
; CV1-NEXT:  # %bb.2:
; CV1-NEXT:    copyw $r0 = $r3
; CV1-NEXT:    fence
; CV1-NEXT:    ret
; CV1-NEXT:    ;;
;
; CV2-LABEL: f32max:
; CV2:       # %bb.0:
; CV2-NEXT:    fence
; CV2-NEXT:    ;;
; CV2-NEXT:  .LBB1_1: # =>This Inner Loop Header: Depth=1
; CV2-NEXT:    lwz.u $r3 = 0[$r0]
; CV2-NEXT:    ;;
; CV2-NEXT:    maxw $r2 = $r1, $r3
; CV2-NEXT:    ;;
; CV2-NEXT:    acswapw.v $r2, [$r0] = $r2r3
; CV2-NEXT:    ;;
; CV2-NEXT:    cb.even $r2 ? .LBB1_1
; CV2-NEXT:    ;;
; CV2-NEXT:  # %bb.2:
; CV2-NEXT:    copyw $r0 = $r3
; CV2-NEXT:    fence
; CV2-NEXT:    ret
; CV2-NEXT:    ;;
  %res = atomicrmw max i32 *%src, i32 %b seq_cst
  ret i32 %res
}

define i32 @f32umin(i32 *%src, i32 %b) {
; CV1-LABEL: f32umin:
; CV1:       # %bb.0:
; CV1-NEXT:    fence
; CV1-NEXT:    ;;
; CV1-NEXT:  .LBB2_1: # =>This Inner Loop Header: Depth=1
; CV1-NEXT:    lwz.u $r3 = 0[$r0]
; CV1-NEXT:    ;;
; CV1-NEXT:    minuw $r2 = $r1, $r3
; CV1-NEXT:    ;;
; CV1-NEXT:    acswapw 0[$r0] = $r2r3
; CV1-NEXT:    ;;
; CV1-NEXT:    cb.even $r2 ? .LBB2_1
; CV1-NEXT:    ;;
; CV1-NEXT:  # %bb.2:
; CV1-NEXT:    copyw $r0 = $r3
; CV1-NEXT:    fence
; CV1-NEXT:    ret
; CV1-NEXT:    ;;
;
; CV2-LABEL: f32umin:
; CV2:       # %bb.0:
; CV2-NEXT:    fence
; CV2-NEXT:    ;;
; CV2-NEXT:  .LBB2_1: # =>This Inner Loop Header: Depth=1
; CV2-NEXT:    lwz.u $r3 = 0[$r0]
; CV2-NEXT:    ;;
; CV2-NEXT:    minuw $r2 = $r1, $r3
; CV2-NEXT:    ;;
; CV2-NEXT:    acswapw.v $r2, [$r0] = $r2r3
; CV2-NEXT:    ;;
; CV2-NEXT:    cb.even $r2 ? .LBB2_1
; CV2-NEXT:    ;;
; CV2-NEXT:  # %bb.2:
; CV2-NEXT:    copyw $r0 = $r3
; CV2-NEXT:    fence
; CV2-NEXT:    ret
; CV2-NEXT:    ;;
  %res = atomicrmw umin i32 *%src, i32 %b seq_cst
  ret i32 %res
}

define i32 @f32umax(i32 *%src, i32 %b) {
; CV1-LABEL: f32umax:
; CV1:       # %bb.0:
; CV1-NEXT:    fence
; CV1-NEXT:    ;;
; CV1-NEXT:  .LBB3_1: # =>This Inner Loop Header: Depth=1
; CV1-NEXT:    lwz.u $r3 = 0[$r0]
; CV1-NEXT:    ;;
; CV1-NEXT:    maxuw $r2 = $r1, $r3
; CV1-NEXT:    ;;
; CV1-NEXT:    acswapw 0[$r0] = $r2r3
; CV1-NEXT:    ;;
; CV1-NEXT:    cb.even $r2 ? .LBB3_1
; CV1-NEXT:    ;;
; CV1-NEXT:  # %bb.2:
; CV1-NEXT:    copyw $r0 = $r3
; CV1-NEXT:    fence
; CV1-NEXT:    ret
; CV1-NEXT:    ;;
;
; CV2-LABEL: f32umax:
; CV2:       # %bb.0:
; CV2-NEXT:    fence
; CV2-NEXT:    ;;
; CV2-NEXT:  .LBB3_1: # =>This Inner Loop Header: Depth=1
; CV2-NEXT:    lwz.u $r3 = 0[$r0]
; CV2-NEXT:    ;;
; CV2-NEXT:    maxuw $r2 = $r1, $r3
; CV2-NEXT:    ;;
; CV2-NEXT:    acswapw.v $r2, [$r0] = $r2r3
; CV2-NEXT:    ;;
; CV2-NEXT:    cb.even $r2 ? .LBB3_1
; CV2-NEXT:    ;;
; CV2-NEXT:  # %bb.2:
; CV2-NEXT:    copyw $r0 = $r3
; CV2-NEXT:    fence
; CV2-NEXT:    ret
; CV2-NEXT:    ;;
  %res = atomicrmw umax i32 *%src, i32 %b seq_cst
  ret i32 %res
}

define i64 @f64min(i64 *%src, i64 %b) {
; CV1-LABEL: f64min:
; CV1:       # %bb.0:
; CV1-NEXT:    fence
; CV1-NEXT:    ;;
; CV1-NEXT:  .LBB4_1: # =>This Inner Loop Header: Depth=1
; CV1-NEXT:    ld.u $r3 = 0[$r0]
; CV1-NEXT:    ;;
; CV1-NEXT:    mind $r2 = $r1, $r3
; CV1-NEXT:    ;;
; CV1-NEXT:    acswapd 0[$r0] = $r2r3
; CV1-NEXT:    ;;
; CV1-NEXT:    cb.even $r2 ? .LBB4_1
; CV1-NEXT:    ;;
; CV1-NEXT:  # %bb.2:
; CV1-NEXT:    copyd $r0 = $r3
; CV1-NEXT:    fence
; CV1-NEXT:    ret
; CV1-NEXT:    ;;
;
; CV2-LABEL: f64min:
; CV2:       # %bb.0:
; CV2-NEXT:    fence
; CV2-NEXT:    ;;
; CV2-NEXT:  .LBB4_1: # =>This Inner Loop Header: Depth=1
; CV2-NEXT:    ld.u $r3 = 0[$r0]
; CV2-NEXT:    ;;
; CV2-NEXT:    mind $r2 = $r1, $r3
; CV2-NEXT:    ;;
; CV2-NEXT:    acswapd.v $r2, [$r0] = $r2r3
; CV2-NEXT:    ;;
; CV2-NEXT:    cb.even $r2 ? .LBB4_1
; CV2-NEXT:    ;;
; CV2-NEXT:  # %bb.2:
; CV2-NEXT:    copyd $r0 = $r3
; CV2-NEXT:    fence
; CV2-NEXT:    ret
; CV2-NEXT:    ;;
  %res = atomicrmw min i64 *%src, i64 %b seq_cst
  ret i64 %res
}

define i64 @f64max(i64 *%src, i64 %b) {
; CV1-LABEL: f64max:
; CV1:       # %bb.0:
; CV1-NEXT:    fence
; CV1-NEXT:    ;;
; CV1-NEXT:  .LBB5_1: # =>This Inner Loop Header: Depth=1
; CV1-NEXT:    ld.u $r3 = 0[$r0]
; CV1-NEXT:    ;;
; CV1-NEXT:    maxd $r2 = $r1, $r3
; CV1-NEXT:    ;;
; CV1-NEXT:    acswapd 0[$r0] = $r2r3
; CV1-NEXT:    ;;
; CV1-NEXT:    cb.even $r2 ? .LBB5_1
; CV1-NEXT:    ;;
; CV1-NEXT:  # %bb.2:
; CV1-NEXT:    copyd $r0 = $r3
; CV1-NEXT:    fence
; CV1-NEXT:    ret
; CV1-NEXT:    ;;
;
; CV2-LABEL: f64max:
; CV2:       # %bb.0:
; CV2-NEXT:    fence
; CV2-NEXT:    ;;
; CV2-NEXT:  .LBB5_1: # =>This Inner Loop Header: Depth=1
; CV2-NEXT:    ld.u $r3 = 0[$r0]
; CV2-NEXT:    ;;
; CV2-NEXT:    maxd $r2 = $r1, $r3
; CV2-NEXT:    ;;
; CV2-NEXT:    acswapd.v $r2, [$r0] = $r2r3
; CV2-NEXT:    ;;
; CV2-NEXT:    cb.even $r2 ? .LBB5_1
; CV2-NEXT:    ;;
; CV2-NEXT:  # %bb.2:
; CV2-NEXT:    copyd $r0 = $r3
; CV2-NEXT:    fence
; CV2-NEXT:    ret
; CV2-NEXT:    ;;
  %res = atomicrmw max i64 *%src, i64 %b seq_cst
  ret i64 %res
}

define i64 @f64umin(i64 *%src, i64 %b) {
; CV1-LABEL: f64umin:
; CV1:       # %bb.0:
; CV1-NEXT:    fence
; CV1-NEXT:    ;;
; CV1-NEXT:  .LBB6_1: # =>This Inner Loop Header: Depth=1
; CV1-NEXT:    ld.u $r3 = 0[$r0]
; CV1-NEXT:    ;;
; CV1-NEXT:    minud $r2 = $r1, $r3
; CV1-NEXT:    ;;
; CV1-NEXT:    acswapd 0[$r0] = $r2r3
; CV1-NEXT:    ;;
; CV1-NEXT:    cb.even $r2 ? .LBB6_1
; CV1-NEXT:    ;;
; CV1-NEXT:  # %bb.2:
; CV1-NEXT:    copyd $r0 = $r3
; CV1-NEXT:    fence
; CV1-NEXT:    ret
; CV1-NEXT:    ;;
;
; CV2-LABEL: f64umin:
; CV2:       # %bb.0:
; CV2-NEXT:    fence
; CV2-NEXT:    ;;
; CV2-NEXT:  .LBB6_1: # =>This Inner Loop Header: Depth=1
; CV2-NEXT:    ld.u $r3 = 0[$r0]
; CV2-NEXT:    ;;
; CV2-NEXT:    minud $r2 = $r1, $r3
; CV2-NEXT:    ;;
; CV2-NEXT:    acswapd.v $r2, [$r0] = $r2r3
; CV2-NEXT:    ;;
; CV2-NEXT:    cb.even $r2 ? .LBB6_1
; CV2-NEXT:    ;;
; CV2-NEXT:  # %bb.2:
; CV2-NEXT:    copyd $r0 = $r3
; CV2-NEXT:    fence
; CV2-NEXT:    ret
; CV2-NEXT:    ;;
  %res = atomicrmw umin i64 *%src, i64 %b seq_cst
  ret i64 %res
}

define i64 @f64umax(i64 *%src, i64 %b) {
; CV1-LABEL: f64umax:
; CV1:       # %bb.0:
; CV1-NEXT:    fence
; CV1-NEXT:    ;;
; CV1-NEXT:  .LBB7_1: # =>This Inner Loop Header: Depth=1
; CV1-NEXT:    ld.u $r3 = 0[$r0]
; CV1-NEXT:    ;;
; CV1-NEXT:    maxud $r2 = $r1, $r3
; CV1-NEXT:    ;;
; CV1-NEXT:    acswapd 0[$r0] = $r2r3
; CV1-NEXT:    ;;
; CV1-NEXT:    cb.even $r2 ? .LBB7_1
; CV1-NEXT:    ;;
; CV1-NEXT:  # %bb.2:
; CV1-NEXT:    copyd $r0 = $r3
; CV1-NEXT:    fence
; CV1-NEXT:    ret
; CV1-NEXT:    ;;
;
; CV2-LABEL: f64umax:
; CV2:       # %bb.0:
; CV2-NEXT:    fence
; CV2-NEXT:    ;;
; CV2-NEXT:  .LBB7_1: # =>This Inner Loop Header: Depth=1
; CV2-NEXT:    ld.u $r3 = 0[$r0]
; CV2-NEXT:    ;;
; CV2-NEXT:    maxud $r2 = $r1, $r3
; CV2-NEXT:    ;;
; CV2-NEXT:    acswapd.v $r2, [$r0] = $r2r3
; CV2-NEXT:    ;;
; CV2-NEXT:    cb.even $r2 ? .LBB7_1
; CV2-NEXT:    ;;
; CV2-NEXT:  # %bb.2:
; CV2-NEXT:    copyd $r0 = $r3
; CV2-NEXT:    fence
; CV2-NEXT:    ret
; CV2-NEXT:    ;;
  %res = atomicrmw umax i64 *%src, i64 %b seq_cst
  ret i64 %res
}
