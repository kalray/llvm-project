; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mcpu=kv3-1 -o - %s | FileCheck %s --check-prefixes=V1
; RUN: llc -mcpu=kv3-2 -o - %s | FileCheck %s --check-prefixes=V2
; RUN: clang -c -o /dev/null %s
; RUN: clang -march=kv3-2 -c -o /dev/null %s

target triple = "kvx-kalray-cos"

@_ZTIi = external constant ptr

; This function should be saving both FP and SP
define noundef i32 @main() personality ptr @__gxx_personality_sj0 {
; V1-LABEL: main:
; V1:       .Lfunc_begin0:
; V1-NEXT:  # %bb.0:
; V1-NEXT:    make $r0 = __gxx_personality_sj0
; V1-NEXT:    addd $r12 = $r12, -256
; V1-NEXT:    get $r16 = $ra
; V1-NEXT:    ;; # (end cycle 0)
; V1-NEXT:    sd 248[$r12] = $r16
; V1-NEXT:    make $r1 = 1
; V1-NEXT:    ;; # (end cycle 1)
; V1-NEXT:    sd 240[$r12] = $r14
; V1-NEXT:    addd $r14 = $r12, 240
; V1-NEXT:    ;; # (end cycle 2)
; V1-NEXT:    so 208[$r12] = $r28r29r30r31
; V1-NEXT:    ;; # (end cycle 3)
; V1-NEXT:    so 176[$r12] = $r24r25r26r27
; V1-NEXT:    ;; # (end cycle 4)
; V1-NEXT:    so 144[$r12] = $r20r21r22r23
; V1-NEXT:    ;; # (end cycle 5)
; V1-NEXT:    sq 128[$r12] = $r18r19
; V1-NEXT:    ;; # (end cycle 6)
; V1-NEXT:    sd -168[$r14] = $r0
; V1-NEXT:    make $r0 = GCC_except_table0
; V1-NEXT:    ;; # (end cycle 7)
; V1-NEXT:    sd -160[$r14] = $r0
; V1-NEXT:    make $r0 = .LBB0_2
; V1-NEXT:    ;; # (end cycle 8)
; V1-NEXT:    sd -152[$r14] = $r14
; V1-NEXT:    ;; # (end cycle 9)
; V1-NEXT:    sd -136[$r14] = $r12
; V1-NEXT:    ;; # (end cycle 10)
; V1-NEXT:    sd -144[$r14] = $r0
; V1-NEXT:    make $r0 = 1
; V1-NEXT:    ;; # (end cycle 11)
; V1-NEXT:    sd -224[$r14] = $r0
; V1-NEXT:    addd $r0 = $r14, -216
; V1-NEXT:    ;; # (end cycle 12)
; V1-NEXT:    sd -208[$r14] = $r1
; V1-NEXT:    call _Unwind_SjLj_Register
; V1-NEXT:    ;; # (end cycle 13)
; V1-NEXT:  .Ltmp0:
; V1-NEXT:    call _Z3foov
; V1-NEXT:    ;;
; V1-NEXT:  .Ltmp1:
; V1-NEXT:  .LBB0_1:
; V1-NEXT:    addd $r0 = $r14, -216
; V1-NEXT:    call _Unwind_SjLj_Unregister
; V1-NEXT:    ;; # (end cycle 0)
; V1-NEXT:    ld $r0 = -224[$r14]
; V1-NEXT:    addd $r12 = $r14, -240
; V1-NEXT:    ;; # (end cycle 0)
; V1-NEXT:    lq $r18r19 = 128[$r12]
; V1-NEXT:    ;; # (end cycle 0)
; V1-NEXT:    lo $r20r21r22r23 = 144[$r12]
; V1-NEXT:    ;; # (end cycle 1)
; V1-NEXT:    lo $r24r25r26r27 = 176[$r12]
; V1-NEXT:    ;; # (end cycle 2)
; V1-NEXT:    lo $r28r29r30r31 = 208[$r12]
; V1-NEXT:    ;; # (end cycle 3)
; V1-NEXT:    ld $r14 = 240[$r12]
; V1-NEXT:    ;; # (end cycle 4)
; V1-NEXT:    ld $r16 = 248[$r12]
; V1-NEXT:    ;; # (end cycle 5)
; V1-NEXT:    set $ra = $r16
; V1-NEXT:    addd $r12 = $r12, 256
; V1-NEXT:    ;; # (end cycle 10)
; V1-NEXT:    ret
; V1-NEXT:    ;;
; V1-NEXT:  .LBB0_2:
; V1-NEXT:    nop
; V1-NEXT:    ;;
; V1-NEXT:    ld $r0 = -208[$r14]
; V1-NEXT:    ;; # (end cycle 0)
; V1-NEXT:    compd.gtu $r1 = $r0, 1
; V1-NEXT:    ;; # (end cycle 3)
; V1-NEXT:    cb.odd $r1 ? .LBB0_6
; V1-NEXT:    ;;
; V1-NEXT:  # %bb.3:
; V1-NEXT:    make $r1 = .LJTI0_0
; V1-NEXT:    ;; # (end cycle 0)
; V1-NEXT:    ld.xs $r0 = $r0[$r1]
; V1-NEXT:    ;; # (end cycle 1)
; V1-NEXT:    igoto $r0
; V1-NEXT:    ;;
; V1-NEXT:  .LBB0_4:
; V1-NEXT:  .Ltmp2:
; V1-NEXT:    ld $r0 = -200[$r14]
; V1-NEXT:    ;; # (end cycle 0)
; V1-NEXT:    ld $r1 = -192[$r14]
; V1-NEXT:    ;; # (end cycle 1)
; V1-NEXT:    compw.ne $r1 = $r1, 1
; V1-NEXT:    ;; # (end cycle 4)
; V1-NEXT:    cb.odd $r1 ? .LBB0_7
; V1-NEXT:    ;;
; V1-NEXT:  # %bb.5:
; V1-NEXT:    make $r18 = -1
; V1-NEXT:    ;; # (end cycle 0)
; V1-NEXT:    sd -208[$r14] = $r18
; V1-NEXT:    call __cxa_begin_catch
; V1-NEXT:    ;; # (end cycle 1)
; V1-NEXT:    lwz $r0 = 0[$r0]
; V1-NEXT:    ;; # (end cycle 0)
; V1-NEXT:    sd -224[$r14] = $r0
; V1-NEXT:    ;; # (end cycle 2)
; V1-NEXT:    sd -208[$r14] = $r18
; V1-NEXT:    call __cxa_end_catch
; V1-NEXT:    ;; # (end cycle 3)
; V1-NEXT:    goto .LBB0_1
; V1-NEXT:    ;;
; V1-NEXT:  .LBB0_6:
; V1-NEXT:    errop
; V1-NEXT:    ;;
; V1-NEXT:  .LBB0_7:
; V1-NEXT:    make $r0 = -1
; V1-NEXT:    ;; # (end cycle 0)
; V1-NEXT:    sd -208[$r14] = $r0
; V1-NEXT:    ;; # (end cycle 1)
;
; V2-LABEL: main:
; V2:       .Lfunc_begin0:
; V2-NEXT:  # %bb.0:
; V2-NEXT:    make $r0 = __gxx_personality_sj0
; V2-NEXT:    addd $r12 = $r12, -256
; V2-NEXT:    get $r16 = $ra
; V2-NEXT:    ;; # (end cycle 0)
; V2-NEXT:    sd 248[$r12] = $r16
; V2-NEXT:    make $r1 = 1
; V2-NEXT:    ;; # (end cycle 1)
; V2-NEXT:    sd 240[$r12] = $r14
; V2-NEXT:    addd $r14 = $r12, 240
; V2-NEXT:    ;; # (end cycle 2)
; V2-NEXT:    so 208[$r12] = $r28r29r30r31
; V2-NEXT:    ;; # (end cycle 3)
; V2-NEXT:    so 176[$r12] = $r24r25r26r27
; V2-NEXT:    ;; # (end cycle 4)
; V2-NEXT:    so 144[$r12] = $r20r21r22r23
; V2-NEXT:    ;; # (end cycle 5)
; V2-NEXT:    sq 128[$r12] = $r18r19
; V2-NEXT:    ;; # (end cycle 6)
; V2-NEXT:    sd -168[$r14] = $r0
; V2-NEXT:    make $r0 = GCC_except_table0
; V2-NEXT:    ;; # (end cycle 7)
; V2-NEXT:    sd -160[$r14] = $r0
; V2-NEXT:    make $r0 = .LBB0_2
; V2-NEXT:    ;; # (end cycle 8)
; V2-NEXT:    sd -152[$r14] = $r14
; V2-NEXT:    ;; # (end cycle 9)
; V2-NEXT:    sd -136[$r14] = $r12
; V2-NEXT:    ;; # (end cycle 10)
; V2-NEXT:    sd -144[$r14] = $r0
; V2-NEXT:    make $r0 = 1
; V2-NEXT:    ;; # (end cycle 11)
; V2-NEXT:    sd -224[$r14] = $r0
; V2-NEXT:    addd $r0 = $r14, -216
; V2-NEXT:    ;; # (end cycle 12)
; V2-NEXT:    sd -208[$r14] = $r1
; V2-NEXT:    call _Unwind_SjLj_Register
; V2-NEXT:    ;; # (end cycle 13)
; V2-NEXT:  .Ltmp0:
; V2-NEXT:    call _Z3foov
; V2-NEXT:    ;;
; V2-NEXT:  .Ltmp1:
; V2-NEXT:  .LBB0_1:
; V2-NEXT:    addd $r0 = $r14, -216
; V2-NEXT:    call _Unwind_SjLj_Unregister
; V2-NEXT:    ;; # (end cycle 0)
; V2-NEXT:    ld $r0 = -224[$r14]
; V2-NEXT:    addd $r12 = $r14, -240
; V2-NEXT:    ;; # (end cycle 0)
; V2-NEXT:    lq $r18r19 = 128[$r12]
; V2-NEXT:    ;; # (end cycle 0)
; V2-NEXT:    lo $r20r21r22r23 = 144[$r12]
; V2-NEXT:    ;; # (end cycle 1)
; V2-NEXT:    lo $r24r25r26r27 = 176[$r12]
; V2-NEXT:    ;; # (end cycle 2)
; V2-NEXT:    lo $r28r29r30r31 = 208[$r12]
; V2-NEXT:    ;; # (end cycle 3)
; V2-NEXT:    ld $r14 = 240[$r12]
; V2-NEXT:    ;; # (end cycle 4)
; V2-NEXT:    ld $r16 = 248[$r12]
; V2-NEXT:    ;; # (end cycle 5)
; V2-NEXT:    set $ra = $r16
; V2-NEXT:    addd $r12 = $r12, 256
; V2-NEXT:    ;; # (end cycle 10)
; V2-NEXT:    ret
; V2-NEXT:    ;;
; V2-NEXT:  .LBB0_2:
; V2-NEXT:    nop
; V2-NEXT:    ;;
; V2-NEXT:    ld $r0 = -208[$r14]
; V2-NEXT:    ;; # (end cycle 0)
; V2-NEXT:    compd.gtu $r1 = $r0, 1
; V2-NEXT:    ;; # (end cycle 3)
; V2-NEXT:    cb.odd $r1 ? .LBB0_6
; V2-NEXT:    ;;
; V2-NEXT:  # %bb.3:
; V2-NEXT:    make $r1 = .LJTI0_0
; V2-NEXT:    ;; # (end cycle 0)
; V2-NEXT:    ld.xs $r0 = $r0[$r1]
; V2-NEXT:    ;; # (end cycle 1)
; V2-NEXT:    igoto $r0
; V2-NEXT:    ;;
; V2-NEXT:  .LBB0_4:
; V2-NEXT:  .Ltmp2:
; V2-NEXT:    ld $r0 = -200[$r14]
; V2-NEXT:    ;; # (end cycle 0)
; V2-NEXT:    ld $r1 = -192[$r14]
; V2-NEXT:    ;; # (end cycle 1)
; V2-NEXT:    compw.ne $r1 = $r1, 1
; V2-NEXT:    ;; # (end cycle 4)
; V2-NEXT:    cb.odd $r1 ? .LBB0_7
; V2-NEXT:    ;;
; V2-NEXT:  # %bb.5:
; V2-NEXT:    make $r18 = -1
; V2-NEXT:    ;; # (end cycle 0)
; V2-NEXT:    sd -208[$r14] = $r18
; V2-NEXT:    call __cxa_begin_catch
; V2-NEXT:    ;; # (end cycle 1)
; V2-NEXT:    lwz $r0 = 0[$r0]
; V2-NEXT:    ;; # (end cycle 0)
; V2-NEXT:    sd -224[$r14] = $r0
; V2-NEXT:    ;; # (end cycle 2)
; V2-NEXT:    sd -208[$r14] = $r18
; V2-NEXT:    call __cxa_end_catch
; V2-NEXT:    ;; # (end cycle 3)
; V2-NEXT:    goto .LBB0_1
; V2-NEXT:    ;;
; V2-NEXT:  .LBB0_6:
; V2-NEXT:    errop
; V2-NEXT:    ;;
; V2-NEXT:  .LBB0_7:
; V2-NEXT:    make $r0 = -1
; V2-NEXT:    ;; # (end cycle 0)
; V2-NEXT:    sd -208[$r14] = $r0
; V2-NEXT:    ;; # (end cycle 1)
  invoke void @_Z3foov()
          to label %10 unwind label %1

1:
  %2 = landingpad { ptr, i32 }
          catch ptr @_ZTIi
  %3 = extractvalue { ptr, i32 } %2, 1
  %4 = tail call i32 @llvm.eh.typeid.for(ptr nonnull @_ZTIi)
  %5 = icmp eq i32 %3, %4
  br i1 %5, label %6, label %12

6:
  %7 = extractvalue { ptr, i32 } %2, 0
  %8 = tail call ptr @__cxa_begin_catch(ptr %7)
  %9 = load i32, ptr %8
  tail call void @__cxa_end_catch()
  br label %10

10:
  %11 = phi i32 [ %9, %6 ], [ 1, %0 ]
  ret i32 %11

12:
  resume { ptr, i32 } %2
}

declare void @_Z3foov()

declare i32 @__gxx_personality_sj0(...)

declare i32 @llvm.eh.typeid.for(ptr)

declare ptr @__cxa_begin_catch(ptr) local_unnamed_addr

declare void @__cxa_end_catch() local_unnamed_addr

