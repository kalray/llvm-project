; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -O3 -o - %s | FileCheck %s
; RUN: clang -O3 -c -o /dev/null %s

target triple = "kvx-kalray-cos"

@badfunc.ntfsW = internal constant [5 x i16] [i16 78, i16 84, i16 70, i16 83, i16 0], align 2
@extfunc = global i64 (...)* null, align 8

; Function Attrs: noinline nounwind uwtable
define i32 @badfunc(i32 %0, i32 %1, i32 %2, i32 %3, ptr nocapture %4, i32 %5) {
; CHECK-LABEL: badfunc:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addd $r12 = $r12, 0xffffffffffffeae0
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 0x1518[$r12] = $r16
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    sq 0x1508[$r12] = $r20r21
; CHECK-NEXT:    make $r21 = extfunc
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    sq 0x14f8[$r12] = $r18r19
; CHECK-NEXT:    copyd $r18 = $r4
; CHECK-NEXT:    copyd $r19 = $r5
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    ld $r0 = 0[$r21]
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    icall $r0
; CHECK-NEXT:    ;;
; CHECK-NEXT:    cb.dnez $r0 ? .LBB0_18
; CHECK-NEXT:    make $r20 = 0
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:  # %bb.1:
; CHECK-NEXT:    ld $r0 = 0[$r21]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    icall $r0
; CHECK-NEXT:    ;;
; CHECK-NEXT:    cb.dnez $r0 ? .LBB0_18
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.2:
; CHECK-NEXT:    make $r0 = extfunc
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    addd $r0 = $r12, 20
; CHECK-NEXT:    ld $r1 = 0[$r0]
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    icall $r1
; CHECK-NEXT:    ;;
; CHECK-NEXT:    compw.ltu $r0 = $r19, 2
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    cb.odd $r0 ? .LBB0_15
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.3: # %.preheader
; CHECK-NEXT:    make $r0 = 0
; CHECK-NEXT:    copyd $r1 = $r18
; CHECK-NEXT:    make $r2 = badfunc.ntfsW
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:  .LBB0_4: # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    lhz $r4 = $r2[$r0]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    cb.weqz $r4 ? .LBB0_19
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.5: # in Loop: Header=BB0_4 Depth=1
; CHECK-NEXT:    sh $r0[$r18] = $r4
; CHECK-NEXT:    addw $r3 = $r19, -1
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    compw.gtu $r5 = $r3, 1
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    cb.even $r5 ? .LBB0_20
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.6: # in Loop: Header=BB0_4 Depth=1
; CHECK-NEXT:    addd $r4 = $r0, $r2
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    lhz $r5 = 2[$r4]
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    cb.weqz $r5 ? .LBB0_21
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.7: # in Loop: Header=BB0_4 Depth=1
; CHECK-NEXT:    addw $r3 = $r19, -2
; CHECK-NEXT:    addd $r7 = $r18, $r0
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sh 2[$r7] = $r5
; CHECK-NEXT:    compw.ltu $r6 = $r3, 2
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    cb.odd $r6 ? .LBB0_22
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.8: # in Loop: Header=BB0_4 Depth=1
; CHECK-NEXT:    lhz $r5 = 4[$r4]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    cb.weqz $r5 ? .LBB0_23
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.9: # in Loop: Header=BB0_4 Depth=1
; CHECK-NEXT:    addw $r3 = $r19, -3
; CHECK-NEXT:    addd $r7 = $r18, $r0
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sh 4[$r7] = $r5
; CHECK-NEXT:    compw.ltu $r6 = $r3, 2
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    cb.odd $r6 ? .LBB0_24
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.10: # in Loop: Header=BB0_4 Depth=1
; CHECK-NEXT:    lhz $r5 = 6[$r4]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    cb.weqz $r5 ? .LBB0_25
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.11: # in Loop: Header=BB0_4 Depth=1
; CHECK-NEXT:    addw $r3 = $r19, -4
; CHECK-NEXT:    addd $r7 = $r18, $r0
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sh 6[$r7] = $r5
; CHECK-NEXT:    compw.ltu $r6 = $r3, 2
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    cb.odd $r6 ? .LBB0_26
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.12: # in Loop: Header=BB0_4 Depth=1
; CHECK-NEXT:    lhz $r3 = 8[$r4]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    cb.weqz $r3 ? .LBB0_27
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.13: # in Loop: Header=BB0_4 Depth=1
; CHECK-NEXT:    addd $r0 = $r0, 10
; CHECK-NEXT:    addd $r1 = $r1, 10
; CHECK-NEXT:    addd $r5 = $r18, $r0
; CHECK-NEXT:    addw $r19 = $r19, -5
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sh 8[$r5] = $r3
; CHECK-NEXT:    compw.gtu $r4 = $r19, 1
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    cb.odd $r4 ? .LBB0_4
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.14: # %..loopexit1_crit_edge
; CHECK-NEXT:    addd $r18 = $r18, $r0
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:  .LBB0_15:
; CHECK-NEXT:    copyd $r3 = $r19
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    cb.weqz $r3 ? .LBB0_17
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_16:
; CHECK-NEXT:    make $r0 = 0
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sh 0[$r18] = $r0
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:  .LBB0_17:
; CHECK-NEXT:    make $r20 = 1
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:  .LBB0_18:
; CHECK-NEXT:    lq $r18r19 = 0x14f8[$r12]
; CHECK-NEXT:    copyd $r0 = $r20
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    lq $r20r21 = 0x1508[$r12]
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    ld $r16 = 0x1518[$r12]
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 0x1520
; CHECK-NEXT:    ;; # (end cycle 7)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_19: # %..loopexit_crit_edge
; CHECK-NEXT:    addd $r18 = $r18, $r0
; CHECK-NEXT:    goto .LBB0_16
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:  .LBB0_20: # %.loopexit1splitsplitsplitsplit
; CHECK-NEXT:    cb.wnez $r3 ? .LBB0_16
; CHECK-NEXT:    addd $r18 = $r1, 2
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    goto .LBB0_17
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_21: # %..loopexitsplitsplitsplit_crit_edge
; CHECK-NEXT:    addd $r0 = $r18, $r0
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    addd $r18 = $r0, 2
; CHECK-NEXT:    goto .LBB0_16
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:  .LBB0_22: # %..loopexit1splitsplitsplit_crit_edge
; CHECK-NEXT:    cb.wnez $r3 ? .LBB0_16
; CHECK-NEXT:    addd $r18 = $r1, 4
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    goto .LBB0_17
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_23: # %.loopexitsplitsplitsplitsplit
; CHECK-NEXT:    addd $r0 = $r18, $r0
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    addd $r18 = $r0, 4
; CHECK-NEXT:    goto .LBB0_16
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:  .LBB0_24: # %..loopexit1splitsplit_crit_edge
; CHECK-NEXT:    cb.wnez $r3 ? .LBB0_16
; CHECK-NEXT:    addd $r18 = $r1, 6
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    goto .LBB0_17
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_25: # %..loopexitsplitsplit_crit_edge
; CHECK-NEXT:    addd $r0 = $r18, $r0
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    addd $r18 = $r0, 6
; CHECK-NEXT:    goto .LBB0_16
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:  .LBB0_26: # %..loopexit1split_crit_edge
; CHECK-NEXT:    cb.wnez $r3 ? .LBB0_16
; CHECK-NEXT:    addd $r18 = $r1, 8
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    goto .LBB0_17
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_27: # %..loopexitsplit_crit_edge
; CHECK-NEXT:    addd $r0 = $r18, $r0
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    addd $r18 = $r0, 8
; CHECK-NEXT:    goto .LBB0_16
; CHECK-NEXT:    ;; # (end cycle 1)
  %7 = alloca [5348 x i8], align 1
  %8 = getelementptr inbounds [5348 x i8], ptr %7, i64 0, i64 0
  call void @llvm.lifetime.start.p0i8(i64 5348, ptr nonnull %8) #4
  %9 = load i64 ()*, i64 ()** bitcast (i64 (...)** @extfunc to i64 ()**), align 8, !tbaa !2
  %10 = tail call i64 %9() #4
  %11 = icmp eq i64 %10, 0
  br i1 %11, label %12, label %36

12:                                               ; preds = %6
  %13 = load i64 ()*, i64 ()** bitcast (i64 (...)** @extfunc to i64 ()**), align 8, !tbaa !2
  %14 = tail call i64 %13() #4
  %15 = icmp eq i64 %14, 0
  br i1 %15, label %16, label %36

16:                                               ; preds = %12
  %17 = load i64 (ptr )*, i64 (ptr )** bitcast (i64 (...)** @extfunc to i64 (ptr )**), align 8, !tbaa !2
  %18 = call i64 %17(ptr nonnull %8) #4
  %19 = icmp ugt i32 %5, 1
  br i1 %19, label %20, label %30

20:                                               ; preds = %16, %66
  %21 = phi i32 [ %67, %66 ], [ %5, %16 ]
  %22 = phi ptr [ %69, %66 ], [ %4, %16 ]
  %23 = phi ptr [ %68, %66 ], [ getelementptr inbounds ([5 x i16], ptr @badfunc.ntfsW, i64 0, i64 0), %16 ]
  %24 = load i16, ptr %23, align 2, !tbaa !6
  %25 = icmp eq i16 %24, 0
  br i1 %25, label %34, label %26

26:                                               ; preds = %20
  %27 = add i32 %21, -1
  %28 = getelementptr inbounds i16, ptr %22, i64 1
  store i16 %24, ptr %22, align 2, !tbaa !6
  %29 = icmp ugt i32 %27, 1
  br i1 %29, label %38, label %30, !llvm.loop !8

30:                                               ; preds = %26, %42, %50, %58, %66, %16
  %31 = phi ptr [ %4, %16 ], [ %28, %26 ], [ %44, %42 ], [ %52, %50 ], [ %60, %58 ], [ %69, %66 ]
  %32 = phi i32 [ %5, %16 ], [ %27, %26 ], [ %43, %42 ], [ %51, %50 ], [ %59, %58 ], [ %67, %66 ]
  %33 = icmp eq i32 %32, 0
  br i1 %33, label %36, label %34

34:                                               ; preds = %20, %38, %46, %54, %62, %30
  %35 = phi ptr [ %31, %30 ], [ %22, %20 ], [ %28, %38 ], [ %44, %46 ], [ %52, %54 ], [ %60, %62 ]
  store i16 0, ptr %35, align 2, !tbaa !6
  br label %36

36:                                               ; preds = %34, %30, %12, %6
  %37 = phi i32 [ 0, %6 ], [ 0, %12 ], [ 1, %30 ], [ 1, %34 ]
  call void @llvm.lifetime.end.p0i8(i64 5348, ptr nonnull %8) #4
  ret i32 %37

38:                                               ; preds = %26
  %39 = getelementptr inbounds i16, ptr %23, i64 1
  %40 = load i16, ptr %39, align 2, !tbaa !6
  %41 = icmp eq i16 %40, 0
  br i1 %41, label %34, label %42

42:                                               ; preds = %38
  %43 = add i32 %21, -2
  %44 = getelementptr inbounds i16, ptr %22, i64 2
  store i16 %40, ptr %28, align 2, !tbaa !6
  %45 = icmp ugt i32 %43, 1
  br i1 %45, label %46, label %30, !llvm.loop !8

46:                                               ; preds = %42
  %47 = getelementptr inbounds i16, ptr %23, i64 2
  %48 = load i16, ptr %47, align 2, !tbaa !6
  %49 = icmp eq i16 %48, 0
  br i1 %49, label %34, label %50

50:                                               ; preds = %46
  %51 = add i32 %21, -3
  %52 = getelementptr inbounds i16, ptr %22, i64 3
  store i16 %48, ptr %44, align 2, !tbaa !6
  %53 = icmp ugt i32 %51, 1
  br i1 %53, label %54, label %30, !llvm.loop !8

54:                                               ; preds = %50
  %55 = getelementptr inbounds i16, ptr %23, i64 3
  %56 = load i16, ptr %55, align 2, !tbaa !6
  %57 = icmp eq i16 %56, 0
  br i1 %57, label %34, label %58

58:                                               ; preds = %54
  %59 = add i32 %21, -4
  %60 = getelementptr inbounds i16, ptr %22, i64 4
  store i16 %56, ptr %52, align 2, !tbaa !6
  %61 = icmp ugt i32 %59, 1
  br i1 %61, label %62, label %30, !llvm.loop !8

62:                                               ; preds = %58
  %63 = getelementptr inbounds i16, ptr %23, i64 4
  %64 = load i16, ptr %63, align 2, !tbaa !6
  %65 = icmp eq i16 %64, 0
  br i1 %65, label %34, label %66

66:                                               ; preds = %62
  %67 = add i32 %21, -5
  %68 = getelementptr inbounds i16, ptr %23, i64 5
  %69 = getelementptr inbounds i16, ptr %22, i64 5
  store i16 %64, ptr %60, align 2, !tbaa !6
  %70 = icmp ugt i32 %67, 1
  br i1 %70, label %20, label %30, !llvm.loop !8
}

; Function Attrs: argmemonly nofree nosync nounwind willreturn
declare void @llvm.lifetime.start.p0i8(i64 immarg, ptr nocapture) #1

; Function Attrs: argmemonly nofree nosync nounwind willreturn
declare void @llvm.lifetime.end.p0i8(i64 immarg, ptr nocapture) #1

attributes #1 = { argmemonly nofree nosync nounwind willreturn }
attributes #2 = { nounwind uwtable "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { norecurse nounwind readnone uwtable willreturn "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"Kalray clang version 12.0.1 (git:software/tools/llvm-project 5855f6ef25926c8d5ad4b3922351573205cb8a1e)"}
!2 = !{!3, !3, i64 0}
!3 = !{!"any pointer", !4, i64 0}
!4 = !{!"omnipotent char", !5, i64 0}
!5 = !{!"Simple C/C++ TBAA"}
!6 = !{!7, !7, i64 0}
!7 = !{!"short", !4, i64 0}
!8 = distinct !{!8, !9}
!9 = !{!"llvm.loop.mustprogress"}
