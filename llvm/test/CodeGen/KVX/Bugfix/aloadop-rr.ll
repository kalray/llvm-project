; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mcpu=kv3-1 -O2 -o - %s | FileCheck %s --check-prefixes=CV1
; RUN: llc -mcpu=kv3-2 -O2 -o - %s | FileCheck %s --check-prefixes=CV2
; RUN: clang -O2 -c -o /dev/null %s
; RUN: clang -O2 -march=kv3-2 -c -o /dev/null %s
; ref: T13217

target triple = "kvx-kalray-cos"

@b = common global ptr null, align 8
@a = common global i64 0, align 8
@c = common global ptr null, align 8

define void @foo32() {
; CV1-LABEL: foo32:
; CV1:       # %bb.0: # %entry
; CV1-NEXT:    make $r0 = b
; CV1-NEXT:    make $r1 = a
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    ld $r0 = 0[$r0]
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:    ld $r1 = 0[$r1]
; CV1-NEXT:    ;; # (end cycle 2)
; CV1-NEXT:    fence
; CV1-NEXT:    ;; # (end cycle 3)
; CV1-NEXT:    lwz.xs $r3 = $r1[$r0]
; CV1-NEXT:    ;; # (end cycle 5)
; CV1-NEXT:  .LBB0_1: # %atomicrmw.start
; CV1-NEXT:    # =>This Inner Loop Header: Depth=1
; CV1-NEXT:    copyd $r2 = $r3
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    copyq $r4r5 = $r2, $r3
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:    acswapw.xs $r1[$r0] = $r4r5
; CV1-NEXT:    ;; # (end cycle 2)
; CV1-NEXT:    lwz.u.xs $r2 = $r1[$r0]
; CV1-NEXT:    ;; # (end cycle 3)
; CV1-NEXT:    cmoved.even $r4 ? $r3 = $r2
; CV1-NEXT:    cb.even $r4 ? .LBB0_1
; CV1-NEXT:    ;; # (end cycle 6)
; CV1-NEXT:  # %bb.2: # %atomicrmw.end
; CV1-NEXT:    fence
; CV1-NEXT:    ret
; CV1-NEXT:    ;; # (end cycle 0)
;
; CV2-LABEL: foo32:
; CV2:       # %bb.0: # %entry
; CV2-NEXT:    make $r0 = b
; CV2-NEXT:    make $r1 = a
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    ld $r0 = 0[$r0]
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:    ld $r1 = 0[$r1]
; CV2-NEXT:    ;; # (end cycle 2)
; CV2-NEXT:    fence
; CV2-NEXT:    ;; # (end cycle 3)
; CV2-NEXT:    addx4d $r0 = $r1, $r0
; CV2-NEXT:    lwz.xs $r3 = $r1[$r0]
; CV2-NEXT:    ;; # (end cycle 5)
; CV2-NEXT:  .LBB0_1: # %atomicrmw.start
; CV2-NEXT:    # =>This Inner Loop Header: Depth=1
; CV2-NEXT:    copyd $r2 = $r3
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    acswapw.v $r1, [$r0] = $r2r3
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:    compw.eq $r2 = $r1, $r3
; CV2-NEXT:    copyd $r3 = $r1
; CV2-NEXT:    ;; # (end cycle 4)
; CV2-NEXT:    cb.even $r2 ? .LBB0_1
; CV2-NEXT:    ;;
; CV2-NEXT:  # %bb.2: # %atomicrmw.end
; CV2-NEXT:    fence
; CV2-NEXT:    ret
; CV2-NEXT:    ;; # (end cycle 0)
entry:
  %0 = load ptr, ptr @b, align 8
  %1 = load i64, ptr @a, align 8
  %arrayidx = getelementptr inbounds i32, ptr %0, i64 %1
  %2 = atomicrmw or ptr %arrayidx, i32 0 seq_cst
  ret void
}

define void @foo64() {
; CV1-LABEL: foo64:
; CV1:       # %bb.0: # %entry
; CV1-NEXT:    make $r0 = c
; CV1-NEXT:    make $r1 = a
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    ld $r0 = 0[$r0]
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:    ld $r1 = 0[$r1]
; CV1-NEXT:    ;; # (end cycle 2)
; CV1-NEXT:    fence
; CV1-NEXT:    ;; # (end cycle 3)
; CV1-NEXT:    ld.xs $r3 = $r1[$r0]
; CV1-NEXT:    ;; # (end cycle 5)
; CV1-NEXT:  .LBB1_1: # %atomicrmw.start
; CV1-NEXT:    # =>This Inner Loop Header: Depth=1
; CV1-NEXT:    copyd $r2 = $r3
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    copyq $r4r5 = $r2, $r3
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:    acswapd.xs $r1[$r0] = $r4r5
; CV1-NEXT:    ;; # (end cycle 2)
; CV1-NEXT:    ld.u.xs $r2 = $r1[$r0]
; CV1-NEXT:    ;; # (end cycle 3)
; CV1-NEXT:    cmoved.even $r4 ? $r3 = $r2
; CV1-NEXT:    cb.even $r4 ? .LBB1_1
; CV1-NEXT:    ;; # (end cycle 6)
; CV1-NEXT:  # %bb.2: # %atomicrmw.end
; CV1-NEXT:    fence
; CV1-NEXT:    ret
; CV1-NEXT:    ;; # (end cycle 0)
;
; CV2-LABEL: foo64:
; CV2:       # %bb.0: # %entry
; CV2-NEXT:    make $r0 = c
; CV2-NEXT:    make $r1 = a
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    ld $r0 = 0[$r0]
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:    ld $r1 = 0[$r1]
; CV2-NEXT:    ;; # (end cycle 2)
; CV2-NEXT:    fence
; CV2-NEXT:    ;; # (end cycle 3)
; CV2-NEXT:    addx8d $r0 = $r1, $r0
; CV2-NEXT:    ld.xs $r3 = $r1[$r0]
; CV2-NEXT:    ;; # (end cycle 5)
; CV2-NEXT:  .LBB1_1: # %atomicrmw.start
; CV2-NEXT:    # =>This Inner Loop Header: Depth=1
; CV2-NEXT:    copyd $r2 = $r3
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    acswapd.v $r1, [$r0] = $r2r3
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:    compd.eq $r2 = $r1, $r3
; CV2-NEXT:    copyd $r3 = $r1
; CV2-NEXT:    ;; # (end cycle 4)
; CV2-NEXT:    cb.even $r2 ? .LBB1_1
; CV2-NEXT:    ;;
; CV2-NEXT:  # %bb.2: # %atomicrmw.end
; CV2-NEXT:    fence
; CV2-NEXT:    ret
; CV2-NEXT:    ;; # (end cycle 0)
entry:
  %0 = load ptr, ptr @c, align 8
  %1 = load i64, ptr @a, align 8
  %arrayidx = getelementptr inbounds i64, ptr %0, i64 %1
  %2 = atomicrmw or ptr %arrayidx, i64 0 seq_cst
  ret void
}
