; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -o - %s | FileCheck %s
; RUN: clang -c -o /dev/null %s

target triple = "kvx-kalray-cos"

define i32 @dzerol() {
; CHECK-LABEL: dzerol:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    addd $r12 = $r12, -32
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    dzerol 27[$r12]
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    lwz $r0 = 28[$r12]
; CHECK-NEXT:    addd $r12 = $r12, 32
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 2)
entry:
  %retval = alloca i32, align 4
  %b = alloca [1 x i8], align 1
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %b, i64 0, i64 0
  call void @llvm.kvx.dzerol(i8* %arraydecay)
  %0 = load i32, i32* %retval, align 4
  ret i32 %0
}

define i32 @dinvall() {
; CHECK-LABEL: dinvall:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    addd $r12 = $r12, -32
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    dinvall 27[$r12]
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    lwz $r0 = 28[$r12]
; CHECK-NEXT:    addd $r12 = $r12, 32
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 2)
entry:
%retval = alloca i32, align 4
%b = alloca [1 x i8], align 1
%arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %b, i64 0, i64 0
call void @llvm.kvx.dinvall(i8* %arraydecay)
%0 = load i32, i32* %retval, align 4
ret i32 %0
}

define i32 @dtouchl() {
; CHECK-LABEL: dtouchl:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    addd $r12 = $r12, -32
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    dtouchl 27[$r12]
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    lwz $r0 = 28[$r12]
; CHECK-NEXT:    addd $r12 = $r12, 32
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 2)
entry:
%retval = alloca i32, align 4
%b = alloca [1 x i8], align 1
%arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %b, i64 0, i64 0
call void @llvm.kvx.dtouchl(i8* %arraydecay)
%0 = load i32, i32* %retval, align 4
ret i32 %0
}

define i32 @i1invals() {
; CHECK-LABEL: i1invals:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    addd $r12 = $r12, -32
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    i1invals 27[$r12]
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    lwz $r0 = 28[$r12]
; CHECK-NEXT:    addd $r12 = $r12, 32
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;; # (end cycle 2)
entry:
%retval = alloca i32, align 4
%b = alloca [1 x i8], align 1
%arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %b, i64 0, i64 0
call void @llvm.kvx.i1invals(i8* %arraydecay)
%0 = load i32, i32* %retval, align 4
ret i32 %0
}

declare void @llvm.kvx.dzerol(i8*)
declare void @llvm.kvx.dinvall(i8*)
declare void @llvm.kvx.dtouchl(i8*)
declare void @llvm.kvx.i1invals(i8*)
