; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mcpu=kv3-1 -verify-machineinstrs -O3 -asm-verbose=false -o - %s | FileCheck %s --check-prefixes=CV1
; RUN: llc -mcpu=kv3-2 -verify-machineinstrs -O3 -asm-verbose=false -o - %s | FileCheck %s --check-prefixes=CV2
; RUN: clang -O3 -c -o /dev/null %s
; RUN: clang -march=kv3-2 -O3 -c -o /dev/null %s

; This test is a minimal reproducer for T15045.

; Original C code is:

; void a() {
;   int *b;
;   while (!__sync_bool_compare_and_swap(&b, 0, 0))
;     *(volatile long *)0;
; }

target triple = "kvx-kalray-cos"

define void @_Z1av() {
; CV1-LABEL: _Z1av:
; CV1:         fence
; CV1-NEXT:    make $r0 = 0
; CV1-NEXT:    addd $r12 = $r12, -32
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    copyd $r3 = $r0
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:  .LBB0_1:
; CV1-NEXT:    copyd $r2 = $r0
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    acswapd 24[$r12] = $r2r3
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:    cb.odd $r2 ? .LBB0_3
; CV1-NEXT:    ;;
; CV1-NEXT:    ld.u $r1 = 24[$r12]
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    compd.eq $r2 = $r1, $r3
; CV1-NEXT:    ;; # (end cycle 3)
; CV1-NEXT:    cb.odd $r2 ? .LBB0_1
; CV1-NEXT:    ;;
; CV1-NEXT:    goto .LBB0_4
; CV1-NEXT:    ;;
; CV1-NEXT:  .LBB0_3:
; CV1-NEXT:    copyd $r1 = $r3
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:  .LBB0_4:
; CV1-NEXT:    cb.deqz $r1 ? .LBB0_45
; CV1-NEXT:    ;;
; CV1-NEXT:  .LBB0_5:
; CV1-NEXT:    ld $r1 = 0[$r0]
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    fence
; CV1-NEXT:    copyd $r3 = $r0
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:  .LBB0_6:
; CV1-NEXT:    copyd $r2 = $r0
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    acswapd 24[$r12] = $r2r3
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:    cb.odd $r2 ? .LBB0_8
; CV1-NEXT:    ;;
; CV1-NEXT:    ld.u $r1 = 24[$r12]
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    compd.eq $r2 = $r1, $r3
; CV1-NEXT:    ;; # (end cycle 3)
; CV1-NEXT:    cb.odd $r2 ? .LBB0_6
; CV1-NEXT:    ;;
; CV1-NEXT:    goto .LBB0_9
; CV1-NEXT:    ;;
; CV1-NEXT:  .LBB0_8:
; CV1-NEXT:    copyd $r1 = $r3
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:  .LBB0_9:
; CV1-NEXT:    compd.eq $r1 = $r1, 0
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    compw.ne $r1 = $r1, 1
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:    cb.even $r1 ? .LBB0_45
; CV1-NEXT:    ;;
; CV1-NEXT:    ld $r1 = 0[$r0]
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    fence
; CV1-NEXT:    copyd $r3 = $r0
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:  .LBB0_11:
; CV1-NEXT:    copyd $r2 = $r0
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    acswapd 24[$r12] = $r2r3
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:    cb.odd $r2 ? .LBB0_13
; CV1-NEXT:    ;;
; CV1-NEXT:    ld.u $r1 = 24[$r12]
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    compd.eq $r2 = $r1, $r3
; CV1-NEXT:    ;; # (end cycle 3)
; CV1-NEXT:    cb.odd $r2 ? .LBB0_11
; CV1-NEXT:    ;;
; CV1-NEXT:    goto .LBB0_14
; CV1-NEXT:    ;;
; CV1-NEXT:  .LBB0_13:
; CV1-NEXT:    copyd $r1 = $r3
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:  .LBB0_14:
; CV1-NEXT:    cb.deqz $r1 ? .LBB0_45
; CV1-NEXT:    ;;
; CV1-NEXT:    ld $r1 = 0[$r0]
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    fence
; CV1-NEXT:    copyd $r3 = $r0
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:  .LBB0_16:
; CV1-NEXT:    copyd $r2 = $r0
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    acswapd 24[$r12] = $r2r3
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:    cb.odd $r2 ? .LBB0_18
; CV1-NEXT:    ;;
; CV1-NEXT:    ld.u $r1 = 24[$r12]
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    compd.eq $r2 = $r1, $r3
; CV1-NEXT:    ;; # (end cycle 3)
; CV1-NEXT:    cb.odd $r2 ? .LBB0_16
; CV1-NEXT:    ;;
; CV1-NEXT:    goto .LBB0_19
; CV1-NEXT:    ;;
; CV1-NEXT:  .LBB0_18:
; CV1-NEXT:    copyd $r1 = $r3
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:  .LBB0_19:
; CV1-NEXT:    cb.deqz $r1 ? .LBB0_45
; CV1-NEXT:    ;;
; CV1-NEXT:    ld $r1 = 0[$r0]
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    fence
; CV1-NEXT:    copyd $r3 = $r0
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:  .LBB0_21:
; CV1-NEXT:    copyd $r2 = $r0
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    acswapd 24[$r12] = $r2r3
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:    cb.odd $r2 ? .LBB0_23
; CV1-NEXT:    ;;
; CV1-NEXT:    ld.u $r1 = 24[$r12]
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    compd.eq $r2 = $r1, $r3
; CV1-NEXT:    ;; # (end cycle 3)
; CV1-NEXT:    cb.odd $r2 ? .LBB0_21
; CV1-NEXT:    ;;
; CV1-NEXT:    goto .LBB0_24
; CV1-NEXT:    ;;
; CV1-NEXT:  .LBB0_23:
; CV1-NEXT:    copyd $r1 = $r3
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:  .LBB0_24:
; CV1-NEXT:    cb.deqz $r1 ? .LBB0_45
; CV1-NEXT:    ;;
; CV1-NEXT:    ld $r1 = 0[$r0]
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    fence
; CV1-NEXT:    copyd $r3 = $r0
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:  .LBB0_26:
; CV1-NEXT:    copyd $r2 = $r0
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    acswapd 24[$r12] = $r2r3
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:    cb.odd $r2 ? .LBB0_28
; CV1-NEXT:    ;;
; CV1-NEXT:    ld.u $r1 = 24[$r12]
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    compd.eq $r2 = $r1, $r3
; CV1-NEXT:    ;; # (end cycle 3)
; CV1-NEXT:    cb.odd $r2 ? .LBB0_26
; CV1-NEXT:    ;;
; CV1-NEXT:    goto .LBB0_29
; CV1-NEXT:    ;;
; CV1-NEXT:  .LBB0_28:
; CV1-NEXT:    copyd $r1 = $r3
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:  .LBB0_29:
; CV1-NEXT:    cb.deqz $r1 ? .LBB0_45
; CV1-NEXT:    ;;
; CV1-NEXT:    ld $r1 = 0[$r0]
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    fence
; CV1-NEXT:    copyd $r3 = $r0
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:  .LBB0_31:
; CV1-NEXT:    copyd $r2 = $r0
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    acswapd 24[$r12] = $r2r3
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:    cb.odd $r2 ? .LBB0_33
; CV1-NEXT:    ;;
; CV1-NEXT:    ld.u $r1 = 24[$r12]
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    compd.eq $r2 = $r1, $r3
; CV1-NEXT:    ;; # (end cycle 3)
; CV1-NEXT:    cb.odd $r2 ? .LBB0_31
; CV1-NEXT:    ;;
; CV1-NEXT:    goto .LBB0_34
; CV1-NEXT:    ;;
; CV1-NEXT:  .LBB0_33:
; CV1-NEXT:    copyd $r1 = $r3
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:  .LBB0_34:
; CV1-NEXT:    cb.deqz $r1 ? .LBB0_45
; CV1-NEXT:    ;;
; CV1-NEXT:    ld $r1 = 0[$r0]
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    fence
; CV1-NEXT:    copyd $r3 = $r0
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:  .LBB0_36:
; CV1-NEXT:    copyd $r2 = $r0
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    acswapd 24[$r12] = $r2r3
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:    cb.odd $r2 ? .LBB0_38
; CV1-NEXT:    ;;
; CV1-NEXT:    ld.u $r1 = 24[$r12]
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    compd.eq $r2 = $r1, $r3
; CV1-NEXT:    ;; # (end cycle 3)
; CV1-NEXT:    cb.odd $r2 ? .LBB0_36
; CV1-NEXT:    ;;
; CV1-NEXT:    goto .LBB0_39
; CV1-NEXT:    ;;
; CV1-NEXT:  .LBB0_38:
; CV1-NEXT:    copyd $r1 = $r3
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:  .LBB0_39:
; CV1-NEXT:    cb.deqz $r1 ? .LBB0_45
; CV1-NEXT:    ;;
; CV1-NEXT:    ld $r1 = 0[$r0]
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    fence
; CV1-NEXT:    copyd $r3 = $r0
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:  .LBB0_41:
; CV1-NEXT:    copyd $r2 = $r0
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    acswapd 24[$r12] = $r2r3
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:    cb.odd $r2 ? .LBB0_43
; CV1-NEXT:    ;;
; CV1-NEXT:    ld.u $r1 = 24[$r12]
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    compd.eq $r2 = $r1, $r3
; CV1-NEXT:    ;; # (end cycle 3)
; CV1-NEXT:    cb.odd $r2 ? .LBB0_41
; CV1-NEXT:    ;;
; CV1-NEXT:    goto .LBB0_44
; CV1-NEXT:    ;;
; CV1-NEXT:  .LBB0_43:
; CV1-NEXT:    copyd $r1 = $r3
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:  .LBB0_44:
; CV1-NEXT:    cb.dnez $r1 ? .LBB0_5
; CV1-NEXT:    ;;
; CV1-NEXT:  .LBB0_45:
; CV1-NEXT:    addd $r12 = $r12, 32
; CV1-NEXT:    ret
; CV1-NEXT:    ;; # (end cycle 0)
;
; CV2-LABEL: _Z1av:
; CV2:         fence
; CV2-NEXT:    make $r0 = 0
; CV2-NEXT:    addd $r12 = $r12, -32
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    copyd $r3 = $r0
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:  .LBB0_1:
; CV2-NEXT:    copyd $r2 = $r0
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    acswapd $r2, 24[$r12] = $r2r3
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:    cb.odd $r2 ? .LBB0_3
; CV2-NEXT:    ;;
; CV2-NEXT:    ld.u $r1 = 24[$r12]
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    compd.eq $r2 = $r1, $r3
; CV2-NEXT:    ;; # (end cycle 3)
; CV2-NEXT:    cb.odd $r2 ? .LBB0_1
; CV2-NEXT:    ;;
; CV2-NEXT:    goto .LBB0_4
; CV2-NEXT:    ;;
; CV2-NEXT:  .LBB0_3:
; CV2-NEXT:    copyd $r1 = $r3
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:  .LBB0_4:
; CV2-NEXT:    cb.deqz $r1 ? .LBB0_45
; CV2-NEXT:    ;;
; CV2-NEXT:  .LBB0_5:
; CV2-NEXT:    ld $r1 = 0[$r0]
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    fence
; CV2-NEXT:    copyd $r3 = $r0
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:  .LBB0_6:
; CV2-NEXT:    copyd $r2 = $r0
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    acswapd $r2, 24[$r12] = $r2r3
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:    cb.odd $r2 ? .LBB0_8
; CV2-NEXT:    ;;
; CV2-NEXT:    ld.u $r1 = 24[$r12]
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    compd.eq $r2 = $r1, $r3
; CV2-NEXT:    ;; # (end cycle 3)
; CV2-NEXT:    cb.odd $r2 ? .LBB0_6
; CV2-NEXT:    ;;
; CV2-NEXT:    goto .LBB0_9
; CV2-NEXT:    ;;
; CV2-NEXT:  .LBB0_8:
; CV2-NEXT:    copyd $r1 = $r3
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:  .LBB0_9:
; CV2-NEXT:    compd.eq $r1 = $r1, 0
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    compw.ne $r1 = $r1, 1
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:    cb.even $r1 ? .LBB0_45
; CV2-NEXT:    ;;
; CV2-NEXT:    ld $r1 = 0[$r0]
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    fence
; CV2-NEXT:    copyd $r3 = $r0
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:  .LBB0_11:
; CV2-NEXT:    copyd $r2 = $r0
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    acswapd $r2, 24[$r12] = $r2r3
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:    cb.odd $r2 ? .LBB0_13
; CV2-NEXT:    ;;
; CV2-NEXT:    ld.u $r1 = 24[$r12]
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    compd.eq $r2 = $r1, $r3
; CV2-NEXT:    ;; # (end cycle 3)
; CV2-NEXT:    cb.odd $r2 ? .LBB0_11
; CV2-NEXT:    ;;
; CV2-NEXT:    goto .LBB0_14
; CV2-NEXT:    ;;
; CV2-NEXT:  .LBB0_13:
; CV2-NEXT:    copyd $r1 = $r3
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:  .LBB0_14:
; CV2-NEXT:    cb.deqz $r1 ? .LBB0_45
; CV2-NEXT:    ;;
; CV2-NEXT:    ld $r1 = 0[$r0]
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    fence
; CV2-NEXT:    copyd $r3 = $r0
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:  .LBB0_16:
; CV2-NEXT:    copyd $r2 = $r0
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    acswapd $r2, 24[$r12] = $r2r3
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:    cb.odd $r2 ? .LBB0_18
; CV2-NEXT:    ;;
; CV2-NEXT:    ld.u $r1 = 24[$r12]
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    compd.eq $r2 = $r1, $r3
; CV2-NEXT:    ;; # (end cycle 3)
; CV2-NEXT:    cb.odd $r2 ? .LBB0_16
; CV2-NEXT:    ;;
; CV2-NEXT:    goto .LBB0_19
; CV2-NEXT:    ;;
; CV2-NEXT:  .LBB0_18:
; CV2-NEXT:    copyd $r1 = $r3
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:  .LBB0_19:
; CV2-NEXT:    cb.deqz $r1 ? .LBB0_45
; CV2-NEXT:    ;;
; CV2-NEXT:    ld $r1 = 0[$r0]
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    fence
; CV2-NEXT:    copyd $r3 = $r0
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:  .LBB0_21:
; CV2-NEXT:    copyd $r2 = $r0
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    acswapd $r2, 24[$r12] = $r2r3
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:    cb.odd $r2 ? .LBB0_23
; CV2-NEXT:    ;;
; CV2-NEXT:    ld.u $r1 = 24[$r12]
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    compd.eq $r2 = $r1, $r3
; CV2-NEXT:    ;; # (end cycle 3)
; CV2-NEXT:    cb.odd $r2 ? .LBB0_21
; CV2-NEXT:    ;;
; CV2-NEXT:    goto .LBB0_24
; CV2-NEXT:    ;;
; CV2-NEXT:  .LBB0_23:
; CV2-NEXT:    copyd $r1 = $r3
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:  .LBB0_24:
; CV2-NEXT:    cb.deqz $r1 ? .LBB0_45
; CV2-NEXT:    ;;
; CV2-NEXT:    ld $r1 = 0[$r0]
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    fence
; CV2-NEXT:    copyd $r3 = $r0
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:  .LBB0_26:
; CV2-NEXT:    copyd $r2 = $r0
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    acswapd $r2, 24[$r12] = $r2r3
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:    cb.odd $r2 ? .LBB0_28
; CV2-NEXT:    ;;
; CV2-NEXT:    ld.u $r1 = 24[$r12]
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    compd.eq $r2 = $r1, $r3
; CV2-NEXT:    ;; # (end cycle 3)
; CV2-NEXT:    cb.odd $r2 ? .LBB0_26
; CV2-NEXT:    ;;
; CV2-NEXT:    goto .LBB0_29
; CV2-NEXT:    ;;
; CV2-NEXT:  .LBB0_28:
; CV2-NEXT:    copyd $r1 = $r3
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:  .LBB0_29:
; CV2-NEXT:    cb.deqz $r1 ? .LBB0_45
; CV2-NEXT:    ;;
; CV2-NEXT:    ld $r1 = 0[$r0]
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    fence
; CV2-NEXT:    copyd $r3 = $r0
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:  .LBB0_31:
; CV2-NEXT:    copyd $r2 = $r0
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    acswapd $r2, 24[$r12] = $r2r3
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:    cb.odd $r2 ? .LBB0_33
; CV2-NEXT:    ;;
; CV2-NEXT:    ld.u $r1 = 24[$r12]
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    compd.eq $r2 = $r1, $r3
; CV2-NEXT:    ;; # (end cycle 3)
; CV2-NEXT:    cb.odd $r2 ? .LBB0_31
; CV2-NEXT:    ;;
; CV2-NEXT:    goto .LBB0_34
; CV2-NEXT:    ;;
; CV2-NEXT:  .LBB0_33:
; CV2-NEXT:    copyd $r1 = $r3
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:  .LBB0_34:
; CV2-NEXT:    cb.deqz $r1 ? .LBB0_45
; CV2-NEXT:    ;;
; CV2-NEXT:    ld $r1 = 0[$r0]
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    fence
; CV2-NEXT:    copyd $r3 = $r0
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:  .LBB0_36:
; CV2-NEXT:    copyd $r2 = $r0
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    acswapd $r2, 24[$r12] = $r2r3
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:    cb.odd $r2 ? .LBB0_38
; CV2-NEXT:    ;;
; CV2-NEXT:    ld.u $r1 = 24[$r12]
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    compd.eq $r2 = $r1, $r3
; CV2-NEXT:    ;; # (end cycle 3)
; CV2-NEXT:    cb.odd $r2 ? .LBB0_36
; CV2-NEXT:    ;;
; CV2-NEXT:    goto .LBB0_39
; CV2-NEXT:    ;;
; CV2-NEXT:  .LBB0_38:
; CV2-NEXT:    copyd $r1 = $r3
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:  .LBB0_39:
; CV2-NEXT:    cb.deqz $r1 ? .LBB0_45
; CV2-NEXT:    ;;
; CV2-NEXT:    ld $r1 = 0[$r0]
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    fence
; CV2-NEXT:    copyd $r3 = $r0
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:  .LBB0_41:
; CV2-NEXT:    copyd $r2 = $r0
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    acswapd $r2, 24[$r12] = $r2r3
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:    cb.odd $r2 ? .LBB0_43
; CV2-NEXT:    ;;
; CV2-NEXT:    ld.u $r1 = 24[$r12]
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    compd.eq $r2 = $r1, $r3
; CV2-NEXT:    ;; # (end cycle 3)
; CV2-NEXT:    cb.odd $r2 ? .LBB0_41
; CV2-NEXT:    ;;
; CV2-NEXT:    goto .LBB0_44
; CV2-NEXT:    ;;
; CV2-NEXT:  .LBB0_43:
; CV2-NEXT:    copyd $r1 = $r3
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:  .LBB0_44:
; CV2-NEXT:    cb.dnez $r1 ? .LBB0_5
; CV2-NEXT:    ;;
; CV2-NEXT:  .LBB0_45:
; CV2-NEXT:    addd $r12 = $r12, 32
; CV2-NEXT:    ret
; CV2-NEXT:    ;; # (end cycle 0)
entry:
  %b = alloca i32*, align 8
  %0 = bitcast i32** %b to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %0)
  %1 = bitcast i32** %b to i64*
  %2 = cmpxchg i64* %1, i64 0, i64 0 seq_cst seq_cst
  %3 = extractvalue { i64, i1 } %2, 1
  br i1 %3, label %while.end, label %while.body

while.body:                                       ; preds = %entry, %while.body.7
  %4 = load volatile i64, i64* null, align 536870912
  %5 = cmpxchg i64* %1, i64 0, i64 0 seq_cst seq_cst
  %6 = extractvalue { i64, i1 } %5, 1
  br i1 %6, label %while.end, label %while.body.1

while.end:                                        ; preds = %while.body, %while.body.1, %while.body.2, %while.body.3, %while.body.4, %while.body.5, %while.body.6, %while.body.7, %entry
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %0)
  ret void

while.body.1:                                     ; preds = %while.body
  %7 = load volatile i64, i64* null, align 536870912
  %8 = cmpxchg i64* %1, i64 0, i64 0 seq_cst seq_cst
  %9 = extractvalue { i64, i1 } %8, 1
  br i1 %9, label %while.end, label %while.body.2

while.body.2:                                     ; preds = %while.body.1
  %10 = load volatile i64, i64* null, align 536870912
  %11 = cmpxchg i64* %1, i64 0, i64 0 seq_cst seq_cst
  %12 = extractvalue { i64, i1 } %11, 1
  br i1 %12, label %while.end, label %while.body.3

while.body.3:                                     ; preds = %while.body.2
  %13 = load volatile i64, i64* null, align 536870912
  %14 = cmpxchg i64* %1, i64 0, i64 0 seq_cst seq_cst
  %15 = extractvalue { i64, i1 } %14, 1
  br i1 %15, label %while.end, label %while.body.4

while.body.4:                                     ; preds = %while.body.3
  %16 = load volatile i64, i64* null, align 536870912
  %17 = cmpxchg i64* %1, i64 0, i64 0 seq_cst seq_cst
  %18 = extractvalue { i64, i1 } %17, 1
  br i1 %18, label %while.end, label %while.body.5

while.body.5:                                     ; preds = %while.body.4
  %19 = load volatile i64, i64* null, align 536870912
  %20 = cmpxchg i64* %1, i64 0, i64 0 seq_cst seq_cst
  %21 = extractvalue { i64, i1 } %20, 1
  br i1 %21, label %while.end, label %while.body.6

while.body.6:                                     ; preds = %while.body.5
  %22 = load volatile i64, i64* null, align 536870912
  %23 = cmpxchg i64* %1, i64 0, i64 0 seq_cst seq_cst
  %24 = extractvalue { i64, i1 } %23, 1
  br i1 %24, label %while.end, label %while.body.7

while.body.7:                                     ; preds = %while.body.6
  %25 = load volatile i64, i64* null, align 536870912
  %26 = cmpxchg i64* %1, i64 0, i64 0 seq_cst seq_cst
  %27 = extractvalue { i64, i1 } %26, 1
  br i1 %27, label %while.end, label %while.body
}

declare void @llvm.lifetime.start.p0i8(i64 immarg, i8* nocapture)
declare void @llvm.lifetime.end.p0i8(i64 immarg, i8* nocapture)
