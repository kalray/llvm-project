; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mcpu=kv3-1 -verify-machineinstrs -O3 -asm-verbose=false -o - %s | FileCheck %s --check-prefixes=CV1
; RUN: llc -mcpu=kv3-2 -verify-machineinstrs -O3 -asm-verbose=false -o - %s | FileCheck %s --check-prefixes=CV2
; RUN: clang -O3 -c -o /dev/null %s
; RUN: clang -march=kv3-2 -O3 -c -o /dev/null %s

; This test is a minimal reproducer for T15045.

; Original C code is:

; void a() {
;   int *b;
;   while (!__sync_bool_compare_and_swap(&b, 0, 0))
;     *(volatile long *)0;
; }

target triple = "kvx-kalray-cos"

define void @_Z1av() {
; CV1-LABEL: _Z1av:
; CV1:         fence
; CV1-NEXT:    make $r1 = 0
; CV1-NEXT:    addd $r12 = $r12, -32
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    copyd $r0 = $r1
; CV1-NEXT:    addd $r2 = $r12, 24
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:    copyq $r4r5 = $r0, $r1
; CV1-NEXT:    ;; # (end cycle 2)
; CV1-NEXT:    acswapd 0[$r2] = $r4r5
; CV1-NEXT:    ;; # (end cycle 3)
; CV1-NEXT:    ld.u $r0 = 0[$r2]
; CV1-NEXT:    ;; # (end cycle 4)
; CV1-NEXT:    cb.wnez $r4 ? .LBB0_9
; CV1-NEXT:    ;;
; CV1-NEXT:  .LBB0_1:
; CV1-NEXT:    ld $r0 = 0[$r1]
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    copyd $r0 = $r1
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:    fence
; CV1-NEXT:    copyq $r4r5 = $r0, $r1
; CV1-NEXT:    ;; # (end cycle 2)
; CV1-NEXT:    acswapd 0[$r2] = $r4r5
; CV1-NEXT:    ;; # (end cycle 3)
; CV1-NEXT:    ld.u $r3 = 0[$r2]
; CV1-NEXT:    ;; # (end cycle 4)
; CV1-NEXT:    cb.odd $r4 ? .LBB0_9
; CV1-NEXT:    ;;
; CV1-NEXT:    copyq $r4r5 = $r0, $r1
; CV1-NEXT:    ld $r3 = 0[$r1]
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    fence
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:    acswapd 0[$r2] = $r4r5
; CV1-NEXT:    ;; # (end cycle 2)
; CV1-NEXT:    ld.u $r0 = 0[$r2]
; CV1-NEXT:    ;; # (end cycle 3)
; CV1-NEXT:    cb.wnez $r4 ? .LBB0_9
; CV1-NEXT:    ;;
; CV1-NEXT:    ld $r0 = 0[$r1]
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    copyd $r0 = $r1
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:    fence
; CV1-NEXT:    copyq $r4r5 = $r0, $r1
; CV1-NEXT:    ;; # (end cycle 2)
; CV1-NEXT:    acswapd 0[$r2] = $r4r5
; CV1-NEXT:    ;; # (end cycle 3)
; CV1-NEXT:    ld.u $r3 = 0[$r2]
; CV1-NEXT:    ;; # (end cycle 4)
; CV1-NEXT:    cb.wnez $r4 ? .LBB0_9
; CV1-NEXT:    ;;
; CV1-NEXT:    copyq $r4r5 = $r0, $r1
; CV1-NEXT:    ld $r3 = 0[$r1]
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    fence
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:    acswapd 0[$r2] = $r4r5
; CV1-NEXT:    ;; # (end cycle 2)
; CV1-NEXT:    ld.u $r0 = 0[$r2]
; CV1-NEXT:    ;; # (end cycle 3)
; CV1-NEXT:    cb.wnez $r4 ? .LBB0_9
; CV1-NEXT:    ;;
; CV1-NEXT:    ld $r0 = 0[$r1]
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    copyd $r0 = $r1
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:    fence
; CV1-NEXT:    copyq $r4r5 = $r0, $r1
; CV1-NEXT:    ;; # (end cycle 2)
; CV1-NEXT:    acswapd 0[$r2] = $r4r5
; CV1-NEXT:    ;; # (end cycle 3)
; CV1-NEXT:    ld.u $r3 = 0[$r2]
; CV1-NEXT:    ;; # (end cycle 4)
; CV1-NEXT:    cb.wnez $r4 ? .LBB0_9
; CV1-NEXT:    ;;
; CV1-NEXT:    copyq $r4r5 = $r0, $r1
; CV1-NEXT:    ld $r3 = 0[$r1]
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    fence
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:    acswapd 0[$r2] = $r4r5
; CV1-NEXT:    ;; # (end cycle 2)
; CV1-NEXT:    ld.u $r0 = 0[$r2]
; CV1-NEXT:    ;; # (end cycle 3)
; CV1-NEXT:    cb.wnez $r4 ? .LBB0_9
; CV1-NEXT:    ;;
; CV1-NEXT:    ld $r0 = 0[$r1]
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    copyd $r0 = $r1
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:    fence
; CV1-NEXT:    copyq $r4r5 = $r0, $r1
; CV1-NEXT:    ;; # (end cycle 2)
; CV1-NEXT:    acswapd 0[$r2] = $r4r5
; CV1-NEXT:    ;; # (end cycle 3)
; CV1-NEXT:    ld.u $r3 = 0[$r2]
; CV1-NEXT:    ;; # (end cycle 4)
; CV1-NEXT:    cb.wnez $r4 ? .LBB0_9
; CV1-NEXT:    ;;
; CV1-NEXT:    copyq $r4r5 = $r0, $r1
; CV1-NEXT:    ld $r3 = 0[$r1]
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    fence
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:    acswapd 0[$r2] = $r4r5
; CV1-NEXT:    ;; # (end cycle 2)
; CV1-NEXT:    ld.u $r0 = 0[$r2]
; CV1-NEXT:    ;; # (end cycle 3)
; CV1-NEXT:    cb.weqz $r4 ? .LBB0_1
; CV1-NEXT:    ;;
; CV1-NEXT:  .LBB0_9:
; CV1-NEXT:    addd $r12 = $r12, 32
; CV1-NEXT:    ret
; CV1-NEXT:    ;; # (end cycle 0)
;
; CV2-LABEL: _Z1av:
; CV2:         fence
; CV2-NEXT:    make $r1 = 0
; CV2-NEXT:    addd $r12 = $r12, -32
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    copyd $r0 = $r1
; CV2-NEXT:    addd $r2 = $r12, 24
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:    acswapd $r0, [$r2] = $r0r1
; CV2-NEXT:    ;; # (end cycle 2)
; CV2-NEXT:    ld.u $r3 = 0[$r2]
; CV2-NEXT:    ;; # (end cycle 3)
; CV2-NEXT:    cb.dnez $r0 ? .LBB0_9
; CV2-NEXT:    ;;
; CV2-NEXT:  .LBB0_1:
; CV2-NEXT:    ld $r0 = 0[$r1]
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    fence
; CV2-NEXT:    copyd $r0 = $r1
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:    acswapd $r3, [$r2] = $r0r1
; CV2-NEXT:    ;; # (end cycle 2)
; CV2-NEXT:    ld.u $r4 = 0[$r2]
; CV2-NEXT:    ;; # (end cycle 3)
; CV2-NEXT:    cb.odd $r3 ? .LBB0_9
; CV2-NEXT:    ;;
; CV2-NEXT:    ld $r3 = 0[$r1]
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    fence
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:    acswapd $r0, [$r2] = $r0r1
; CV2-NEXT:    ;; # (end cycle 2)
; CV2-NEXT:    ld.u $r3 = 0[$r2]
; CV2-NEXT:    ;; # (end cycle 3)
; CV2-NEXT:    cb.dnez $r0 ? .LBB0_9
; CV2-NEXT:    ;;
; CV2-NEXT:    ld $r0 = 0[$r1]
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    fence
; CV2-NEXT:    copyd $r0 = $r1
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:    acswapd $r3, [$r2] = $r0r1
; CV2-NEXT:    ;; # (end cycle 2)
; CV2-NEXT:    ld.u $r4 = 0[$r2]
; CV2-NEXT:    ;; # (end cycle 3)
; CV2-NEXT:    cb.dnez $r3 ? .LBB0_9
; CV2-NEXT:    ;;
; CV2-NEXT:    ld $r3 = 0[$r1]
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    fence
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:    acswapd $r0, [$r2] = $r0r1
; CV2-NEXT:    ;; # (end cycle 2)
; CV2-NEXT:    ld.u $r3 = 0[$r2]
; CV2-NEXT:    ;; # (end cycle 3)
; CV2-NEXT:    cb.dnez $r0 ? .LBB0_9
; CV2-NEXT:    ;;
; CV2-NEXT:    ld $r0 = 0[$r1]
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    fence
; CV2-NEXT:    copyd $r0 = $r1
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:    acswapd $r3, [$r2] = $r0r1
; CV2-NEXT:    ;; # (end cycle 2)
; CV2-NEXT:    ld.u $r4 = 0[$r2]
; CV2-NEXT:    ;; # (end cycle 3)
; CV2-NEXT:    cb.dnez $r3 ? .LBB0_9
; CV2-NEXT:    ;;
; CV2-NEXT:    ld $r3 = 0[$r1]
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    fence
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:    acswapd $r0, [$r2] = $r0r1
; CV2-NEXT:    ;; # (end cycle 2)
; CV2-NEXT:    ld.u $r3 = 0[$r2]
; CV2-NEXT:    ;; # (end cycle 3)
; CV2-NEXT:    cb.dnez $r0 ? .LBB0_9
; CV2-NEXT:    ;;
; CV2-NEXT:    ld $r0 = 0[$r1]
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    fence
; CV2-NEXT:    copyd $r0 = $r1
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:    acswapd $r3, [$r2] = $r0r1
; CV2-NEXT:    ;; # (end cycle 2)
; CV2-NEXT:    ld.u $r4 = 0[$r2]
; CV2-NEXT:    ;; # (end cycle 3)
; CV2-NEXT:    cb.dnez $r3 ? .LBB0_9
; CV2-NEXT:    ;;
; CV2-NEXT:    ld $r3 = 0[$r1]
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    fence
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:    acswapd $r0, [$r2] = $r0r1
; CV2-NEXT:    ;; # (end cycle 2)
; CV2-NEXT:    ld.u $r3 = 0[$r2]
; CV2-NEXT:    ;; # (end cycle 3)
; CV2-NEXT:    cb.deqz $r0 ? .LBB0_1
; CV2-NEXT:    ;;
; CV2-NEXT:  .LBB0_9:
; CV2-NEXT:    addd $r12 = $r12, 32
; CV2-NEXT:    ret
; CV2-NEXT:    ;; # (end cycle 0)
entry:
  %b = alloca ptr, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %b)
  %0 = cmpxchg ptr %b, i64 0, i64 0 seq_cst seq_cst, align 8
  %1 = extractvalue { i64, i1 } %0, 1
  br i1 %1, label %while.end, label %while.body

while.body:
  %2 = load volatile i64, ptr null, align 4294967296
  %3 = cmpxchg ptr %b, i64 0, i64 0 seq_cst seq_cst, align 8
  %4 = extractvalue { i64, i1 } %3, 1
  br i1 %4, label %while.end, label %while.body.1

while.end:
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %b)
  ret void

while.body.1:
  %5 = load volatile i64, ptr null, align 4294967296
  %6 = cmpxchg ptr %b, i64 0, i64 0 seq_cst seq_cst, align 8
  %7 = extractvalue { i64, i1 } %6, 1
  br i1 %7, label %while.end, label %while.body.2

while.body.2:
  %8 = load volatile i64, ptr null, align 4294967296
  %9 = cmpxchg ptr %b, i64 0, i64 0 seq_cst seq_cst, align 8
  %10 = extractvalue { i64, i1 } %9, 1
  br i1 %10, label %while.end, label %while.body.3

while.body.3:
  %11 = load volatile i64, ptr null, align 4294967296
  %12 = cmpxchg ptr %b, i64 0, i64 0 seq_cst seq_cst, align 8
  %13 = extractvalue { i64, i1 } %12, 1
  br i1 %13, label %while.end, label %while.body.4

while.body.4:
  %14 = load volatile i64, ptr null, align 4294967296
  %15 = cmpxchg ptr %b, i64 0, i64 0 seq_cst seq_cst, align 8
  %16 = extractvalue { i64, i1 } %15, 1
  br i1 %16, label %while.end, label %while.body.5

while.body.5:
  %17 = load volatile i64, ptr null, align 4294967296
  %18 = cmpxchg ptr %b, i64 0, i64 0 seq_cst seq_cst, align 8
  %19 = extractvalue { i64, i1 } %18, 1
  br i1 %19, label %while.end, label %while.body.6

while.body.6:
  %20 = load volatile i64, ptr null, align 4294967296
  %21 = cmpxchg ptr %b, i64 0, i64 0 seq_cst seq_cst, align 8
  %22 = extractvalue { i64, i1 } %21, 1
  br i1 %22, label %while.end, label %while.body.7

while.body.7:
  %23 = load volatile i64, ptr null, align 4294967296
  %24 = cmpxchg ptr %b, i64 0, i64 0 seq_cst seq_cst, align 8
  %25 = extractvalue { i64, i1 } %24, 1
  br i1 %25, label %while.end, label %while.body
}

declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture)

declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture)

