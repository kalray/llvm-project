; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mcpu=kv3-1 -verify-machineinstrs -O3 -asm-verbose=false -o - %s | FileCheck %s --check-prefixes=CV1
; RUN: llc -mcpu=kv3-2 -verify-machineinstrs -O3 -asm-verbose=false -o - %s | FileCheck %s --check-prefixes=CV2
; RUN: clang -O3 -c -o /dev/null %s
; RUN: clang -march=kv3-2 -O3 -c -o /dev/null %s

; This test is a minimal reproducer for T15045.

; Original C code is:

; void a() {
;   int *b;
;   while (!__sync_bool_compare_and_swap(&b, 0, 0))
;     *(volatile long *)0;
; }

target triple = "kvx-kalray-cos"

define void @_Z1av() {
; CV1-LABEL: _Z1av:
; CV1:         fence
; CV1-NEXT:    make $r0 = 0
; CV1-NEXT:    addd $r12 = $r12, -32
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    copyd $r3 = $r0
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:  .LBB0_1:
; CV1-NEXT:    copyd $r2 = $r0
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    acswapd 24[$r12] = $r2r3
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:    cb.odd $r2 ? .LBB0_3
; CV1-NEXT:    ;;
; CV1-NEXT:    ld.u $r1 = 24[$r12]
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    compd.eq $r2 = $r1, $r3
; CV1-NEXT:    ;; # (end cycle 3)
; CV1-NEXT:    cb.odd $r2 ? .LBB0_1
; CV1-NEXT:    ;;
; CV1-NEXT:    goto .LBB0_4
; CV1-NEXT:    ;;
; CV1-NEXT:  .LBB0_3:
; CV1-NEXT:    copyd $r1 = $r3
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:  .LBB0_4:
; CV1-NEXT:    cb.deqz $r1 ? .LBB0_45
; CV1-NEXT:    ;;
; CV1-NEXT:  .LBB0_5:
; CV1-NEXT:    ld $r1 = 0[$r0]
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    fence
; CV1-NEXT:    copyd $r3 = $r0
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:  .LBB0_6:
; CV1-NEXT:    copyd $r2 = $r0
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    acswapd 24[$r12] = $r2r3
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:    cb.odd $r2 ? .LBB0_8
; CV1-NEXT:    ;;
; CV1-NEXT:    ld.u $r1 = 24[$r12]
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    compd.eq $r2 = $r1, $r3
; CV1-NEXT:    ;; # (end cycle 3)
; CV1-NEXT:    cb.odd $r2 ? .LBB0_6
; CV1-NEXT:    ;;
; CV1-NEXT:    goto .LBB0_9
; CV1-NEXT:    ;;
; CV1-NEXT:  .LBB0_8:
; CV1-NEXT:    copyd $r1 = $r3
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:  .LBB0_9:
; CV1-NEXT:    compd.eq $r1 = $r1, 0
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    compw.ne $r1 = $r1, 1
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:    cb.even $r1 ? .LBB0_45
; CV1-NEXT:    ;;
; CV1-NEXT:    ld $r1 = 0[$r0]
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    fence
; CV1-NEXT:    copyd $r3 = $r0
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:  .LBB0_11:
; CV1-NEXT:    copyd $r2 = $r0
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    acswapd 24[$r12] = $r2r3
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:    cb.odd $r2 ? .LBB0_13
; CV1-NEXT:    ;;
; CV1-NEXT:    ld.u $r1 = 24[$r12]
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    compd.eq $r2 = $r1, $r3
; CV1-NEXT:    ;; # (end cycle 3)
; CV1-NEXT:    cb.odd $r2 ? .LBB0_11
; CV1-NEXT:    ;;
; CV1-NEXT:    goto .LBB0_14
; CV1-NEXT:    ;;
; CV1-NEXT:  .LBB0_13:
; CV1-NEXT:    copyd $r1 = $r3
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:  .LBB0_14:
; CV1-NEXT:    cb.deqz $r1 ? .LBB0_45
; CV1-NEXT:    ;;
; CV1-NEXT:    ld $r1 = 0[$r0]
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    fence
; CV1-NEXT:    copyd $r3 = $r0
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:  .LBB0_16:
; CV1-NEXT:    copyd $r2 = $r0
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    acswapd 24[$r12] = $r2r3
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:    cb.odd $r2 ? .LBB0_18
; CV1-NEXT:    ;;
; CV1-NEXT:    ld.u $r1 = 24[$r12]
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    compd.eq $r2 = $r1, $r3
; CV1-NEXT:    ;; # (end cycle 3)
; CV1-NEXT:    cb.odd $r2 ? .LBB0_16
; CV1-NEXT:    ;;
; CV1-NEXT:    goto .LBB0_19
; CV1-NEXT:    ;;
; CV1-NEXT:  .LBB0_18:
; CV1-NEXT:    copyd $r1 = $r3
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:  .LBB0_19:
; CV1-NEXT:    cb.deqz $r1 ? .LBB0_45
; CV1-NEXT:    ;;
; CV1-NEXT:    ld $r1 = 0[$r0]
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    fence
; CV1-NEXT:    copyd $r3 = $r0
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:  .LBB0_21:
; CV1-NEXT:    copyd $r2 = $r0
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    acswapd 24[$r12] = $r2r3
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:    cb.odd $r2 ? .LBB0_23
; CV1-NEXT:    ;;
; CV1-NEXT:    ld.u $r1 = 24[$r12]
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    compd.eq $r2 = $r1, $r3
; CV1-NEXT:    ;; # (end cycle 3)
; CV1-NEXT:    cb.odd $r2 ? .LBB0_21
; CV1-NEXT:    ;;
; CV1-NEXT:    goto .LBB0_24
; CV1-NEXT:    ;;
; CV1-NEXT:  .LBB0_23:
; CV1-NEXT:    copyd $r1 = $r3
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:  .LBB0_24:
; CV1-NEXT:    cb.deqz $r1 ? .LBB0_45
; CV1-NEXT:    ;;
; CV1-NEXT:    ld $r1 = 0[$r0]
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    fence
; CV1-NEXT:    copyd $r3 = $r0
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:  .LBB0_26:
; CV1-NEXT:    copyd $r2 = $r0
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    acswapd 24[$r12] = $r2r3
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:    cb.odd $r2 ? .LBB0_28
; CV1-NEXT:    ;;
; CV1-NEXT:    ld.u $r1 = 24[$r12]
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    compd.eq $r2 = $r1, $r3
; CV1-NEXT:    ;; # (end cycle 3)
; CV1-NEXT:    cb.odd $r2 ? .LBB0_26
; CV1-NEXT:    ;;
; CV1-NEXT:    goto .LBB0_29
; CV1-NEXT:    ;;
; CV1-NEXT:  .LBB0_28:
; CV1-NEXT:    copyd $r1 = $r3
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:  .LBB0_29:
; CV1-NEXT:    cb.deqz $r1 ? .LBB0_45
; CV1-NEXT:    ;;
; CV1-NEXT:    ld $r1 = 0[$r0]
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    fence
; CV1-NEXT:    copyd $r3 = $r0
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:  .LBB0_31:
; CV1-NEXT:    copyd $r2 = $r0
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    acswapd 24[$r12] = $r2r3
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:    cb.odd $r2 ? .LBB0_33
; CV1-NEXT:    ;;
; CV1-NEXT:    ld.u $r1 = 24[$r12]
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    compd.eq $r2 = $r1, $r3
; CV1-NEXT:    ;; # (end cycle 3)
; CV1-NEXT:    cb.odd $r2 ? .LBB0_31
; CV1-NEXT:    ;;
; CV1-NEXT:    goto .LBB0_34
; CV1-NEXT:    ;;
; CV1-NEXT:  .LBB0_33:
; CV1-NEXT:    copyd $r1 = $r3
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:  .LBB0_34:
; CV1-NEXT:    cb.deqz $r1 ? .LBB0_45
; CV1-NEXT:    ;;
; CV1-NEXT:    ld $r1 = 0[$r0]
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    fence
; CV1-NEXT:    copyd $r3 = $r0
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:  .LBB0_36:
; CV1-NEXT:    copyd $r2 = $r0
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    acswapd 24[$r12] = $r2r3
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:    cb.odd $r2 ? .LBB0_38
; CV1-NEXT:    ;;
; CV1-NEXT:    ld.u $r1 = 24[$r12]
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    compd.eq $r2 = $r1, $r3
; CV1-NEXT:    ;; # (end cycle 3)
; CV1-NEXT:    cb.odd $r2 ? .LBB0_36
; CV1-NEXT:    ;;
; CV1-NEXT:    goto .LBB0_39
; CV1-NEXT:    ;;
; CV1-NEXT:  .LBB0_38:
; CV1-NEXT:    copyd $r1 = $r3
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:  .LBB0_39:
; CV1-NEXT:    cb.deqz $r1 ? .LBB0_45
; CV1-NEXT:    ;;
; CV1-NEXT:    ld $r1 = 0[$r0]
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    fence
; CV1-NEXT:    copyd $r3 = $r0
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:  .LBB0_41:
; CV1-NEXT:    copyd $r2 = $r0
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    acswapd 24[$r12] = $r2r3
; CV1-NEXT:    ;; # (end cycle 1)
; CV1-NEXT:    cb.odd $r2 ? .LBB0_43
; CV1-NEXT:    ;;
; CV1-NEXT:    ld.u $r1 = 24[$r12]
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:    compd.eq $r2 = $r1, $r3
; CV1-NEXT:    ;; # (end cycle 3)
; CV1-NEXT:    cb.odd $r2 ? .LBB0_41
; CV1-NEXT:    ;;
; CV1-NEXT:    goto .LBB0_44
; CV1-NEXT:    ;;
; CV1-NEXT:  .LBB0_43:
; CV1-NEXT:    copyd $r1 = $r3
; CV1-NEXT:    ;; # (end cycle 0)
; CV1-NEXT:  .LBB0_44:
; CV1-NEXT:    cb.dnez $r1 ? .LBB0_5
; CV1-NEXT:    ;;
; CV1-NEXT:  .LBB0_45:
; CV1-NEXT:    addd $r12 = $r12, 32
; CV1-NEXT:    ret
; CV1-NEXT:    ;; # (end cycle 0)
;
; CV2-LABEL: _Z1av:
; CV2:         fence
; CV2-NEXT:    make $r0 = 0
; CV2-NEXT:    addd $r12 = $r12, -32
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    copyd $r3 = $r0
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:  .LBB0_1:
; CV2-NEXT:    copyd $r2 = $r0
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    acswapd $r2, 24[$r12] = $r2r3
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:    cb.odd $r2 ? .LBB0_3
; CV2-NEXT:    ;;
; CV2-NEXT:    ld.u $r1 = 24[$r12]
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    compd.eq $r2 = $r1, $r3
; CV2-NEXT:    ;; # (end cycle 3)
; CV2-NEXT:    cb.odd $r2 ? .LBB0_1
; CV2-NEXT:    ;;
; CV2-NEXT:    goto .LBB0_4
; CV2-NEXT:    ;;
; CV2-NEXT:  .LBB0_3:
; CV2-NEXT:    copyd $r1 = $r3
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:  .LBB0_4:
; CV2-NEXT:    cb.deqz $r1 ? .LBB0_45
; CV2-NEXT:    ;;
; CV2-NEXT:  .LBB0_5:
; CV2-NEXT:    ld $r1 = 0[$r0]
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    fence
; CV2-NEXT:    copyd $r3 = $r0
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:  .LBB0_6:
; CV2-NEXT:    copyd $r2 = $r0
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    acswapd $r2, 24[$r12] = $r2r3
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:    cb.odd $r2 ? .LBB0_8
; CV2-NEXT:    ;;
; CV2-NEXT:    ld.u $r1 = 24[$r12]
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    compd.eq $r2 = $r1, $r3
; CV2-NEXT:    ;; # (end cycle 3)
; CV2-NEXT:    cb.odd $r2 ? .LBB0_6
; CV2-NEXT:    ;;
; CV2-NEXT:    goto .LBB0_9
; CV2-NEXT:    ;;
; CV2-NEXT:  .LBB0_8:
; CV2-NEXT:    copyd $r1 = $r3
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:  .LBB0_9:
; CV2-NEXT:    compd.eq $r1 = $r1, 0
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    compw.ne $r1 = $r1, 1
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:    cb.even $r1 ? .LBB0_45
; CV2-NEXT:    ;;
; CV2-NEXT:    ld $r1 = 0[$r0]
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    fence
; CV2-NEXT:    copyd $r3 = $r0
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:  .LBB0_11:
; CV2-NEXT:    copyd $r2 = $r0
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    acswapd $r2, 24[$r12] = $r2r3
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:    cb.odd $r2 ? .LBB0_13
; CV2-NEXT:    ;;
; CV2-NEXT:    ld.u $r1 = 24[$r12]
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    compd.eq $r2 = $r1, $r3
; CV2-NEXT:    ;; # (end cycle 3)
; CV2-NEXT:    cb.odd $r2 ? .LBB0_11
; CV2-NEXT:    ;;
; CV2-NEXT:    goto .LBB0_14
; CV2-NEXT:    ;;
; CV2-NEXT:  .LBB0_13:
; CV2-NEXT:    copyd $r1 = $r3
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:  .LBB0_14:
; CV2-NEXT:    cb.deqz $r1 ? .LBB0_45
; CV2-NEXT:    ;;
; CV2-NEXT:    ld $r1 = 0[$r0]
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    fence
; CV2-NEXT:    copyd $r3 = $r0
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:  .LBB0_16:
; CV2-NEXT:    copyd $r2 = $r0
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    acswapd $r2, 24[$r12] = $r2r3
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:    cb.odd $r2 ? .LBB0_18
; CV2-NEXT:    ;;
; CV2-NEXT:    ld.u $r1 = 24[$r12]
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    compd.eq $r2 = $r1, $r3
; CV2-NEXT:    ;; # (end cycle 3)
; CV2-NEXT:    cb.odd $r2 ? .LBB0_16
; CV2-NEXT:    ;;
; CV2-NEXT:    goto .LBB0_19
; CV2-NEXT:    ;;
; CV2-NEXT:  .LBB0_18:
; CV2-NEXT:    copyd $r1 = $r3
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:  .LBB0_19:
; CV2-NEXT:    cb.deqz $r1 ? .LBB0_45
; CV2-NEXT:    ;;
; CV2-NEXT:    ld $r1 = 0[$r0]
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    fence
; CV2-NEXT:    copyd $r3 = $r0
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:  .LBB0_21:
; CV2-NEXT:    copyd $r2 = $r0
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    acswapd $r2, 24[$r12] = $r2r3
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:    cb.odd $r2 ? .LBB0_23
; CV2-NEXT:    ;;
; CV2-NEXT:    ld.u $r1 = 24[$r12]
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    compd.eq $r2 = $r1, $r3
; CV2-NEXT:    ;; # (end cycle 3)
; CV2-NEXT:    cb.odd $r2 ? .LBB0_21
; CV2-NEXT:    ;;
; CV2-NEXT:    goto .LBB0_24
; CV2-NEXT:    ;;
; CV2-NEXT:  .LBB0_23:
; CV2-NEXT:    copyd $r1 = $r3
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:  .LBB0_24:
; CV2-NEXT:    cb.deqz $r1 ? .LBB0_45
; CV2-NEXT:    ;;
; CV2-NEXT:    ld $r1 = 0[$r0]
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    fence
; CV2-NEXT:    copyd $r3 = $r0
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:  .LBB0_26:
; CV2-NEXT:    copyd $r2 = $r0
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    acswapd $r2, 24[$r12] = $r2r3
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:    cb.odd $r2 ? .LBB0_28
; CV2-NEXT:    ;;
; CV2-NEXT:    ld.u $r1 = 24[$r12]
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    compd.eq $r2 = $r1, $r3
; CV2-NEXT:    ;; # (end cycle 3)
; CV2-NEXT:    cb.odd $r2 ? .LBB0_26
; CV2-NEXT:    ;;
; CV2-NEXT:    goto .LBB0_29
; CV2-NEXT:    ;;
; CV2-NEXT:  .LBB0_28:
; CV2-NEXT:    copyd $r1 = $r3
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:  .LBB0_29:
; CV2-NEXT:    cb.deqz $r1 ? .LBB0_45
; CV2-NEXT:    ;;
; CV2-NEXT:    ld $r1 = 0[$r0]
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    fence
; CV2-NEXT:    copyd $r3 = $r0
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:  .LBB0_31:
; CV2-NEXT:    copyd $r2 = $r0
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    acswapd $r2, 24[$r12] = $r2r3
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:    cb.odd $r2 ? .LBB0_33
; CV2-NEXT:    ;;
; CV2-NEXT:    ld.u $r1 = 24[$r12]
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    compd.eq $r2 = $r1, $r3
; CV2-NEXT:    ;; # (end cycle 3)
; CV2-NEXT:    cb.odd $r2 ? .LBB0_31
; CV2-NEXT:    ;;
; CV2-NEXT:    goto .LBB0_34
; CV2-NEXT:    ;;
; CV2-NEXT:  .LBB0_33:
; CV2-NEXT:    copyd $r1 = $r3
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:  .LBB0_34:
; CV2-NEXT:    cb.deqz $r1 ? .LBB0_45
; CV2-NEXT:    ;;
; CV2-NEXT:    ld $r1 = 0[$r0]
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    fence
; CV2-NEXT:    copyd $r3 = $r0
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:  .LBB0_36:
; CV2-NEXT:    copyd $r2 = $r0
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    acswapd $r2, 24[$r12] = $r2r3
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:    cb.odd $r2 ? .LBB0_38
; CV2-NEXT:    ;;
; CV2-NEXT:    ld.u $r1 = 24[$r12]
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    compd.eq $r2 = $r1, $r3
; CV2-NEXT:    ;; # (end cycle 3)
; CV2-NEXT:    cb.odd $r2 ? .LBB0_36
; CV2-NEXT:    ;;
; CV2-NEXT:    goto .LBB0_39
; CV2-NEXT:    ;;
; CV2-NEXT:  .LBB0_38:
; CV2-NEXT:    copyd $r1 = $r3
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:  .LBB0_39:
; CV2-NEXT:    cb.deqz $r1 ? .LBB0_45
; CV2-NEXT:    ;;
; CV2-NEXT:    ld $r1 = 0[$r0]
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    fence
; CV2-NEXT:    copyd $r3 = $r0
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:  .LBB0_41:
; CV2-NEXT:    copyd $r2 = $r0
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    acswapd $r2, 24[$r12] = $r2r3
; CV2-NEXT:    ;; # (end cycle 1)
; CV2-NEXT:    cb.odd $r2 ? .LBB0_43
; CV2-NEXT:    ;;
; CV2-NEXT:    ld.u $r1 = 24[$r12]
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:    compd.eq $r2 = $r1, $r3
; CV2-NEXT:    ;; # (end cycle 3)
; CV2-NEXT:    cb.odd $r2 ? .LBB0_41
; CV2-NEXT:    ;;
; CV2-NEXT:    goto .LBB0_44
; CV2-NEXT:    ;;
; CV2-NEXT:  .LBB0_43:
; CV2-NEXT:    copyd $r1 = $r3
; CV2-NEXT:    ;; # (end cycle 0)
; CV2-NEXT:  .LBB0_44:
; CV2-NEXT:    cb.dnez $r1 ? .LBB0_5
; CV2-NEXT:    ;;
; CV2-NEXT:  .LBB0_45:
; CV2-NEXT:    addd $r12 = $r12, 32
; CV2-NEXT:    ret
; CV2-NEXT:    ;; # (end cycle 0)
entry:
  %b = alloca ptr, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %b)
  %0 = cmpxchg ptr %b, i64 0, i64 0 seq_cst seq_cst, align 8
  %1 = extractvalue { i64, i1 } %0, 1
  br i1 %1, label %while.end, label %while.body

while.body:
  %2 = load volatile i64, ptr null, align 4294967296
  %3 = cmpxchg ptr %b, i64 0, i64 0 seq_cst seq_cst, align 8
  %4 = extractvalue { i64, i1 } %3, 1
  br i1 %4, label %while.end, label %while.body.1

while.end:
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %b)
  ret void

while.body.1:
  %5 = load volatile i64, ptr null, align 4294967296
  %6 = cmpxchg ptr %b, i64 0, i64 0 seq_cst seq_cst, align 8
  %7 = extractvalue { i64, i1 } %6, 1
  br i1 %7, label %while.end, label %while.body.2

while.body.2:
  %8 = load volatile i64, ptr null, align 4294967296
  %9 = cmpxchg ptr %b, i64 0, i64 0 seq_cst seq_cst, align 8
  %10 = extractvalue { i64, i1 } %9, 1
  br i1 %10, label %while.end, label %while.body.3

while.body.3:
  %11 = load volatile i64, ptr null, align 4294967296
  %12 = cmpxchg ptr %b, i64 0, i64 0 seq_cst seq_cst, align 8
  %13 = extractvalue { i64, i1 } %12, 1
  br i1 %13, label %while.end, label %while.body.4

while.body.4:
  %14 = load volatile i64, ptr null, align 4294967296
  %15 = cmpxchg ptr %b, i64 0, i64 0 seq_cst seq_cst, align 8
  %16 = extractvalue { i64, i1 } %15, 1
  br i1 %16, label %while.end, label %while.body.5

while.body.5:
  %17 = load volatile i64, ptr null, align 4294967296
  %18 = cmpxchg ptr %b, i64 0, i64 0 seq_cst seq_cst, align 8
  %19 = extractvalue { i64, i1 } %18, 1
  br i1 %19, label %while.end, label %while.body.6

while.body.6:
  %20 = load volatile i64, ptr null, align 4294967296
  %21 = cmpxchg ptr %b, i64 0, i64 0 seq_cst seq_cst, align 8
  %22 = extractvalue { i64, i1 } %21, 1
  br i1 %22, label %while.end, label %while.body.7

while.body.7:
  %23 = load volatile i64, ptr null, align 4294967296
  %24 = cmpxchg ptr %b, i64 0, i64 0 seq_cst seq_cst, align 8
  %25 = extractvalue { i64, i1 } %24, 1
  br i1 %25, label %while.end, label %while.body
}

declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture)

declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture)

