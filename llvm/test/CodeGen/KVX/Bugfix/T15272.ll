; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -relocation-model=pic -o - %s | FileCheck %s --check-prefixes=CHECK
; RUN: llc -mcpu=kv3-2 -relocation-model=pic -o - %s -mtriple=kvx-kalray-cos | FileCheck %s --check-prefixes=CHECK
; RUN: clang -c -o /dev/null %s -mllvm -relocation-model=pic
; RUN: clang -march=kv3-2 -c -o /dev/null %s -mllvm -relocation-model=pic

target triple = "kvx-kalray-cos"

; reduced testcase from T15272

%struct.f = type { [16 x %struct.a] }
%struct.a = type { %class.g }
%class.g = type { i8 }

$_ZN1fILi16EEC2Ev = comdat any

$_ZN1aC2Ev = comdat any

define void @_Z1iv() {
; CHECK-LABEL: _Z1iv:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addd $r12 = $r12, -32
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 24[$r12] = $r16
; CHECK-NEXT:    addd $r0 = $r12, 8
; CHECK-NEXT:    call _ZN1fILi16EEC2Ev
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    ld $r16 = 24[$r12]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 32
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %1 = alloca %struct.f, align 1
  call void @_ZN1fILi16EEC2Ev(%struct.f* %1)
  ret void
}

define linkonce_odr void @_ZN1fILi16EEC2Ev(%struct.f* %0) comdat align 2 {
; CHECK-LABEL: _ZN1fILi16EEC2Ev:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addd $r12 = $r12, -32
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 24[$r12] = $r16
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    sq 8[$r12] = $r18r19
; CHECK-NEXT:    copyd $r18 = $r0
; CHECK-NEXT:    make $r19 = 16
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    sd 0[$r12] = $r18
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:  .LBB1_1: # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    copyd $r0 = $r18
; CHECK-NEXT:    call _ZN1aC2Ev
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    addd $r18 = $r18, 1
; CHECK-NEXT:    addd $r19 = $r19, -1
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    cb.dnez $r19 ? .LBB1_1
; CHECK-NEXT:    ;;
; CHECK-NEXT:  # %bb.2:
; CHECK-NEXT:    lq $r18r19 = 8[$r12]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    ld $r16 = 24[$r12]
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 32
; CHECK-NEXT:    ;; # (end cycle 6)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %2 = alloca %struct.f*, align 8
  store %struct.f* %0, %struct.f** %2, align 8
  %3 = load %struct.f*, %struct.f** %2, align 8
  %4 = getelementptr inbounds %struct.f, %struct.f* %3, i32 0, i32 0
  %5 = getelementptr inbounds [16 x %struct.a], [16 x %struct.a]* %4, i32 0, i32 0
  %6 = getelementptr inbounds %struct.a, %struct.a* %5, i64 16
  br label %7

7:                                                ; preds = %7, %1
  %8 = phi %struct.a* [ %5, %1 ], [ %9, %7 ]
  call void @_ZN1aC2Ev(%struct.a* %8)
  %9 = getelementptr inbounds %struct.a, %struct.a* %8, i64 1
  %10 = icmp eq %struct.a* %9, %6
  br i1 %10, label %11, label %7

11:                                               ; preds = %7
  ret void
}

define linkonce_odr void @_ZN1aC2Ev(%struct.a* %0) comdat align 2 {
; CHECK-LABEL: _ZN1aC2Ev:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addd $r12 = $r12, -32
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    sd 24[$r12] = $r16
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    sd 16[$r12] = $r0
; CHECK-NEXT:    call _ZN1gC1Ev
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    ld $r16 = 24[$r12]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 32
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
  %2 = alloca %struct.a*, align 8
  store %struct.a* %0, %struct.a** %2, align 8
  %3 = load %struct.a*, %struct.a** %2, align 8
  %4 = getelementptr inbounds %struct.a, %struct.a* %3, i32 0, i32 0
  call void @_ZN1gC1Ev(%class.g* %4)
  ret void
}

declare void @_ZN1gC1Ev(%class.g*)
