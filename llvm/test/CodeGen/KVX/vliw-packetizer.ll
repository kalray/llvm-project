; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -O2 -asm-verbose=false -o - %s | FileCheck %s
; RUN: clang -O2 -c -o /dev/null %s

; NOTE: -use-kvx-vliw-sched generates wrong code here, this is a known behavior.
; This option should be used with caution while the VLIW scheduler has not been correctly fixed/tuned for KVX.
; RUN: llc -O2 -asm-verbose=false -use-kvx-vliw-sched -o - %s | FileCheck -check-prefix=RELAXED %s

target triple = "kvx-kalray-cos"

; Rule 3: An ALU instruction that produces a carry must not be
; bundled with a SET or WFXL instruction on CS.
define i64 @rule3_c(i64 %a, i64 %b, i64 %c) {
; CHECK-LABEL: rule3_c:
; CHECK:         #APP
; CHECK-NEXT:    set $cs = $r0
; CHECK-NEXT:    ;;
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    addcd $r0 = $r1, $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
;
; RELAXED-LABEL: rule3_c:
; RELAXED:         #APP
; RELAXED-NEXT:    set $cs = $r0
; RELAXED-NEXT:    ;;
; RELAXED-NEXT:    #NO_APP
; RELAXED-NEXT:    addcd $r0 = $r1, $r2
; RELAXED-NEXT:    ret
; RELAXED-NEXT:    ;;
entry:
  tail call void asm sideeffect "set $$cs = $0", "r,~{$cs}"(i64 %a)
  %0 = tail call i64 @llvm.kvx.addcd(i64 %b, i64 %c, i32 0)
  ret i64 %0
}

declare void @llvm.kvx.set(i32, i64)

declare i64 @llvm.kvx.addcd(i64, i64, i32) #2

define i64 @rule3_ci(i64 %a, i64 %b, i64 %c) {
; CHECK-LABEL: rule3_ci:
; CHECK:         #APP
; CHECK-NEXT:    set $cs = $r0
; CHECK-NEXT:    ;;
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    addcd.i $r0 = $r1, $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
;
; RELAXED-LABEL: rule3_ci:
; RELAXED:         #APP
; RELAXED-NEXT:    set $cs = $r0
; RELAXED-NEXT:    ;;
; RELAXED-NEXT:    #NO_APP
; RELAXED-NEXT:    addcd.i $r0 = $r1, $r2
; RELAXED-NEXT:    ret
; RELAXED-NEXT:    ;;
entry:
  tail call void asm sideeffect "set $$cs = $0", "r,~{$cs}"(i64 %a)
  %0 = tail call i64 @llvm.kvx.addcd(i64 %b, i64 %c, i32 1) ; 1 = ".i"
  ret i64 %0
}

; Rule 4: An ALU or MAU instruction that produces an IEEE 754
; floating point flag must not be bundled with a SET or WFX*
; instruction on CS.
define float @rule4_set(i64 %a, float %b, float %c) {
; CHECK-LABEL: rule4_set:
; CHECK:         #APP
; CHECK-NEXT:    set $cs = $r0
; CHECK-NEXT:    ;;
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    faddw $r0 = $r1, $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
;
; RELAXED-LABEL: rule4_set:
; RELAXED:         faddw $r1 = $r1, $r2
; RELAXED-NEXT:    ;;
; RELAXED-NEXT:    #APP
; RELAXED-NEXT:    set $cs = $r0
; RELAXED-NEXT:    ;;
; RELAXED-NEXT:    #NO_APP
; RELAXED-NEXT:    copyd $r0 = $r1
; RELAXED-NEXT:    ret
; RELAXED-NEXT:    ;;
entry:
  tail call void asm sideeffect "set $$cs = $0", "r,~{$cs}"(i64 %a)
  %add = fadd float %b, %c
  ret float %add
}

declare float @llvm.kvx.faddw(float, float, i32, i32) #2

define float @rule4_set_builtins_only(i64 %a, float %b, float %c) {
; CHECK-LABEL: rule4_set_builtins_only:
; CHECK:         #APP
; CHECK-NEXT:    set $cs = $r0
; CHECK-NEXT:    ;;
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    faddw.rn $r0 = $r1, $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
;
; RELAXED-LABEL: rule4_set_builtins_only:
; RELAXED:         faddw.rn $r1 = $r1, $r2
; RELAXED-NEXT:    ;;
; RELAXED-NEXT:    #APP
; RELAXED-NEXT:    set $cs = $r0
; RELAXED-NEXT:    ;;
; RELAXED-NEXT:    #NO_APP
; RELAXED-NEXT:    copyd $r0 = $r1
; RELAXED-NEXT:    ret
; RELAXED-NEXT:    ;;
entry:
  tail call void asm sideeffect "set $$cs = $0", "r,~{$cs}"(i64 %a)
  %add = tail call float @llvm.kvx.faddw(float %b, float %c, i32 0, i32 0)
  ret float %add
}

define float @rule4_wfxm(i64 %a, float %b, float %c) {
; CHECK-LABEL: rule4_wfxm:
; CHECK:         #APP
; CHECK-NEXT:    wfxm $cs, $r0
; CHECK-NEXT:    ;;
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    faddw $r0 = $r1, $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
;
; RELAXED-LABEL: rule4_wfxm:
; RELAXED:         faddw $r1 = $r1, $r2
; RELAXED-NEXT:    ;;
; RELAXED-NEXT:    #APP
; RELAXED-NEXT:    wfxm $cs, $r0
; RELAXED-NEXT:    ;;
; RELAXED-NEXT:    #NO_APP
; RELAXED-NEXT:    copyd $r0 = $r1
; RELAXED-NEXT:    ret
; RELAXED-NEXT:    ;;
entry:
  tail call void asm sideeffect "wfxm $$cs, $0", "r,~{$cs}"(i64 %a)
  %add = fadd float %b, %c
  ret float %add
}

define float @rule4_wfxm_builtins_only(i64 %a, float %b, float %c) {
; CHECK-LABEL: rule4_wfxm_builtins_only:
; CHECK:         #APP
; CHECK-NEXT:    wfxm $cs, $r0
; CHECK-NEXT:    ;;
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    faddw.rn $r0 = $r1, $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
;
; RELAXED-LABEL: rule4_wfxm_builtins_only:
; RELAXED:         faddw.rn $r1 = $r1, $r2
; RELAXED-NEXT:    ;;
; RELAXED-NEXT:    #APP
; RELAXED-NEXT:    wfxm $cs, $r0
; RELAXED-NEXT:    ;;
; RELAXED-NEXT:    #NO_APP
; RELAXED-NEXT:    copyd $r0 = $r1
; RELAXED-NEXT:    ret
; RELAXED-NEXT:    ;;
entry:
  tail call void asm sideeffect "wfxm $$cs, $0", "r,~{$cs}"(i64 %a)
  %add = tail call float @llvm.kvx.faddw(float %b, float %c, i32 0, i32 0)
  ret float %add
}

declare void @llvm.kvx.wfxm(i32, i64)

define float @rule4_wfxl(i64 %a, float %b, float %c) {
; CHECK-LABEL: rule4_wfxl:
; CHECK:         #APP
; CHECK-NEXT:    wfxl $cs, $r0
; CHECK-NEXT:    ;;
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    faddw $r0 = $r1, $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
;
; RELAXED-LABEL: rule4_wfxl:
; RELAXED:         faddw $r1 = $r1, $r2
; RELAXED-NEXT:    ;;
; RELAXED-NEXT:    #APP
; RELAXED-NEXT:    wfxl $cs, $r0
; RELAXED-NEXT:    ;;
; RELAXED-NEXT:    #NO_APP
; RELAXED-NEXT:    copyd $r0 = $r1
; RELAXED-NEXT:    ret
; RELAXED-NEXT:    ;;
entry:
  tail call void asm sideeffect "wfxl $$cs, $0", "r,~{$cs}"(i64 %a)
  %add = fadd float %b, %c
  ret float %add
}

declare void @llvm.kvx.wfxl(i32, i64)
