; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -O3 -o - %s | FileCheck %s
; RUN: clang -O3 -g -c -o /dev/null %s

target triple = "kvx-kalray-cos"

%struct.Y = type { i64, i64 }

define %struct.Y @f(i64 %x.coerce0, i64 %x.coerce1, i64 %x.coerce2, i64 %x.coerce3, i64 %x.coerce4, i64 %x.coerce5, i64 %x.coerce6, i64 %x.coerce7, i64 %x.coerce8, i64 %x.coerce9, i64 %x.coerce10, i64 %x.coerce11, i64 %x.coerce12, i64 %x.coerce13) {
; CHECK-LABEL: f:
; CHECK:       .Lfunc_begin0:
; CHECK-NEXT:    .cfi_sections .debug_frame
; CHECK-NEXT:    .cfi_startproc
; CHECK-NEXT:  # %bb.0: # %entry
; CHECK-NEXT:    addd $r12 = $r12, -64
; CHECK-NEXT:    get $r16 = $ra
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    .cfi_register 67, 16
; CHECK-NEXT:    .cfi_def_cfa_offset 64
; CHECK-NEXT:    sd 56[$r12] = $r16
; CHECK-NEXT:    ;; # (end cycle 1)
; CHECK-NEXT:    .cfi_offset 67, -8
; CHECK-NEXT:    sq 40[$r12] = $r18r19
; CHECK-NEXT:    copyd $r18 = $r1
; CHECK-NEXT:    addd $r19 = $r0, 10
; CHECK-NEXT:    ;; # (end cycle 2)
; CHECK-NEXT:    .cfi_offset 19, -24
; CHECK-NEXT:    .cfi_offset 18, -16
; CHECK-NEXT:    ld $r1 = 64[$r12]
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    ld $r15 = 72[$r12]
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    sd 8[$r12] = $r15
; CHECK-NEXT:    copyd $r0 = $r19
; CHECK-NEXT:    ;; # (end cycle 6)
; CHECK-NEXT:    sd 0[$r12] = $r1
; CHECK-NEXT:    copyd $r1 = $r18
; CHECK-NEXT:    call g
; CHECK-NEXT:    ;; # (end cycle 7)
; CHECK-NEXT:    copyd $r0 = $r19
; CHECK-NEXT:    ld $r1 = 72[$r12]
; CHECK-NEXT:    ;; # (end cycle 0)
; CHECK-NEXT:    addd $r1 = $r1, 10
; CHECK-NEXT:    ;; # (end cycle 3)
; CHECK-NEXT:    sd 72[$r12] = $r1
; CHECK-NEXT:    ;; # (end cycle 4)
; CHECK-NEXT:    ld $r1 = 72[$r12]
; CHECK-NEXT:    copyd $r2 = $r18
; CHECK-NEXT:    ;; # (end cycle 5)
; CHECK-NEXT:    lq $r18r19 = 40[$r12]
; CHECK-NEXT:    ;; # (end cycle 6)
; CHECK-NEXT:    ld $r16 = 56[$r12]
; CHECK-NEXT:    ;; # (end cycle 7)
; CHECK-NEXT:    set $ra = $r16
; CHECK-NEXT:    addd $r12 = $r12, 64
; CHECK-NEXT:    ;; # (end cycle 12)
; CHECK-NEXT:    .cfi_def_cfa_offset 0
; CHECK-NEXT:    goto h
; CHECK-NEXT:    ;;
entry:
  %x.sroa.30 = alloca i64, align 8
  store i64 %x.coerce13, i64* %x.sroa.30, align 8
  %add = add nsw i64 %x.coerce0, 10
  %call = tail call %struct.Y @g(i64 %add, i64 %x.coerce1, i64 %x.coerce2, i64 %x.coerce3, i64 %x.coerce4, i64 %x.coerce5, i64 %x.coerce6, i64 %x.coerce7, i64 %x.coerce8, i64 %x.coerce9, i64 %x.coerce10, i64 %x.coerce11, i64 %x.coerce12, i64 %x.coerce13)
  %0 = extractvalue %struct.Y %call, 0
  %x.sroa.30.0.x.sroa.30.0.x.sroa.30.104. = load volatile i64, i64* %x.sroa.30, align 8
  %add2 = add nsw i64 %x.sroa.30.0.x.sroa.30.0.x.sroa.30.104., 10
  store volatile i64 %add2, i64* %x.sroa.30, align 8
  %conv = trunc i64 %add to i32
  %x.sroa.30.0.x.sroa.30.0.x.sroa.30.104.11 = load volatile i64, i64* %x.sroa.30, align 8
  %call5 = tail call %struct.Y (i32, ...) @h(i32 %conv, i64 %x.sroa.30.0.x.sroa.30.0.x.sroa.30.104.11, i64 %x.coerce1)
  ret %struct.Y %call5

}

declare %struct.Y @g(i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64)

declare %struct.Y @h(i32, ...)

!llvm.dbg.cu = !{!0}
!llvm.module.flags = !{!3, !4, !5}

!0 = distinct !DICompileUnit(language: DW_LANG_C99, file: !1, producer: "me", isOptimized:true, runtimeVersion: 0, emissionKind: FullDebug, enums: !2, splitDebugInlining: false, nameTableKind: None)
!1 = !DIFile(filename: "myfile", directory: "mydir")
!2 = !{}
!3 = !{i32 7, !"Dwarf Version", i32 4}
!4 = !{i32 2, !"Debug Info Version", i32 3}
!5 = !{i32 1, !"wchar_size", i32 4}

