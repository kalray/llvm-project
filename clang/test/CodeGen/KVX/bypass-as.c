// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// RUN: %clang_cc1 -triple kvx-kalray-cos -O3 -S %s -o - -emit-llvm | FileCheck %s

typedef int v4i32 __attribute__((vector_size(4 * sizeof(int))));
typedef float v2f32 __attribute__((vector_size(2 * sizeof(float))));
typedef float v4f32 __attribute__((vector_size(4 * sizeof(float))));

struct S {
  int a;
  int b;
  int c;
  int d;
};

// CHECK-LABEL: @bypass_i8(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load i8, ptr addrspace(256) [[I:%.*]], align 1, !tbaa [[TBAA2:![0-9]+]]
// CHECK-NEXT:    ret i8 [[TMP0]]
//
char bypass_i8(__bypass char *i) {
  return *i;
}

// CHECK-LABEL: @bypass_i16(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load i16, ptr addrspace(256) [[I:%.*]], align 2, !tbaa [[TBAA5:![0-9]+]]
// CHECK-NEXT:    ret i16 [[TMP0]]
//
short bypass_i16(__bypass short *i) {
  return *i;
}

// CHECK-LABEL: @bypass_i32(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr addrspace(256) [[I:%.*]], align 4, !tbaa [[TBAA7:![0-9]+]]
// CHECK-NEXT:    ret i32 [[TMP0]]
//
int bypass_i32(__bypass int *i) {
  return *i;
}

// CHECK-LABEL: @bypass_i64(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load i64, ptr addrspace(256) [[I:%.*]], align 8, !tbaa [[TBAA9:![0-9]+]]
// CHECK-NEXT:    ret i64 [[TMP0]]
//
long bypass_i64(__bypass long *i) {
  return *i;
}

// CHECK-LABEL: @fbypass_f32(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load float, ptr addrspace(256) [[F:%.*]], align 4, !tbaa [[TBAA11:![0-9]+]]
// CHECK-NEXT:    ret float [[TMP0]]
//
float fbypass_f32(__bypass float *f) {
  return *f;
}

// CHECK-LABEL: @fbypass_f64(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load double, ptr addrspace(256) [[D:%.*]], align 8, !tbaa [[TBAA13:![0-9]+]]
// CHECK-NEXT:    ret double [[TMP0]]
//
double fbypass_f64(__bypass double *d) {
  return *d;
}

// CHECK-LABEL: @fbypass_v2f32(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load <2 x float>, ptr addrspace(256) [[V:%.*]], align 8, !tbaa [[TBAA2]]
// CHECK-NEXT:    ret <2 x float> [[TMP0]]
//
v2f32 fbypass_v2f32(__bypass v2f32 *v) {
  return *v;
}

// CHECK-LABEL: @fbypass_v4f32(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load <4 x float>, ptr addrspace(256) [[V:%.*]], align 16, !tbaa [[TBAA2]]
// CHECK-NEXT:    ret <4 x float> [[TMP0]]
//
v4f32 fbypass_v4f32(__bypass v4f32 *v) {
  return *v;
}

// CHECK-LABEL: @foo_bypass_a(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr addrspace(256) [[S:%.*]], align 4, !tbaa [[TBAA15:![0-9]+]]
// CHECK-NEXT:    ret i32 [[TMP0]]
//
int foo_bypass_a(__bypass struct S *s) {
  return s->a;
}

// CHECK-LABEL: @foo_bypass_b(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[B:%.*]] = getelementptr inbounds [[STRUCT_S:%.*]], ptr addrspace(256) [[S:%.*]], i64 0, i32 1
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr addrspace(256) [[B]], align 4, !tbaa [[TBAA17:![0-9]+]]
// CHECK-NEXT:    ret i32 [[TMP0]]
//
int foo_bypass_b(__bypass struct S *s) {
  return s->b;
}

// CHECK-LABEL: @foo_bypass_c(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[C:%.*]] = getelementptr inbounds [[STRUCT_S:%.*]], ptr addrspace(256) [[S:%.*]], i64 0, i32 2
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr addrspace(256) [[C]], align 4, !tbaa [[TBAA18:![0-9]+]]
// CHECK-NEXT:    ret i32 [[TMP0]]
//
int foo_bypass_c(__bypass struct S *s) {
  return s->c;
}

// CHECK-LABEL: @foo_bypass_d(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[D:%.*]] = getelementptr inbounds [[STRUCT_S:%.*]], ptr addrspace(256) [[S:%.*]], i64 0, i32 3
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr addrspace(256) [[D]], align 4, !tbaa [[TBAA19:![0-9]+]]
// CHECK-NEXT:    ret i32 [[TMP0]]
//
int foo_bypass_d(__bypass struct S *s) {
  return s->d;
}

// CHECK-LABEL: @foo_bypass_3(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds <4 x i32>, ptr addrspace(256) [[V:%.*]], i64 0, i64 3
// CHECK-NEXT:    [[VECEXT:%.*]] = load i32, ptr addrspace(256) [[TMP0]], align 4
// CHECK-NEXT:    ret i32 [[VECEXT]]
//
int foo_bypass_3(__bypass v4i32 *v) {
  return (*v)[3];
}

// CHECK-LABEL: @foo_bypass_x(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load <4 x i32>, ptr addrspace(256) [[V:%.*]], align 16, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[VECEXT:%.*]] = extractelement <4 x i32> [[TMP0]], i32 [[X:%.*]]
// CHECK-NEXT:    ret i32 [[VECEXT]]
//
int foo_bypass_x(__bypass v4i32 *v, int x) {
  return (*v)[x];
}

// CHECK-LABEL: @foo_default(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[I:%.*]], align 4, !tbaa [[TBAA7]]
// CHECK-NEXT:    ret i32 [[TMP0]]
//
int foo_default(int *i) {
  return *i;
}

// CHECK-LABEL: @foo_default_a(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[S:%.*]], align 4, !tbaa [[TBAA15]]
// CHECK-NEXT:    ret i32 [[TMP0]]
//
int foo_default_a(struct S *s) {
  return s->a;
}

// CHECK-LABEL: @foo_default_b(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[B:%.*]] = getelementptr inbounds [[STRUCT_S:%.*]], ptr [[S:%.*]], i64 0, i32 1
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[B]], align 4, !tbaa [[TBAA17]]
// CHECK-NEXT:    ret i32 [[TMP0]]
//
int foo_default_b(struct S *s) {
  return s->b;
}

// CHECK-LABEL: @foo_default_c(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[C:%.*]] = getelementptr inbounds [[STRUCT_S:%.*]], ptr [[S:%.*]], i64 0, i32 2
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[C]], align 4, !tbaa [[TBAA18]]
// CHECK-NEXT:    ret i32 [[TMP0]]
//
int foo_default_c(struct S *s) {
  return s->c;
}

// CHECK-LABEL: @foo_default_d(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[D:%.*]] = getelementptr inbounds [[STRUCT_S:%.*]], ptr [[S:%.*]], i64 0, i32 3
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[D]], align 4, !tbaa [[TBAA19]]
// CHECK-NEXT:    ret i32 [[TMP0]]
//
int foo_default_d(struct S *s) {
  return s->d;
}

// CHECK-LABEL: @foo_default_3(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds <4 x i32>, ptr [[V:%.*]], i64 0, i64 3
// CHECK-NEXT:    [[VECEXT:%.*]] = load i32, ptr [[TMP0]], align 4
// CHECK-NEXT:    ret i32 [[VECEXT]]
//
int foo_default_3(v4i32 *v) {
  return (*v)[3];
}

// CHECK-LABEL: @foo_default_x(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load <4 x i32>, ptr [[V:%.*]], align 16, !tbaa [[TBAA2]]
// CHECK-NEXT:    [[VECEXT:%.*]] = extractelement <4 x i32> [[TMP0]], i32 [[X:%.*]]
// CHECK-NEXT:    ret i32 [[VECEXT]]
//
int foo_default_x(v4i32 *v, int x) {
  return (*v)[x];
}
