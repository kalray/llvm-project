// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// RUN: %clang_cc1 -triple kvx-kalray-cos -emit-llvm %s -O2 -o - | FileCheck %s

typedef float __attribute__((__vector_size__(2 * sizeof(float)))) v2f32;
typedef float __attribute__((__vector_size__(4 * sizeof(float)))) v4f32;
typedef float __attribute__((__vector_size__(8 * sizeof(float)))) v8f32;
typedef double __attribute__((__vector_size__(2 * sizeof(double)))) v2f64;
typedef double __attribute__((__vector_size__(4 * sizeof(double)))) v4f64;

///////////////////////////////////
/// Word Complex Floating-Point ///
///////////////////////////////////

// CHECK-LABEL: @fmulwc(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <2 x float> @llvm.kvx.fmulwc(<2 x float> [[A:%.*]], <2 x float> [[B:%.*]], i32 0, i32 0, i32 0)
// CHECK-NEXT:    ret <2 x float> [[TMP0]]
//
v2f32 fmulwc(v2f32 a, v2f32 b) {
  return __builtin_kvx_fmulwc(a, b, ".rn");
}

// CHECK-LABEL: @fmulwc_nomod(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <2 x float> @llvm.kvx.fmulwc(<2 x float> [[A:%.*]], <2 x float> [[B:%.*]], i32 0, i32 7, i32 0)
// CHECK-NEXT:    ret <2 x float> [[TMP0]]
//
v2f32 fmulwc_nomod(v2f32 a, v2f32 b) {
  return __builtin_kvx_fmulwc(a, b, "");
}

// CHECK-LABEL: @fmulwc_mod_0(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <2 x float> @llvm.kvx.fmulwc(<2 x float> [[A:%.*]], <2 x float> [[B:%.*]], i32 0, i32 7, i32 0)
// CHECK-NEXT:    ret <2 x float> [[TMP0]]
//
v2f32 fmulwc_mod_0(v2f32 a, v2f32 b) {
  return __builtin_kvx_fmulwc(a, b, 0);
}

// CHECK-LABEL: @ffmawc(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <2 x float> @llvm.kvx.ffmawc(<2 x float> [[A:%.*]], <2 x float> [[B:%.*]], <2 x float> [[C:%.*]], i32 0, i32 0, i32 0)
// CHECK-NEXT:    ret <2 x float> [[TMP0]]
//
v2f32 ffmawc(v2f32 a, v2f32 b, v2f32 c) {
  return __builtin_kvx_ffmawc(a, b, c, ".rn");
}

// CHECK-LABEL: @ffmswc(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <2 x float> @llvm.kvx.ffmswc(<2 x float> [[A:%.*]], <2 x float> [[B:%.*]], <2 x float> [[C:%.*]], i32 0, i32 0, i32 0)
// CHECK-NEXT:    ret <2 x float> [[TMP0]]
//
v2f32 ffmswc(v2f32 a, v2f32 b, v2f32 c) {
  return __builtin_kvx_ffmswc(a, b, c, ".rn");
}

// CHECK-LABEL: @fmulcwc(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <2 x float> @llvm.kvx.fmulwc(<2 x float> [[A:%.*]], <2 x float> [[B:%.*]], i32 1, i32 0, i32 0)
// CHECK-NEXT:    ret <2 x float> [[TMP0]]
//
v2f32 fmulcwc(v2f32 a, v2f32 b) {
  return __builtin_kvx_fmulwc(a, b, ".c.rn");
}

// CHECK-LABEL: @ffmacwc(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <2 x float> @llvm.kvx.ffmawc(<2 x float> [[A:%.*]], <2 x float> [[B:%.*]], <2 x float> [[C:%.*]], i32 1, i32 0, i32 0)
// CHECK-NEXT:    ret <2 x float> [[TMP0]]
//
v2f32 ffmacwc(v2f32 a, v2f32 b, v2f32 c) {
  return __builtin_kvx_ffmawc(a, b, c, ".c.rn");
}

// CHECK-LABEL: @ffmscwc(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <2 x float> @llvm.kvx.ffmswc(<2 x float> [[A:%.*]], <2 x float> [[B:%.*]], <2 x float> [[C:%.*]], i32 1, i32 0, i32 0)
// CHECK-NEXT:    ret <2 x float> [[TMP0]]
//
v2f32 ffmscwc(v2f32 a, v2f32 b, v2f32 c) {
  return __builtin_kvx_ffmswc(a, b, c, ".c.rn");
}

// CHECK-LABEL: @fconjwc(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <2 x float> @llvm.kvx.fconjwc(<2 x float> [[A:%.*]])
// CHECK-NEXT:    ret <2 x float> [[TMP0]]
//
v2f32 fconjwc(v2f32 a) {
  return __builtin_kvx_fconjwc(a);
}

////////////////////////////////////////
/// Word Complex Pair Floating-Point ///
////////////////////////////////////////

// CHECK-LABEL: @fmulwcp(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <4 x float> @llvm.kvx.fmulwcp(<4 x float> [[A:%.*]], <4 x float> [[B:%.*]], i32 0, i32 0, i32 0)
// CHECK-NEXT:    ret <4 x float> [[TMP0]]
//
v4f32 fmulwcp(v4f32 a, v4f32 b) {
  return __builtin_kvx_fmulwcp(a, b, ".rn");
}

// CHECK-LABEL: @ffmawcp(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <4 x float> @llvm.kvx.ffmawcp(<4 x float> [[A:%.*]], <4 x float> [[B:%.*]], <4 x float> [[C:%.*]], i32 0, i32 0, i32 0)
// CHECK-NEXT:    ret <4 x float> [[TMP0]]
//
v4f32 ffmawcp(v4f32 a, v4f32 b, v4f32 c) {
  return __builtin_kvx_ffmawcp(a, b, c, ".rn");
}

// CHECK-LABEL: @ffmswcp(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <4 x float> @llvm.kvx.ffmswcp(<4 x float> [[A:%.*]], <4 x float> [[B:%.*]], <4 x float> [[C:%.*]], i32 0, i32 0, i32 0)
// CHECK-NEXT:    ret <4 x float> [[TMP0]]
//
v4f32 ffmswcp(v4f32 a, v4f32 b, v4f32 c) {
  return __builtin_kvx_ffmswcp(a, b, c, ".rn");
}

// CHECK-LABEL: @fmulcwcp(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <4 x float> @llvm.kvx.fmulwcp(<4 x float> [[A:%.*]], <4 x float> [[B:%.*]], i32 1, i32 0, i32 0)
// CHECK-NEXT:    ret <4 x float> [[TMP0]]
//
v4f32 fmulcwcp(v4f32 a, v4f32 b) {
  return __builtin_kvx_fmulwcp(a, b, ".c.rn");
}

// CHECK-LABEL: @ffmacwcp(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <4 x float> @llvm.kvx.ffmawcp(<4 x float> [[A:%.*]], <4 x float> [[B:%.*]], <4 x float> [[C:%.*]], i32 1, i32 0, i32 0)
// CHECK-NEXT:    ret <4 x float> [[TMP0]]
//
v4f32 ffmacwcp(v4f32 a, v4f32 b, v4f32 c) {
  return __builtin_kvx_ffmawcp(a, b, c, ".c.rn");
}

// CHECK-LABEL: @ffmscwcp(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <4 x float> @llvm.kvx.ffmswcp(<4 x float> [[A:%.*]], <4 x float> [[B:%.*]], <4 x float> [[C:%.*]], i32 1, i32 0, i32 0)
// CHECK-NEXT:    ret <4 x float> [[TMP0]]
//
v4f32 ffmscwcp(v4f32 a, v4f32 b, v4f32 c) {
  return __builtin_kvx_ffmswcp(a, b, c, ".c.rn");
}

// CHECK-LABEL: @fconjwcp(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <4 x float> @llvm.kvx.fconjwcp(<4 x float> [[A:%.*]])
// CHECK-NEXT:    ret <4 x float> [[TMP0]]
//
v4f32 fconjwcp(v4f32 a) {
  return __builtin_kvx_fconjwcp(a);
}

/////////////////////////////////////////////
/// Word Complex Quadruple Floating-Point ///
/////////////////////////////////////////////

// CHECK-LABEL: @fmulwcq(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = shufflevector <8 x float> [[A:%.*]], <8 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
// CHECK-NEXT:    [[TMP1:%.*]] = shufflevector <8 x float> [[B:%.*]], <8 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
// CHECK-NEXT:    [[TMP2:%.*]] = tail call <4 x float> @llvm.kvx.fmulwcp(<4 x float> [[TMP0]], <4 x float> [[TMP1]], i32 0, i32 0, i32 0)
// CHECK-NEXT:    [[TMP3:%.*]] = shufflevector <8 x float> [[A]], <8 x float> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
// CHECK-NEXT:    [[TMP4:%.*]] = shufflevector <8 x float> [[B]], <8 x float> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
// CHECK-NEXT:    [[TMP5:%.*]] = tail call <4 x float> @llvm.kvx.fmulwcp(<4 x float> [[TMP3]], <4 x float> [[TMP4]], i32 0, i32 0, i32 0)
// CHECK-NEXT:    [[TMP6:%.*]] = shufflevector <4 x float> [[TMP2]], <4 x float> [[TMP5]], <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
// CHECK-NEXT:    ret <8 x float> [[TMP6]]
//
v8f32 fmulwcq(v8f32 a, v8f32 b) {
  return __builtin_kvx_fmulwcq(a, b, ".rn");
}

// CHECK-LABEL: @ffmawcq(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = shufflevector <8 x float> [[A:%.*]], <8 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
// CHECK-NEXT:    [[TMP1:%.*]] = shufflevector <8 x float> [[B:%.*]], <8 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
// CHECK-NEXT:    [[TMP2:%.*]] = shufflevector <8 x float> [[C:%.*]], <8 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
// CHECK-NEXT:    [[TMP3:%.*]] = tail call <4 x float> @llvm.kvx.ffmawcp(<4 x float> [[TMP0]], <4 x float> [[TMP1]], <4 x float> [[TMP2]], i32 0, i32 0, i32 0)
// CHECK-NEXT:    [[TMP4:%.*]] = shufflevector <8 x float> [[A]], <8 x float> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
// CHECK-NEXT:    [[TMP5:%.*]] = shufflevector <8 x float> [[B]], <8 x float> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
// CHECK-NEXT:    [[TMP6:%.*]] = shufflevector <8 x float> [[C]], <8 x float> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
// CHECK-NEXT:    [[TMP7:%.*]] = tail call <4 x float> @llvm.kvx.ffmawcp(<4 x float> [[TMP4]], <4 x float> [[TMP5]], <4 x float> [[TMP6]], i32 0, i32 0, i32 0)
// CHECK-NEXT:    [[TMP8:%.*]] = shufflevector <4 x float> [[TMP3]], <4 x float> [[TMP7]], <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
// CHECK-NEXT:    ret <8 x float> [[TMP8]]
//
v8f32 ffmawcq(v8f32 a, v8f32 b, v8f32 c) {
  return __builtin_kvx_ffmawcq(a, b, c, ".rn");
}

// CHECK-LABEL: @ffmswcq(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = shufflevector <8 x float> [[A:%.*]], <8 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
// CHECK-NEXT:    [[TMP1:%.*]] = shufflevector <8 x float> [[B:%.*]], <8 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
// CHECK-NEXT:    [[TMP2:%.*]] = shufflevector <8 x float> [[C:%.*]], <8 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
// CHECK-NEXT:    [[TMP3:%.*]] = tail call <4 x float> @llvm.kvx.ffmswcp(<4 x float> [[TMP0]], <4 x float> [[TMP1]], <4 x float> [[TMP2]], i32 0, i32 0, i32 0)
// CHECK-NEXT:    [[TMP4:%.*]] = shufflevector <8 x float> [[A]], <8 x float> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
// CHECK-NEXT:    [[TMP5:%.*]] = shufflevector <8 x float> [[B]], <8 x float> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
// CHECK-NEXT:    [[TMP6:%.*]] = shufflevector <8 x float> [[C]], <8 x float> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
// CHECK-NEXT:    [[TMP7:%.*]] = tail call <4 x float> @llvm.kvx.ffmswcp(<4 x float> [[TMP4]], <4 x float> [[TMP5]], <4 x float> [[TMP6]], i32 0, i32 0, i32 0)
// CHECK-NEXT:    [[TMP8:%.*]] = shufflevector <4 x float> [[TMP3]], <4 x float> [[TMP7]], <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
// CHECK-NEXT:    ret <8 x float> [[TMP8]]
//
v8f32 ffmswcq(v8f32 a, v8f32 b, v8f32 c) {
  return __builtin_kvx_ffmswcq(a, b, c, ".rn");
}

// CHECK-LABEL: @fmulcwcq(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = shufflevector <8 x float> [[A:%.*]], <8 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
// CHECK-NEXT:    [[TMP1:%.*]] = shufflevector <8 x float> [[B:%.*]], <8 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
// CHECK-NEXT:    [[TMP2:%.*]] = tail call <4 x float> @llvm.kvx.fmulwcp(<4 x float> [[TMP0]], <4 x float> [[TMP1]], i32 1, i32 0, i32 0)
// CHECK-NEXT:    [[TMP3:%.*]] = shufflevector <8 x float> [[A]], <8 x float> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
// CHECK-NEXT:    [[TMP4:%.*]] = shufflevector <8 x float> [[B]], <8 x float> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
// CHECK-NEXT:    [[TMP5:%.*]] = tail call <4 x float> @llvm.kvx.fmulwcp(<4 x float> [[TMP3]], <4 x float> [[TMP4]], i32 1, i32 0, i32 0)
// CHECK-NEXT:    [[TMP6:%.*]] = shufflevector <4 x float> [[TMP2]], <4 x float> [[TMP5]], <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
// CHECK-NEXT:    ret <8 x float> [[TMP6]]
//
v8f32 fmulcwcq(v8f32 a, v8f32 b) {
  return __builtin_kvx_fmulwcq(a, b, ".c.rn");
}

// CHECK-LABEL: @ffmacwcq(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = shufflevector <8 x float> [[A:%.*]], <8 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
// CHECK-NEXT:    [[TMP1:%.*]] = shufflevector <8 x float> [[B:%.*]], <8 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
// CHECK-NEXT:    [[TMP2:%.*]] = shufflevector <8 x float> [[C:%.*]], <8 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
// CHECK-NEXT:    [[TMP3:%.*]] = tail call <4 x float> @llvm.kvx.ffmawcp(<4 x float> [[TMP0]], <4 x float> [[TMP1]], <4 x float> [[TMP2]], i32 1, i32 0, i32 0)
// CHECK-NEXT:    [[TMP4:%.*]] = shufflevector <8 x float> [[A]], <8 x float> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
// CHECK-NEXT:    [[TMP5:%.*]] = shufflevector <8 x float> [[B]], <8 x float> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
// CHECK-NEXT:    [[TMP6:%.*]] = shufflevector <8 x float> [[C]], <8 x float> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
// CHECK-NEXT:    [[TMP7:%.*]] = tail call <4 x float> @llvm.kvx.ffmawcp(<4 x float> [[TMP4]], <4 x float> [[TMP5]], <4 x float> [[TMP6]], i32 1, i32 0, i32 0)
// CHECK-NEXT:    [[TMP8:%.*]] = shufflevector <4 x float> [[TMP3]], <4 x float> [[TMP7]], <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
// CHECK-NEXT:    ret <8 x float> [[TMP8]]
//
v8f32 ffmacwcq(v8f32 a, v8f32 b, v8f32 c) {
  return __builtin_kvx_ffmawcq(a, b, c, ".c.rn");
}

// CHECK-LABEL: @ffmscwcq(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = shufflevector <8 x float> [[A:%.*]], <8 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
// CHECK-NEXT:    [[TMP1:%.*]] = shufflevector <8 x float> [[B:%.*]], <8 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
// CHECK-NEXT:    [[TMP2:%.*]] = shufflevector <8 x float> [[C:%.*]], <8 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
// CHECK-NEXT:    [[TMP3:%.*]] = tail call <4 x float> @llvm.kvx.ffmswcp(<4 x float> [[TMP0]], <4 x float> [[TMP1]], <4 x float> [[TMP2]], i32 1, i32 0, i32 0)
// CHECK-NEXT:    [[TMP4:%.*]] = shufflevector <8 x float> [[A]], <8 x float> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
// CHECK-NEXT:    [[TMP5:%.*]] = shufflevector <8 x float> [[B]], <8 x float> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
// CHECK-NEXT:    [[TMP6:%.*]] = shufflevector <8 x float> [[C]], <8 x float> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
// CHECK-NEXT:    [[TMP7:%.*]] = tail call <4 x float> @llvm.kvx.ffmswcp(<4 x float> [[TMP4]], <4 x float> [[TMP5]], <4 x float> [[TMP6]], i32 1, i32 0, i32 0)
// CHECK-NEXT:    [[TMP8:%.*]] = shufflevector <4 x float> [[TMP3]], <4 x float> [[TMP7]], <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
// CHECK-NEXT:    ret <8 x float> [[TMP8]]
//
v8f32 ffmscwcq(v8f32 a, v8f32 b, v8f32 c) {
  return __builtin_kvx_ffmswcq(a, b, c, ".c.rn");
}

// CHECK-LABEL: @fconjwcq(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = shufflevector <8 x float> [[A:%.*]], <8 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <4 x float> @llvm.kvx.fconjwcp(<4 x float> [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = shufflevector <8 x float> [[A]], <8 x float> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
// CHECK-NEXT:    [[TMP3:%.*]] = tail call <4 x float> @llvm.kvx.fconjwcp(<4 x float> [[TMP2]])
// CHECK-NEXT:    [[TMP4:%.*]] = shufflevector <4 x float> [[TMP1]], <4 x float> [[TMP3]], <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
// CHECK-NEXT:    ret <8 x float> [[TMP4]]
//
v8f32 fconjwcq(v8f32 a) {
  return __builtin_kvx_fconjwcq(a);
}

/////////////////////////////////////
/// Double Complex Floating-Point ///
/////////////////////////////////////

// CHECK-LABEL: @fmuldc(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <2 x double> @llvm.kvx.fmuldc(<2 x double> [[A:%.*]], <2 x double> [[B:%.*]], i32 0, i32 0)
// CHECK-NEXT:    ret <2 x double> [[TMP0]]
//
v2f64 fmuldc(v2f64 a, v2f64 b) {
  return __builtin_kvx_fmuldc(a, b, ".rn");
}

// CHECK-LABEL: @ffmadc(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <2 x double> @llvm.kvx.ffmadc(<2 x double> [[A:%.*]], <2 x double> [[B:%.*]], <2 x double> [[C:%.*]], i32 0, i32 0)
// CHECK-NEXT:    ret <2 x double> [[TMP0]]
//
v2f64 ffmadc(v2f64 a, v2f64 b, v2f64 c) {
  return __builtin_kvx_ffmadc(a, b, c, ".rn");
}

// CHECK-LABEL: @ffmsdc(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <2 x double> @llvm.kvx.ffmsdc(<2 x double> [[A:%.*]], <2 x double> [[B:%.*]], <2 x double> [[C:%.*]], i32 0, i32 0)
// CHECK-NEXT:    ret <2 x double> [[TMP0]]
//
v2f64 ffmsdc(v2f64 a, v2f64 b, v2f64 c) {
  return __builtin_kvx_ffmsdc(a, b, c, ".rn");
}

// CHECK-LABEL: @fmulcdc(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <2 x double> @llvm.kvx.fmulcdc(<2 x double> [[A:%.*]], <2 x double> [[B:%.*]], i32 0, i32 0)
// CHECK-NEXT:    ret <2 x double> [[TMP0]]
//
v2f64 fmulcdc(v2f64 a, v2f64 b) {
  return __builtin_kvx_fmuldc(a, b, ".c.rn");
}

// CHECK-LABEL: @ffmacdc(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <2 x double> @llvm.kvx.ffmacdc(<2 x double> [[A:%.*]], <2 x double> [[B:%.*]], <2 x double> [[C:%.*]], i32 0, i32 0)
// CHECK-NEXT:    ret <2 x double> [[TMP0]]
//
v2f64 ffmacdc(v2f64 a, v2f64 b, v2f64 c) {
  return __builtin_kvx_ffmadc(a, b, c, ".c.rn");
}

// CHECK-LABEL: @ffmscdc(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <2 x double> @llvm.kvx.ffmscdc(<2 x double> [[A:%.*]], <2 x double> [[B:%.*]], <2 x double> [[C:%.*]], i32 0, i32 0)
// CHECK-NEXT:    ret <2 x double> [[TMP0]]
//
v2f64 ffmscdc(v2f64 a, v2f64 b, v2f64 c) {
  return __builtin_kvx_ffmsdc(a, b, c, ".c.rn");
}

// CHECK-LABEL: @fconjdc(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <2 x double> @llvm.kvx.fconjdc(<2 x double> [[A:%.*]])
// CHECK-NEXT:    ret <2 x double> [[TMP0]]
//
v2f64 fconjdc(v2f64 a) {
  return __builtin_kvx_fconjdc(a);
}

//////////////////////////////////////////
/// Double Complex Pair Floating-Point ///
//////////////////////////////////////////

// CHECK-LABEL: @fmuldcp(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = shufflevector <4 x double> [[A:%.*]], <4 x double> undef, <2 x i32> <i32 0, i32 1>
// CHECK-NEXT:    [[TMP1:%.*]] = shufflevector <4 x double> [[B:%.*]], <4 x double> undef, <2 x i32> <i32 0, i32 1>
// CHECK-NEXT:    [[TMP2:%.*]] = tail call <2 x double> @llvm.kvx.fmuldc(<2 x double> [[TMP0]], <2 x double> [[TMP1]], i32 0, i32 0)
// CHECK-NEXT:    [[TMP3:%.*]] = shufflevector <4 x double> [[A]], <4 x double> undef, <2 x i32> <i32 2, i32 3>
// CHECK-NEXT:    [[TMP4:%.*]] = shufflevector <4 x double> [[B]], <4 x double> undef, <2 x i32> <i32 2, i32 3>
// CHECK-NEXT:    [[TMP5:%.*]] = tail call <2 x double> @llvm.kvx.fmuldc(<2 x double> [[TMP3]], <2 x double> [[TMP4]], i32 0, i32 0)
// CHECK-NEXT:    [[TMP6:%.*]] = shufflevector <2 x double> [[TMP2]], <2 x double> [[TMP5]], <4 x i32> <i32 0, i32 1, i32 2, i32 3>
// CHECK-NEXT:    ret <4 x double> [[TMP6]]
//
v4f64 fmuldcp(v4f64 a, v4f64 b) {
  return __builtin_kvx_fmuldcp(a, b, ".rn");
}

// CHECK-LABEL: @ffmadcp(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = shufflevector <4 x double> [[A:%.*]], <4 x double> undef, <2 x i32> <i32 0, i32 1>
// CHECK-NEXT:    [[TMP1:%.*]] = shufflevector <4 x double> [[B:%.*]], <4 x double> undef, <2 x i32> <i32 0, i32 1>
// CHECK-NEXT:    [[TMP2:%.*]] = shufflevector <4 x double> [[C:%.*]], <4 x double> undef, <2 x i32> <i32 0, i32 1>
// CHECK-NEXT:    [[TMP3:%.*]] = tail call <2 x double> @llvm.kvx.ffmadc(<2 x double> [[TMP0]], <2 x double> [[TMP1]], <2 x double> [[TMP2]], i32 0, i32 0)
// CHECK-NEXT:    [[TMP4:%.*]] = shufflevector <4 x double> [[A]], <4 x double> undef, <2 x i32> <i32 2, i32 3>
// CHECK-NEXT:    [[TMP5:%.*]] = shufflevector <4 x double> [[B]], <4 x double> undef, <2 x i32> <i32 2, i32 3>
// CHECK-NEXT:    [[TMP6:%.*]] = shufflevector <4 x double> [[C]], <4 x double> undef, <2 x i32> <i32 2, i32 3>
// CHECK-NEXT:    [[TMP7:%.*]] = tail call <2 x double> @llvm.kvx.ffmadc(<2 x double> [[TMP4]], <2 x double> [[TMP5]], <2 x double> [[TMP6]], i32 0, i32 0)
// CHECK-NEXT:    [[TMP8:%.*]] = shufflevector <2 x double> [[TMP3]], <2 x double> [[TMP7]], <4 x i32> <i32 0, i32 1, i32 2, i32 3>
// CHECK-NEXT:    ret <4 x double> [[TMP8]]
//
v4f64 ffmadcp(v4f64 a, v4f64 b, v4f64 c) {
  return __builtin_kvx_ffmadcp(a, b, c, ".rn");
}

// CHECK-LABEL: @ffmsdcp(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = shufflevector <4 x double> [[A:%.*]], <4 x double> undef, <2 x i32> <i32 0, i32 1>
// CHECK-NEXT:    [[TMP1:%.*]] = shufflevector <4 x double> [[B:%.*]], <4 x double> undef, <2 x i32> <i32 0, i32 1>
// CHECK-NEXT:    [[TMP2:%.*]] = shufflevector <4 x double> [[C:%.*]], <4 x double> undef, <2 x i32> <i32 0, i32 1>
// CHECK-NEXT:    [[TMP3:%.*]] = tail call <2 x double> @llvm.kvx.ffmsdc(<2 x double> [[TMP0]], <2 x double> [[TMP1]], <2 x double> [[TMP2]], i32 0, i32 0)
// CHECK-NEXT:    [[TMP4:%.*]] = shufflevector <4 x double> [[A]], <4 x double> undef, <2 x i32> <i32 2, i32 3>
// CHECK-NEXT:    [[TMP5:%.*]] = shufflevector <4 x double> [[B]], <4 x double> undef, <2 x i32> <i32 2, i32 3>
// CHECK-NEXT:    [[TMP6:%.*]] = shufflevector <4 x double> [[C]], <4 x double> undef, <2 x i32> <i32 2, i32 3>
// CHECK-NEXT:    [[TMP7:%.*]] = tail call <2 x double> @llvm.kvx.ffmsdc(<2 x double> [[TMP4]], <2 x double> [[TMP5]], <2 x double> [[TMP6]], i32 0, i32 0)
// CHECK-NEXT:    [[TMP8:%.*]] = shufflevector <2 x double> [[TMP3]], <2 x double> [[TMP7]], <4 x i32> <i32 0, i32 1, i32 2, i32 3>
// CHECK-NEXT:    ret <4 x double> [[TMP8]]
//
v4f64 ffmsdcp(v4f64 a, v4f64 b, v4f64 c) {
  return __builtin_kvx_ffmsdcp(a, b, c, ".rn");
}

// CHECK-LABEL: @fmulcdcp(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = shufflevector <4 x double> [[A:%.*]], <4 x double> undef, <2 x i32> <i32 0, i32 1>
// CHECK-NEXT:    [[TMP1:%.*]] = shufflevector <4 x double> [[B:%.*]], <4 x double> undef, <2 x i32> <i32 0, i32 1>
// CHECK-NEXT:    [[TMP2:%.*]] = tail call <2 x double> @llvm.kvx.fmulcdc(<2 x double> [[TMP0]], <2 x double> [[TMP1]], i32 0, i32 0)
// CHECK-NEXT:    [[TMP3:%.*]] = shufflevector <4 x double> [[A]], <4 x double> undef, <2 x i32> <i32 2, i32 3>
// CHECK-NEXT:    [[TMP4:%.*]] = shufflevector <4 x double> [[B]], <4 x double> undef, <2 x i32> <i32 2, i32 3>
// CHECK-NEXT:    [[TMP5:%.*]] = tail call <2 x double> @llvm.kvx.fmulcdc(<2 x double> [[TMP3]], <2 x double> [[TMP4]], i32 0, i32 0)
// CHECK-NEXT:    [[TMP6:%.*]] = shufflevector <2 x double> [[TMP2]], <2 x double> [[TMP5]], <4 x i32> <i32 0, i32 1, i32 2, i32 3>
// CHECK-NEXT:    ret <4 x double> [[TMP6]]
//
v4f64 fmulcdcp(v4f64 a, v4f64 b) {
  return __builtin_kvx_fmuldcp(a, b, ".c.rn");
}

// CHECK-LABEL: @ffmacdcp(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = shufflevector <4 x double> [[A:%.*]], <4 x double> undef, <2 x i32> <i32 0, i32 1>
// CHECK-NEXT:    [[TMP1:%.*]] = shufflevector <4 x double> [[B:%.*]], <4 x double> undef, <2 x i32> <i32 0, i32 1>
// CHECK-NEXT:    [[TMP2:%.*]] = shufflevector <4 x double> [[C:%.*]], <4 x double> undef, <2 x i32> <i32 0, i32 1>
// CHECK-NEXT:    [[TMP3:%.*]] = tail call <2 x double> @llvm.kvx.ffmacdc(<2 x double> [[TMP0]], <2 x double> [[TMP1]], <2 x double> [[TMP2]], i32 0, i32 0)
// CHECK-NEXT:    [[TMP4:%.*]] = shufflevector <4 x double> [[A]], <4 x double> undef, <2 x i32> <i32 2, i32 3>
// CHECK-NEXT:    [[TMP5:%.*]] = shufflevector <4 x double> [[B]], <4 x double> undef, <2 x i32> <i32 2, i32 3>
// CHECK-NEXT:    [[TMP6:%.*]] = shufflevector <4 x double> [[C]], <4 x double> undef, <2 x i32> <i32 2, i32 3>
// CHECK-NEXT:    [[TMP7:%.*]] = tail call <2 x double> @llvm.kvx.ffmacdc(<2 x double> [[TMP4]], <2 x double> [[TMP5]], <2 x double> [[TMP6]], i32 0, i32 0)
// CHECK-NEXT:    [[TMP8:%.*]] = shufflevector <2 x double> [[TMP3]], <2 x double> [[TMP7]], <4 x i32> <i32 0, i32 1, i32 2, i32 3>
// CHECK-NEXT:    ret <4 x double> [[TMP8]]
//
v4f64 ffmacdcp(v4f64 a, v4f64 b, v4f64 c) {
  return __builtin_kvx_ffmadcp(a, b, c, ".c.rn");
}

// CHECK-LABEL: @ffmscdcp(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = shufflevector <4 x double> [[A:%.*]], <4 x double> undef, <2 x i32> <i32 0, i32 1>
// CHECK-NEXT:    [[TMP1:%.*]] = shufflevector <4 x double> [[B:%.*]], <4 x double> undef, <2 x i32> <i32 0, i32 1>
// CHECK-NEXT:    [[TMP2:%.*]] = shufflevector <4 x double> [[C:%.*]], <4 x double> undef, <2 x i32> <i32 0, i32 1>
// CHECK-NEXT:    [[TMP3:%.*]] = tail call <2 x double> @llvm.kvx.ffmscdc(<2 x double> [[TMP0]], <2 x double> [[TMP1]], <2 x double> [[TMP2]], i32 0, i32 0)
// CHECK-NEXT:    [[TMP4:%.*]] = shufflevector <4 x double> [[A]], <4 x double> undef, <2 x i32> <i32 2, i32 3>
// CHECK-NEXT:    [[TMP5:%.*]] = shufflevector <4 x double> [[B]], <4 x double> undef, <2 x i32> <i32 2, i32 3>
// CHECK-NEXT:    [[TMP6:%.*]] = shufflevector <4 x double> [[C]], <4 x double> undef, <2 x i32> <i32 2, i32 3>
// CHECK-NEXT:    [[TMP7:%.*]] = tail call <2 x double> @llvm.kvx.ffmscdc(<2 x double> [[TMP4]], <2 x double> [[TMP5]], <2 x double> [[TMP6]], i32 0, i32 0)
// CHECK-NEXT:    [[TMP8:%.*]] = shufflevector <2 x double> [[TMP3]], <2 x double> [[TMP7]], <4 x i32> <i32 0, i32 1, i32 2, i32 3>
// CHECK-NEXT:    ret <4 x double> [[TMP8]]
//
v4f64 ffmscdcp(v4f64 a, v4f64 b, v4f64 c) {
  return __builtin_kvx_ffmsdcp(a, b, c, ".c.rn");
}

// CHECK-LABEL: @fconjdcp(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = shufflevector <4 x double> [[A:%.*]], <4 x double> undef, <2 x i32> <i32 0, i32 1>
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <2 x double> @llvm.kvx.fconjdc(<2 x double> [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = shufflevector <4 x double> [[A]], <4 x double> undef, <2 x i32> <i32 2, i32 3>
// CHECK-NEXT:    [[TMP3:%.*]] = tail call <2 x double> @llvm.kvx.fconjdc(<2 x double> [[TMP2]])
// CHECK-NEXT:    [[TMP4:%.*]] = shufflevector <2 x double> [[TMP1]], <2 x double> [[TMP3]], <4 x i32> <i32 0, i32 1, i32 2, i32 3>
// CHECK-NEXT:    ret <4 x double> [[TMP4]]
//
v4f64 fconjdcp(v4f64 a) {
  return __builtin_kvx_fconjdcp(a);
}
