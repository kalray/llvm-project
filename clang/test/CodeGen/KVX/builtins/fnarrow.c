// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// RUN: %clang_cc1 -triple kvx-kalray-cos -O2 -emit-llvm -o - %s | FileCheck %s
#include "vector-types.h"

// CHECK-LABEL: @fnarrowwh(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call half @llvm.kvx.fnarrow.f16(float [[V:%.*]], i32 1, i32 1)
// CHECK-NEXT:    ret half [[TMP0]]
//
half fnarrowwh(float v) {
  return __builtin_kvx_fnarrowwh(v, ".ru.s");
}

// CHECK-LABEL: @fnarrowdw(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call float @llvm.kvx.fnarrow.f32(double [[V:%.*]], i32 1, i32 1)
// CHECK-NEXT:    ret float [[TMP0]]
//
float fnarrowdw(double v) {
  return __builtin_kvx_fnarrowdw(v, ".ru.s");
}

// CHECK-LABEL: @fnarrowwhq(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <4 x half> @llvm.kvx.fnarrow.v4f16(<4 x float> [[V:%.*]], i32 1, i32 1)
// CHECK-NEXT:    ret <4 x half> [[TMP0]]
//
v4f16 fnarrowwhq(v4f32 v) {
  return __builtin_kvx_fnarrowwhq(v, ".ru.s");
}

// CHECK-LABEL: @fnarrowwho(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = shufflevector <8 x float> [[V:%.*]], <8 x float> poison, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <4 x half> @llvm.kvx.fnarrow.v4f16(<4 x float> [[TMP0]], i32 1, i32 1)
// CHECK-NEXT:    [[TMP2:%.*]] = shufflevector <8 x float> [[V]], <8 x float> poison, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
// CHECK-NEXT:    [[TMP3:%.*]] = tail call <4 x half> @llvm.kvx.fnarrow.v4f16(<4 x float> [[TMP2]], i32 1, i32 1)
// CHECK-NEXT:    [[TMP4:%.*]] = shufflevector <4 x half> [[TMP1]], <4 x half> [[TMP3]], <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
// CHECK-NEXT:    ret <8 x half> [[TMP4]]
//
v8f16 fnarrowwho(v8f32 v) {
  return __builtin_kvx_fnarrowwho(v, ".ru.s");
}

// CHECK-LABEL: @fnarrowdwp(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <2 x float> @llvm.kvx.fnarrow.v2f32(<2 x double> [[V:%.*]], i32 1, i32 1)
// CHECK-NEXT:    ret <2 x float> [[TMP0]]
//
v2f32 fnarrowdwp(v2f64 v) {
  return __builtin_kvx_fnarrowdwp(v, ".ru.s");
}

// CHECK-LABEL: @fnarrowdwq(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = shufflevector <4 x double> [[V:%.*]], <4 x double> poison, <2 x i32> <i32 0, i32 1>
// CHECK-NEXT:    [[TMP1:%.*]] = tail call <2 x float> @llvm.kvx.fnarrow.v2f32(<2 x double> [[TMP0]], i32 1, i32 1)
// CHECK-NEXT:    [[TMP2:%.*]] = shufflevector <4 x double> [[V]], <4 x double> poison, <2 x i32> <i32 2, i32 3>
// CHECK-NEXT:    [[TMP3:%.*]] = tail call <2 x float> @llvm.kvx.fnarrow.v2f32(<2 x double> [[TMP2]], i32 1, i32 1)
// CHECK-NEXT:    [[TMP4:%.*]] = shufflevector <2 x float> [[TMP1]], <2 x float> [[TMP3]], <4 x i32> <i32 0, i32 1, i32 2, i32 3>
// CHECK-NEXT:    ret <4 x float> [[TMP4]]
//
v4f32 fnarrowdwq(v4f64 v) {
  return __builtin_kvx_fnarrowdwq(v, ".ru.s");
}
