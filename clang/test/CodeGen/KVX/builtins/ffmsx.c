// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// RUN: %clang_cc1 -triple kvx-kalray-cos -S -O2 -emit-llvm -o - %s | FileCheck %s
#include "vector-types.h"

// CHECK-LABEL: @ffmsxhwri1(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call float @llvm.kvx.ffmsx.f32(half [[V1:%.*]], half 0xH4500, float [[V2:%.*]], i32 7, i32 0)
// CHECK-NEXT:    ret float [[TMP0]]
//
float ffmsxhwri1(half v1, float v2) { return __builtin_kvx_ffmsxhw(v1, 5.0f16, v2, ""); }

// CHECK-LABEL: @ffmsxhwri2(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call float @llvm.kvx.ffmsx.f32(half 0xH4500, half [[V1:%.*]], float [[V2:%.*]], i32 7, i32 0)
// CHECK-NEXT:    ret float [[TMP0]]
//
float ffmsxhwri2(half v1, float v2) { return __builtin_kvx_ffmsxhw(5.0f16, v1, v2, ""); }

// CHECK-LABEL: @ffmsxhwrr(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call float @llvm.kvx.ffmsx.f32(half [[V0:%.*]], half [[V1:%.*]], float [[V2:%.*]], i32 7, i32 0)
// CHECK-NEXT:    ret float [[TMP0]]
//
float ffmsxhwrr(half v0, half v1, float v2) { return __builtin_kvx_ffmsxhw(v0, v1, v2, ""); }

// CHECK-LABEL: @ffmsxhwo(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = shufflevector <8 x half> [[V0:%.*]], <8 x half> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
// CHECK-NEXT:    [[TMP1:%.*]] = shufflevector <8 x half> [[V1:%.*]], <8 x half> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
// CHECK-NEXT:    [[TMP2:%.*]] = shufflevector <8 x float> [[V2:%.*]], <8 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
// CHECK-NEXT:    [[TMP3:%.*]] = tail call <4 x float> @llvm.kvx.ffmsx.v4f32(<4 x half> [[TMP0]], <4 x half> [[TMP1]], <4 x float> [[TMP2]], i32 7, i32 0)
// CHECK-NEXT:    [[TMP4:%.*]] = shufflevector <8 x half> [[V0]], <8 x half> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
// CHECK-NEXT:    [[TMP5:%.*]] = shufflevector <8 x half> [[V1]], <8 x half> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
// CHECK-NEXT:    [[TMP6:%.*]] = shufflevector <8 x float> [[V2]], <8 x float> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
// CHECK-NEXT:    [[TMP7:%.*]] = tail call <4 x float> @llvm.kvx.ffmsx.v4f32(<4 x half> [[TMP4]], <4 x half> [[TMP5]], <4 x float> [[TMP6]], i32 7, i32 0)
// CHECK-NEXT:    [[TMP8:%.*]] = shufflevector <4 x float> [[TMP3]], <4 x float> [[TMP7]], <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
// CHECK-NEXT:    ret <8 x float> [[TMP8]]
//
v8f32 ffmsxhwo(v8f16 v0, v8f16 v1, v8f32 v2) { return __builtin_kvx_ffmsxhwo(v0, v1, v2, ""); }

// CHECK-LABEL: @ffmsxhwp(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <2 x float> @llvm.kvx.ffmsx.v2f32(<2 x half> [[V0:%.*]], <2 x half> [[V1:%.*]], <2 x float> [[V2:%.*]], i32 7, i32 1)
// CHECK-NEXT:    ret <2 x float> [[TMP0]]
//
v2f32 ffmsxhwp(v2f16 v0, v2f16 v1, v2f32 v2) { return __builtin_kvx_ffmsxhwp(v0, v1, v2, ".s"); }

// CHECK-LABEL: @ffmsxhwp_2(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <2 x float> @llvm.kvx.ffmsx.v2f32(<2 x half> [[V0:%.*]], <2 x half> [[V1:%.*]], <2 x float> [[V2:%.*]], i32 7, i32 0)
// CHECK-NEXT:    ret <2 x float> [[TMP0]]
//
v2f32 ffmsxhwp_2(v2f16 v0, v2f16 v1, v2f32 v2) { return __builtin_kvx_ffmsxhwp(v0, v1, v2, ""); }

// CHECK-LABEL: @ffmsxhwq(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <4 x float> @llvm.kvx.ffmsx.v4f32(<4 x half> [[V0:%.*]], <4 x half> [[V1:%.*]], <4 x float> [[V2:%.*]], i32 7, i32 0)
// CHECK-NEXT:    ret <4 x float> [[TMP0]]
//
v4f32 ffmsxhwq(v4f16 v0, v4f16 v1, v4f32 v2) { return __builtin_kvx_ffmsxhwq(v0, v1, v2, ""); }

// CHECK-LABEL: @ffmsxwd(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call double @llvm.kvx.ffmsx.f64(float [[V0:%.*]], float [[V1:%.*]], double [[V2:%.*]], i32 7, i32 0)
// CHECK-NEXT:    ret double [[TMP0]]
//
double ffmsxwd(float v0, float v1, double v2) { return __builtin_kvx_ffmsxwd(v0, v1, v2, ""); }

// CHECK-LABEL: @ffmsxwdri(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call double @llvm.kvx.ffmsx.f64(float 0x400921CAC0000000, float [[V1:%.*]], double [[V2:%.*]], i32 7, i32 0)
// CHECK-NEXT:    ret double [[TMP0]]
//
double ffmsxwdri(float v1, double v2) { return __builtin_kvx_ffmsxwd(3.1415, v1, v2, ""); }

// CHECK-LABEL: @ffmsxwdri2(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call double @llvm.kvx.ffmsx.f64(float [[V1:%.*]], float 0x400921CAC0000000, double [[V2:%.*]], i32 7, i32 0)
// CHECK-NEXT:    ret double [[TMP0]]
//
double ffmsxwdri2(float v1, double v2) { return __builtin_kvx_ffmsxwd(v1, 3.1415, v2, ""); }

// CHECK-LABEL: @ffmsxwdp(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <2 x double> @llvm.kvx.ffmsx.v2f64(<2 x float> [[V0:%.*]], <2 x float> [[V1:%.*]], <2 x double> [[V2:%.*]], i32 7, i32 0)
// CHECK-NEXT:    ret <2 x double> [[TMP0]]
//
v2f64 ffmsxwdp(v2f32 v0, v2f32 v1, v2f64 v2) { return __builtin_kvx_ffmsxwdp(v0, v1, v2, ""); }

// CHECK-LABEL: @ffmsxwdq(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = shufflevector <4 x float> [[V0:%.*]], <4 x float> undef, <2 x i32> <i32 0, i32 1>
// CHECK-NEXT:    [[TMP1:%.*]] = shufflevector <4 x float> [[V1:%.*]], <4 x float> undef, <2 x i32> <i32 0, i32 1>
// CHECK-NEXT:    [[TMP2:%.*]] = shufflevector <4 x double> [[V2:%.*]], <4 x double> undef, <2 x i32> <i32 0, i32 1>
// CHECK-NEXT:    [[TMP3:%.*]] = tail call <2 x double> @llvm.kvx.ffmsx.v2f64(<2 x float> [[TMP0]], <2 x float> [[TMP1]], <2 x double> [[TMP2]], i32 7, i32 0)
// CHECK-NEXT:    [[TMP4:%.*]] = shufflevector <4 x float> [[V0]], <4 x float> undef, <2 x i32> <i32 2, i32 3>
// CHECK-NEXT:    [[TMP5:%.*]] = shufflevector <4 x float> [[V1]], <4 x float> undef, <2 x i32> <i32 2, i32 3>
// CHECK-NEXT:    [[TMP6:%.*]] = shufflevector <4 x double> [[V2]], <4 x double> undef, <2 x i32> <i32 2, i32 3>
// CHECK-NEXT:    [[TMP7:%.*]] = tail call <2 x double> @llvm.kvx.ffmsx.v2f64(<2 x float> [[TMP4]], <2 x float> [[TMP5]], <2 x double> [[TMP6]], i32 7, i32 0)
// CHECK-NEXT:    [[TMP8:%.*]] = shufflevector <2 x double> [[TMP3]], <2 x double> [[TMP7]], <4 x i32> <i32 0, i32 1, i32 2, i32 3>
// CHECK-NEXT:    ret <4 x double> [[TMP8]]
//
v4f64 ffmsxwdq(v4f32 v0, v4f32 v1, v4f64 v2) { return __builtin_kvx_ffmsxwdq(v0, v1, v2, ""); }
