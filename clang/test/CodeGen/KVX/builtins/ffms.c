// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// RUN: %clang_cc1 -triple kvx-kalray-cos -S -O2 -emit-llvm -o - %s | FileCheck %s
#include "vector-types.h"
// CHECK-LABEL: @ffmsd(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call double @llvm.kvx.ffms.f64(double [[A:%.*]], double [[B:%.*]], double [[C:%.*]], i32 3, i32 0)
// CHECK-NEXT:    ret double [[TMP0]]
//
double ffmsd(double a, double b, double c) { return __builtin_kvx_ffmsd(a, b, c, ".rz"); }
// CHECK-LABEL: @ffmsdp(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <2 x double> @llvm.kvx.ffms.v2f64(<2 x double> [[V1:%.*]], <2 x double> [[V2:%.*]], <2 x double> [[V3:%.*]], i32 0, i32 0)
// CHECK-NEXT:    ret <2 x double> [[TMP0]]
//
v2f64 ffmsdp(v2f64 v1, v2f64 v2, v2f64 v3) { return __builtin_kvx_ffmsdp(v1, v2, v3, ".rn"); }
// CHECK-LABEL: @ffmsdq(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = shufflevector <4 x double> [[V1:%.*]], <4 x double> undef, <2 x i32> <i32 0, i32 1>
// CHECK-NEXT:    [[TMP1:%.*]] = shufflevector <4 x double> [[V2:%.*]], <4 x double> undef, <2 x i32> <i32 0, i32 1>
// CHECK-NEXT:    [[TMP2:%.*]] = shufflevector <4 x double> [[V3:%.*]], <4 x double> undef, <2 x i32> <i32 0, i32 1>
// CHECK-NEXT:    [[TMP3:%.*]] = tail call <2 x double> @llvm.kvx.ffms.v2f64(<2 x double> [[TMP0]], <2 x double> [[TMP1]], <2 x double> [[TMP2]], i32 0, i32 0)
// CHECK-NEXT:    [[TMP4:%.*]] = shufflevector <4 x double> [[V1]], <4 x double> undef, <2 x i32> <i32 2, i32 3>
// CHECK-NEXT:    [[TMP5:%.*]] = shufflevector <4 x double> [[V2]], <4 x double> undef, <2 x i32> <i32 2, i32 3>
// CHECK-NEXT:    [[TMP6:%.*]] = shufflevector <4 x double> [[V3]], <4 x double> undef, <2 x i32> <i32 2, i32 3>
// CHECK-NEXT:    [[TMP7:%.*]] = tail call <2 x double> @llvm.kvx.ffms.v2f64(<2 x double> [[TMP4]], <2 x double> [[TMP5]], <2 x double> [[TMP6]], i32 0, i32 0)
// CHECK-NEXT:    [[TMP8:%.*]] = shufflevector <2 x double> [[TMP3]], <2 x double> [[TMP7]], <4 x i32> <i32 0, i32 1, i32 2, i32 3>
// CHECK-NEXT:    ret <4 x double> [[TMP8]]
//
v4f64 ffmsdq(v4f64 v1, v4f64 v2, v4f64 v3) { return __builtin_kvx_ffmsdq(v1, v2, v3, ".rn"); }
// CHECK-LABEL: @ffmsh(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call half @llvm.kvx.ffms.f16(half [[A:%.*]], half [[B:%.*]], half [[C:%.*]], i32 1, i32 1)
// CHECK-NEXT:    ret half [[TMP0]]
//
half ffmsh(half a, half b, half c) { return __builtin_kvx_ffmsh(a, b, c, ".ru.s"); }
// CHECK-LABEL: @ffmshp(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <2 x half> @llvm.kvx.ffms.v2f16(<2 x half> [[V1:%.*]], <2 x half> [[V2:%.*]], <2 x half> [[V3:%.*]], i32 3, i32 1)
// CHECK-NEXT:    ret <2 x half> [[TMP0]]
//
v2f16 ffmshp(v2f16 v1, v2f16 v2, v2f16 v3) { return __builtin_kvx_ffmshp(v1, v2, v3, ".rz.s"); }
// CHECK-LABEL: @ffmshq(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <4 x half> @llvm.kvx.ffms.v4f16(<4 x half> [[V1:%.*]], <4 x half> [[V2:%.*]], <4 x half> [[V3:%.*]], i32 1, i32 1)
// CHECK-NEXT:    ret <4 x half> [[TMP0]]
//
v4f16 ffmshq(v4f16 v1, v4f16 v2, v4f16 v3) { return __builtin_kvx_ffmshq(v1, v2, v3, ".ru.s"); }
// CHECK-LABEL: @ffmsw(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call float @llvm.kvx.ffms.f32(float [[A:%.*]], float [[B:%.*]], float [[C:%.*]], i32 3, i32 0)
// CHECK-NEXT:    ret float [[TMP0]]
//
float ffmsw(float a, float b, float c) { return __builtin_kvx_ffmsw(a, b, c, ".rz"); }
// CHECK-LABEL: @ffmswo(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = shufflevector <8 x float> [[V1:%.*]], <8 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
// CHECK-NEXT:    [[TMP1:%.*]] = shufflevector <8 x float> [[V2:%.*]], <8 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
// CHECK-NEXT:    [[TMP2:%.*]] = shufflevector <8 x float> [[V3:%.*]], <8 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
// CHECK-NEXT:    [[TMP3:%.*]] = tail call <4 x float> @llvm.kvx.ffms.v4f32(<4 x float> [[TMP0]], <4 x float> [[TMP1]], <4 x float> [[TMP2]], i32 0, i32 0)
// CHECK-NEXT:    [[TMP4:%.*]] = shufflevector <8 x float> [[V1]], <8 x float> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
// CHECK-NEXT:    [[TMP5:%.*]] = shufflevector <8 x float> [[V2]], <8 x float> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
// CHECK-NEXT:    [[TMP6:%.*]] = shufflevector <8 x float> [[V3]], <8 x float> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
// CHECK-NEXT:    [[TMP7:%.*]] = tail call <4 x float> @llvm.kvx.ffms.v4f32(<4 x float> [[TMP4]], <4 x float> [[TMP5]], <4 x float> [[TMP6]], i32 0, i32 0)
// CHECK-NEXT:    [[TMP8:%.*]] = shufflevector <4 x float> [[TMP3]], <4 x float> [[TMP7]], <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
// CHECK-NEXT:    ret <8 x float> [[TMP8]]
//
v8f32 ffmswo(v8f32 v1, v8f32 v2, v8f32 v3) { return __builtin_kvx_ffmswo(v1, v2, v3, ".rn"); }
// CHECK-LABEL: @ffmswp(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <2 x float> @llvm.kvx.ffms.v2f32(<2 x float> [[V1:%.*]], <2 x float> [[V2:%.*]], <2 x float> [[V3:%.*]], i32 0, i32 0)
// CHECK-NEXT:    ret <2 x float> [[TMP0]]
//
v2f32 ffmswp(v2f32 v1, v2f32 v2, v2f32 v3) { return __builtin_kvx_ffmswp(v1, v2, v3, ".rn"); }
// CHECK-LABEL: @ffmswq(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call <4 x float> @llvm.kvx.ffms.v4f32(<4 x float> [[V1:%.*]], <4 x float> [[V2:%.*]], <4 x float> [[V3:%.*]], i32 0, i32 0)
// CHECK-NEXT:    ret <4 x float> [[TMP0]]
//
v4f32 ffmswq(v4f32 v1, v4f32 v2, v4f32 v3) { return __builtin_kvx_ffmswq(v1, v2, v3, ".rn"); }
