// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// RUN: %clang_cc1 -triple kvx-kalray-cos -fnative-half-arguments-and-returns -Wno-implicit-function-declaration -O1 -emit-llvm -o - %s | FileCheck %s

double fma(double, double, double);
float fmaf(float, float, float);
_Float16 fmaf16(_Float16, _Float16, _Float16);

// CHECK-LABEL: @my_fma(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call double @llvm.fma.f64(double [[X:%.*]], double [[Y:%.*]], double [[Z:%.*]])
// CHECK-NEXT:    ret double [[TMP0]]
//
double my_fma(double x, double y, double z)
{
    return fma(x, y, z);
}

// CHECK-LABEL: @my_fmaf(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call float @llvm.fma.f32(float [[X:%.*]], float [[Y:%.*]], float [[Z:%.*]])
// CHECK-NEXT:    ret float [[TMP0]]
//
float my_fmaf(float x, float y, float z)
{
    return fmaf(x, y, z);
}

// TODO: Make the same happen to half arguments.
// CHECK-LABEL: @my_fmah(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[CALL:%.*]] = tail call half @fmaf16(half noundef [[X:%.*]], half noundef [[Y:%.*]], half noundef [[Z:%.*]]) #[[ATTR4:[0-9]+]]
// CHECK-NEXT:    ret half [[CALL]]
//
_Float16 my_fmah(_Float16 x, _Float16 y, _Float16 z)
{
    return fmaf16(x, y, z);
}
