// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --function-signature --check-globals
// RUN: %clang_cc1 %s -DCL20 -O0 -triple kvx-kalray-cos-elf -emit-llvm -cl-std=CL2.0 -o - | FileCheck --check-prefixes=CHECK %s
// RUN: %clang_cc1 %s -DCL20 -O0 -triple kvx-kalray-osp-elf -emit-llvm -cl-std=CL2.0 -o - | FileCheck --check-prefixes=CHECK %s


struct S {
  int x;
  int y;
  int *z;
};


struct S g_s;

//.
// CHECK: @f.ii = internal addrspace(1) global i32 0, align 4
// CHECK: @g_s = addrspace(1) global %struct.S zeroinitializer, align 8
// CHECK: @g_extern_var = external addrspace(1) global float, align 4
// CHECK: @l_extern_var = external addrspace(1) global float, align 4
// CHECK: @test_static.l_static_var = internal addrspace(1) global float 0.000000e+00, align 4
// CHECK: @g_static_var = internal addrspace(1) global float 0.000000e+00, align 4
// CHECK: @i = addrspace(1) global i32 0, align 4
// CHECK: @ptr = addrspace(1) global ptr addrspace(5) null, align 8
//.
// CHECK-LABEL: define {{[^@]+}}@f__p
// CHECK-SAME: (ptr addrspace(4) noundef [[ARG:%.*]]) #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[ARG_ADDR:%.*]] = alloca ptr addrspace(4), align 8
// CHECK-NEXT:    store ptr addrspace(4) [[ARG]], ptr [[ARG_ADDR]], align 8
// CHECK-NEXT:    ret void
//
void f__p(__private int *arg) {}

// CHECK-LABEL: define {{[^@]+}}@f__g
// CHECK-SAME: (ptr addrspace(1) noundef [[ARG:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[ARG_ADDR:%.*]] = alloca ptr addrspace(1), align 8
// CHECK-NEXT:    store ptr addrspace(1) [[ARG]], ptr [[ARG_ADDR]], align 8
// CHECK-NEXT:    ret void
//
void f__g(__global int *arg) {}

// CHECK-LABEL: define {{[^@]+}}@f__l
// CHECK-SAME: (ptr addrspace(2) noundef [[ARG:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[ARG_ADDR:%.*]] = alloca ptr addrspace(2), align 8
// CHECK-NEXT:    store ptr addrspace(2) [[ARG]], ptr [[ARG_ADDR]], align 8
// CHECK-NEXT:    ret void
//
void f__l(__local int *arg) {}

// CHECK-LABEL: define {{[^@]+}}@f__c
// CHECK-SAME: (ptr addrspace(3) noundef [[ARG:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[ARG_ADDR:%.*]] = alloca ptr addrspace(3), align 8
// CHECK-NEXT:    store ptr addrspace(3) [[ARG]], ptr [[ARG_ADDR]], align 8
// CHECK-NEXT:    ret void
//
void f__c(__constant int *arg) {}

// CHECK-LABEL: define {{[^@]+}}@fp
// CHECK-SAME: (ptr addrspace(4) noundef [[ARG:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[ARG_ADDR:%.*]] = alloca ptr addrspace(4), align 8
// CHECK-NEXT:    store ptr addrspace(4) [[ARG]], ptr [[ARG_ADDR]], align 8
// CHECK-NEXT:    ret void
//
void fp(private int *arg) {}

// CHECK-LABEL: define {{[^@]+}}@fg
// CHECK-SAME: (ptr addrspace(1) noundef [[ARG:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[ARG_ADDR:%.*]] = alloca ptr addrspace(1), align 8
// CHECK-NEXT:    store ptr addrspace(1) [[ARG]], ptr [[ARG_ADDR]], align 8
// CHECK-NEXT:    ret void
//
void fg(global int *arg) {}

// CHECK-LABEL: define {{[^@]+}}@fl
// CHECK-SAME: (ptr addrspace(2) noundef [[ARG:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[ARG_ADDR:%.*]] = alloca ptr addrspace(2), align 8
// CHECK-NEXT:    store ptr addrspace(2) [[ARG]], ptr [[ARG_ADDR]], align 8
// CHECK-NEXT:    ret void
//
void fl(local int *arg) {}

// CHECK-LABEL: define {{[^@]+}}@fc
// CHECK-SAME: (ptr addrspace(3) noundef [[ARG:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[ARG_ADDR:%.*]] = alloca ptr addrspace(3), align 8
// CHECK-NEXT:    store ptr addrspace(3) [[ARG]], ptr [[ARG_ADDR]], align 8
// CHECK-NEXT:    ret void
//
void fc(constant int *arg) {}

// CHECK-LABEL: define {{[^@]+}}@fd
// CHECK-SAME: (ptr addrspace(6) noundef [[ARG:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[ARG_ADDR:%.*]] = alloca ptr addrspace(6), align 8
// CHECK-NEXT:    store ptr addrspace(6) [[ARG]], ptr [[ARG_ADDR]], align 8
// CHECK-NEXT:    ret void
//
void fd(__attribute__((opencl_global_device)) int *arg) {}

// CHECK-LABEL: define {{[^@]+}}@fh
// CHECK-SAME: (ptr addrspace(7) noundef [[ARG:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[ARG_ADDR:%.*]] = alloca ptr addrspace(7), align 8
// CHECK-NEXT:    store ptr addrspace(7) [[ARG]], ptr [[ARG_ADDR]], align 8
// CHECK-NEXT:    ret void
//
void fh(__attribute__((opencl_global_host)) int *arg) {}

int i;
int *ptr;

// CHECK-LABEL: define {{[^@]+}}@f
// CHECK-SAME: (ptr addrspace(5) noundef [[ARG:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[ARG_ADDR:%.*]] = alloca ptr addrspace(5), align 8
// CHECK-NEXT:    [[I:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store ptr addrspace(5) [[ARG]], ptr [[ARG_ADDR]], align 8
// CHECK-NEXT:    ret void
//
void f(int *arg) {

  int i;

  static int ii;
}

typedef int int_td;
typedef int *intp_td;
// CHECK-LABEL: define {{[^@]+}}@test_typedef
// CHECK-SAME: (ptr addrspace(1) noundef [[X:%.*]], ptr addrspace(3) noundef [[Y:%.*]], ptr addrspace(5) noundef [[Z:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[X_ADDR:%.*]] = alloca ptr addrspace(1), align 8
// CHECK-NEXT:    [[Y_ADDR:%.*]] = alloca ptr addrspace(3), align 8
// CHECK-NEXT:    [[Z_ADDR:%.*]] = alloca ptr addrspace(5), align 8
// CHECK-NEXT:    store ptr addrspace(1) [[X]], ptr [[X_ADDR]], align 8
// CHECK-NEXT:    store ptr addrspace(3) [[Y]], ptr [[Y_ADDR]], align 8
// CHECK-NEXT:    store ptr addrspace(5) [[Z]], ptr [[Z_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr addrspace(3), ptr [[Y_ADDR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr addrspace(3) [[TMP0]], align 4
// CHECK-NEXT:    [[TMP2:%.*]] = load ptr addrspace(1), ptr [[X_ADDR]], align 8
// CHECK-NEXT:    store i32 [[TMP1]], ptr addrspace(1) [[TMP2]], align 4
// CHECK-NEXT:    [[TMP3:%.*]] = load ptr addrspace(5), ptr [[Z_ADDR]], align 8
// CHECK-NEXT:    store i32 0, ptr addrspace(5) [[TMP3]], align 4
// CHECK-NEXT:    ret void
//
void test_typedef(global int_td *x, constant int_td *y, intp_td z) {
  *x = *y;
  *z = 0;
}

// CHECK-LABEL: define {{[^@]+}}@test_struct
// CHECK-SAME: () #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[PS:%.*]] = alloca ptr addrspace(5), align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr addrspace(5), ptr [[PS]], align 8
// CHECK-NEXT:    [[X:%.*]] = getelementptr inbounds [[STRUCT_S:%.*]], ptr addrspace(5) [[TMP0]], i32 0, i32 0
// CHECK-NEXT:    store i32 0, ptr addrspace(5) [[X]], align 8
// CHECK-NEXT:    store i32 0, ptr addrspace(1) @g_s, align 8
// CHECK-NEXT:    ret void
//
void test_struct() {
      struct S *ps;
      ps->x = 0;
      g_s.x = 0;
}

// CHECK-LABEL: define {{[^@]+}}@test_void_par
// CHECK-SAME: () #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret void
//
void test_void_par(void) {}

// CHECK-LABEL: define {{[^@]+}}@test_func_return_type
// CHECK-SAME: () #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret i32 0
//
int test_func_return_type(void) {
  return 0;
}

extern float g_extern_var;

// CHECK-LABEL: define {{[^@]+}}@test_extern
// CHECK-SAME: (ptr addrspace(1) noundef align 4 [[BUF:%.*]]) #[[ATTR1:[0-9]+]] !kernel_arg_addr_space !3 !kernel_arg_access_qual !4 !kernel_arg_type !5 !kernel_arg_base_type !5 !kernel_arg_type_qual !6 {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[BUF_ADDR:%.*]] = alloca ptr addrspace(1), align 8
// CHECK-NEXT:    store ptr addrspace(1) [[BUF]], ptr [[BUF_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load float, ptr addrspace(1) @g_extern_var, align 4
// CHECK-NEXT:    [[TMP1:%.*]] = load float, ptr addrspace(1) @l_extern_var, align 4
// CHECK-NEXT:    [[ADD:%.*]] = fadd float [[TMP0]], [[TMP1]]
// CHECK-NEXT:    [[TMP2:%.*]] = load ptr addrspace(1), ptr [[BUF_ADDR]], align 8
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds float, ptr addrspace(1) [[TMP2]], i64 0
// CHECK-NEXT:    [[TMP3:%.*]] = load float, ptr addrspace(1) [[ARRAYIDX]], align 4
// CHECK-NEXT:    [[ADD1:%.*]] = fadd float [[TMP3]], [[ADD]]
// CHECK-NEXT:    store float [[ADD1]], ptr addrspace(1) [[ARRAYIDX]], align 4
// CHECK-NEXT:    ret void
//
kernel void test_extern(global float *buf) {
  extern float l_extern_var;
  buf[0] += g_extern_var + l_extern_var;
}

static float g_static_var;

// CHECK-LABEL: define {{[^@]+}}@test_static
// CHECK-SAME: (ptr addrspace(1) noundef align 4 [[BUF:%.*]]) #[[ATTR1]] !kernel_arg_addr_space !3 !kernel_arg_access_qual !4 !kernel_arg_type !5 !kernel_arg_base_type !5 !kernel_arg_type_qual !6 {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[BUF_ADDR:%.*]] = alloca ptr addrspace(1), align 8
// CHECK-NEXT:    store ptr addrspace(1) [[BUF]], ptr [[BUF_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load float, ptr addrspace(1) @g_static_var, align 4
// CHECK-NEXT:    [[TMP1:%.*]] = load float, ptr addrspace(1) @test_static.l_static_var, align 4
// CHECK-NEXT:    [[ADD:%.*]] = fadd float [[TMP0]], [[TMP1]]
// CHECK-NEXT:    [[TMP2:%.*]] = load ptr addrspace(1), ptr [[BUF_ADDR]], align 8
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds float, ptr addrspace(1) [[TMP2]], i64 0
// CHECK-NEXT:    [[TMP3:%.*]] = load float, ptr addrspace(1) [[ARRAYIDX]], align 4
// CHECK-NEXT:    [[ADD1:%.*]] = fadd float [[TMP3]], [[ADD]]
// CHECK-NEXT:    store float [[ADD1]], ptr addrspace(1) [[ARRAYIDX]], align 4
// CHECK-NEXT:    ret void
//
kernel void test_static(global float *buf) {
  static float l_static_var;
  buf[0] += g_static_var + l_static_var;
}
//.
// CHECK: attributes #[[ATTR0]] = { convergent noinline norecurse nounwind optnone "no-trapping-math"="true" "stack-protector-buffer-size"="8" }
// CHECK: attributes #[[ATTR1]] = { convergent noinline norecurse nounwind optnone "no-trapping-math"="true" "stack-protector-buffer-size"="8" "uniform-work-group-size"="false" }
//.
// CHECK: [[META0:![0-9]+]] = !{i32 1, !"wchar_size", i32 4}
// CHECK: [[META1:![0-9]+]] = !{i32 2, i32 0}
// CHECK: [[META2:![0-9]+]] = !{!"{{.*}}clang version {{.*}}"}
// CHECK: [[META3:![0-9]+]] = !{i32 1}
// CHECK: [[META4:![0-9]+]] = !{!"none"}
// CHECK: [[META5:![0-9]+]] = !{!"float*"}
// CHECK: [[META6:![0-9]+]] = !{!""}
//.
